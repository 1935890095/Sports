using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace ZF.UI.Editor
{
	public class CodeExport : ScriptableObject
	{
		public static string GenCsCodePath = "Script/Game/UI/res";

		public static string GenLuaCodePath = "Lua/game/ui/res";

		public CodeExport()
		{
		}

		public static void ExportCSCode()
		{
			Object[] objects = Selection.objects;
			Object[] array = objects;
			foreach (Object val in array)
			{
				CsExport((GameObject)(object)((val is GameObject) ? val : null));
			}
			AssetDatabase.Refresh();
		}

		public static void ExportLuaCode()
		{
			Object[] objects = Selection.objects;
			Object[] array = objects;
			foreach (Object val in array)
			{
				LuaExport((GameObject)(object)((val is GameObject) ? val : null));
			}
			AssetDatabase.Refresh();
		}

		private static void CsExport(GameObject go)
		{
			ExportGroup component = go.GetComponent<ExportGroup>();
			if (component == null)
			{
				Debug.LogErrorFormat("gameobject {0} has no ExportGroup", new object[1] {go.name });
				return;
			}
			string text = Path.Combine(Application.dataPath, GenCsCodePath);
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			string text2 = GenCsCodePath.Replace("/", ".");
			text2 = text2.Replace("Script", "ZF").Replace("Scripts", "ZF");
			string text3 = Path.Combine(text, go.name + ".cs");
			using (FileStream stream = File.Open(text3, FileMode.Create, FileAccess.ReadWrite))
			{
				using StreamWriter writer = new StreamWriter(stream);
				CodeWriter codeWriter = new CodeWriter(writer);
				codeWriter.WriteLine("/** This file is generated by tools, do not modify it manully! v2 */");
				codeWriter.WriteLine("using System;");
				codeWriter.WriteLine("using UnityEngine;");
				codeWriter.WriteLine("using UnityEngine.UI;");
				codeWriter.WriteLine("using ZF.UI;");
				codeWriter.WriteLine();
				codeWriter.WriteLineFormat("namespace {0} {{", text2);
				codeWriter.IncraseTab();
				codeWriter.WriteLineFormat("public class {0} {{", go.name);
				CsExportGroup(component, codeWriter);
				codeWriter.WriteLine("}");
				codeWriter.DecreaseTab();
				codeWriter.WriteLine("}");
				codeWriter.Flush();
			}
			Debug.LogFormat("++++++++++++++++++导出代码{0}+++++++++++++++++++", new object[1] { text3 });
		}

		private static void CsExportGroup(ExportGroup group, CodeWriter writer)
		{
			writer.IncraseTab();
			writer.WriteLine("[Export(false, \"\", \"\")]");
			writer.WriteLineFormat("public {0} self {{ get; set; }}", group.type);
			ExportNode[] children = group.children;
			foreach (ExportNode exportNode in children)
			{
				if (exportNode is ExportGroup)
				{
					writer.WriteLine();
					writer.WriteLineFormat("[Export(true, \"{0}\", \"{1}\")]", exportNode.path, exportNode.desc);
					writer.WriteLineFormat("public {0} {1} {{ get; set; }} ", "G" + exportNode.Name, exportNode.Name);
				}
				else
				{
					writer.WriteLine();
					writer.WriteLineFormat("[Export(false, \"{0}\", \"{1}\")]", exportNode.path, exportNode.desc);
					writer.WriteLineFormat("public {0} {1} {{ get; set; }} ", exportNode.type, exportNode.Name);
				}
			}
			List<ExportGroup> list = (from x in @group.children
				where x is ExportGroup
				select x as ExportGroup).ToList();
			foreach (ExportGroup item in list)
			{
				writer.WriteLine();
				writer.WriteLineFormat("public class {0} {{", "G" + item.Name);
				CsExportGroup(item, writer);
				writer.WriteLine("}");
			}
			writer.DecreaseTab();
		}

		private static void LuaExport(GameObject go)
		{
			ExportGroup component = go.GetComponent<ExportGroup>();
			if ((object)component == null)
			{
				Debug.LogErrorFormat("gameobject {0} has no ExportGroup", new object[1] { go.name });
				return;
			}
			string text = Path.Combine(Application.dataPath, GenLuaCodePath);
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			string text2 = Path.Combine(text, go.name + ".lua");
			using (FileStream stream = File.Open(text2, FileMode.Create, FileAccess.ReadWrite))
			{
				using StreamWriter writer = new StreamWriter(stream);
				CodeWriter codeWriter = new CodeWriter(writer);
				codeWriter.WriteLine("--[[ This file is generated by tools, do not modify it manully! ]]");
				codeWriter.WriteLine();
				codeWriter.WriteLineFormat("local {0} = {{ ", go.name);
				LuaExportDefines(component, codeWriter);
				codeWriter.WriteLine("}");
				codeWriter.WriteLineFormat("{0}.__name = \"{0}\"", go.name);
				codeWriter.WriteLine();
				codeWriter.WriteLineFormat("function {0}.load(view, parent, path)", go.name);
				LuaExportLoads(null, component, codeWriter);
				codeWriter.WriteLine("end");
				codeWriter.WriteLine();
				codeWriter.WriteLineFormat("return {0}", go.name);
				codeWriter.Flush();
			}
			Debug.LogFormat("++++++++++++++++++导出代码{0}+++++++++++++++++++", new object[1] { text2 });
		}

		private static void LuaExportDefines(ExportGroup group, CodeWriter writer)
		{
			writer.IncraseTab();
			writer.WriteLineFormat("self,{0}--[[GameObject]]", align(16, "self"));
			ExportNode[] children = group.children;
			foreach (ExportNode exportNode in children)
			{
				if (exportNode is ExportGroup)
				{
					writer.WriteLineFormat("{0} = {{", exportNode.Name);
					LuaExportDefines(exportNode as ExportGroup, writer);
					writer.WriteLine("},");
				}
				else
				{
					writer.WriteLineFormat("{0},{1}--[[{2}]]", exportNode.Name, align(16, exportNode.Name), exportNode.type);
				}
			}
			writer.DecreaseTab();
		}

		private static void LuaExportLoads(string parent, ExportGroup group, CodeWriter writer)
		{
			if (parent == null)
			{
				writer.IncraseTab();
				writer.WriteLineFormat("parent, path = parent or 0, path or \"{0}\"", group.path);
				writer.WriteLineFormat("local self = clone({0})", group.Name);
				writer.WriteLineFormat("self.self = G.api.View.Lookup(view, parent, path, \"{0}\")", group.type);
				ExportNode[] children = group.children;
				foreach (ExportNode exportNode in children)
				{
					if (exportNode is ExportGroup)
					{
						LuaExportLoads("self", exportNode as ExportGroup, writer);
						continue;
					}
					writer.WriteLineFormat("self.{0} = G.api.View.Lookup(view, self.self, \"{1}\", \"{2}\")", exportNode.Name, exportNode.path, exportNode.type);
				}
				writer.WriteLine("return self");
				writer.DecreaseTab();
				return;
			}
			writer.WriteLineFormat("{0}.{1}.self = G.api.View.Lookup(view, {2}.self, \"{3}\", \"{4}\")", parent, group.Name, parent, group.path, group.type);
			ExportNode[] children2 = group.children;
			foreach (ExportNode exportNode2 in children2)
			{
				if (exportNode2 is ExportGroup)
				{
					LuaExportLoads(parent + "." + group.Name, exportNode2 as ExportGroup, writer);
					continue;
				}
				writer.WriteLineFormat("{0}.{1}.{2} = G.api.View.Lookup(view, {3}.self, \"{4}\", \"{5}\")", parent, group.Name, exportNode2.Name, parent + "." + group.Name, exportNode2.path, exportNode2.type);
			}
		}

		private static string align(int align, string name, bool comma = true)
		{
			if (align == 0)
			{
				align = 16;
			}
			int num = 0;
			int num2 = name.Length;
			if (comma)
			{
				num2++;
			}
			if (num2 <= align)
			{
				num = align - num2;
			}
			if (num == 0)
			{
				return "";
			}
			return new string(' ', num);
		}
	}
}
