// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: player.proto

package proto_player

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GetPlayerData struct {
	Data *PlayerData `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *GetPlayerData) Reset()      { *m = GetPlayerData{} }
func (*GetPlayerData) ProtoMessage() {}
func (*GetPlayerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{0}
}
func (m *GetPlayerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPlayerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPlayerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPlayerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPlayerData.Merge(m, src)
}
func (m *GetPlayerData) XXX_Size() int {
	return m.Size()
}
func (m *GetPlayerData) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPlayerData.DiscardUnknown(m)
}

var xxx_messageInfo_GetPlayerData proto.InternalMessageInfo

func (m *GetPlayerData) GetData() *PlayerData {
	if m != nil {
		return m.Data
	}
	return nil
}

type PlayerData struct {
	Id   int64       `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Base *PlayerBase `protobuf:"bytes,2,opt,name=Base,proto3" json:"Base,omitempty"`
	Room *PlayerRoom `protobuf:"bytes,3,opt,name=Room,proto3" json:"Room,omitempty"`
	Bag  *PlayerBag  `protobuf:"bytes,4,opt,name=Bag,proto3" json:"Bag,omitempty"`
	Game *PlayerGame `protobuf:"bytes,5,opt,name=Game,proto3" json:"Game,omitempty"`
}

func (m *PlayerData) Reset()      { *m = PlayerData{} }
func (*PlayerData) ProtoMessage() {}
func (*PlayerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{1}
}
func (m *PlayerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerData.Merge(m, src)
}
func (m *PlayerData) XXX_Size() int {
	return m.Size()
}
func (m *PlayerData) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerData.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerData proto.InternalMessageInfo

func (m *PlayerData) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PlayerData) GetBase() *PlayerBase {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *PlayerData) GetRoom() *PlayerRoom {
	if m != nil {
		return m.Room
	}
	return nil
}

func (m *PlayerData) GetBag() *PlayerBag {
	if m != nil {
		return m.Bag
	}
	return nil
}

func (m *PlayerData) GetGame() *PlayerGame {
	if m != nil {
		return m.Game
	}
	return nil
}

// 玩家基础数据
type PlayerBase struct {
	Name  string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Level int32  `protobuf:"varint,2,opt,name=Level,proto3" json:"Level,omitempty"`
	Money int32  `protobuf:"varint,3,opt,name=Money,proto3" json:"Money,omitempty"`
	Coin  int32  `protobuf:"varint,4,opt,name=Coin,proto3" json:"Coin,omitempty"`
	Head  string `protobuf:"bytes,5,opt,name=Head,proto3" json:"Head,omitempty"`
}

func (m *PlayerBase) Reset()      { *m = PlayerBase{} }
func (*PlayerBase) ProtoMessage() {}
func (*PlayerBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{2}
}
func (m *PlayerBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerBase.Merge(m, src)
}
func (m *PlayerBase) XXX_Size() int {
	return m.Size()
}
func (m *PlayerBase) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerBase.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerBase proto.InternalMessageInfo

func (m *PlayerBase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlayerBase) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *PlayerBase) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *PlayerBase) GetCoin() int32 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *PlayerBase) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

// 玩家对局数据
type PlayerGame struct {
	GameInfos []*GameInfo `protobuf:"bytes,1,rep,name=GameInfos,proto3" json:"GameInfos,omitempty"`
}

func (m *PlayerGame) Reset()      { *m = PlayerGame{} }
func (*PlayerGame) ProtoMessage() {}
func (*PlayerGame) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{3}
}
func (m *PlayerGame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerGame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerGame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerGame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerGame.Merge(m, src)
}
func (m *PlayerGame) XXX_Size() int {
	return m.Size()
}
func (m *PlayerGame) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerGame.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerGame proto.InternalMessageInfo

func (m *PlayerGame) GetGameInfos() []*GameInfo {
	if m != nil {
		return m.GameInfos
	}
	return nil
}

type GameInfo struct {
	GameType    int32   `protobuf:"varint,1,opt,name=GameType,proto3" json:"GameType,omitempty"`
	TotalCount  int32   `protobuf:"varint,2,opt,name=TotalCount,proto3" json:"TotalCount,omitempty"`
	WinCount    int32   `protobuf:"varint,3,opt,name=WinCount,proto3" json:"WinCount,omitempty"`
	MaxWin      int32   `protobuf:"varint,4,opt,name=MaxWin,proto3" json:"MaxWin,omitempty"`
	TotalWin    int32   `protobuf:"varint,5,opt,name=TotalWin,proto3" json:"TotalWin,omitempty"`
	Cards       []int32 `protobuf:"varint,6,rep,packed,name=Cards,proto3" json:"Cards,omitempty"`
	CardType    int32   `protobuf:"varint,7,opt,name=CardType,proto3" json:"CardType,omitempty"`
	RaiseCount  int32   `protobuf:"varint,8,opt,name=RaiseCount,proto3" json:"RaiseCount,omitempty"`
	RaiseCounts []int32 `protobuf:"varint,9,rep,packed,name=RaiseCounts,proto3" json:"RaiseCounts,omitempty"`
	FoldCounts  []int32 `protobuf:"varint,10,rep,packed,name=FoldCounts,proto3" json:"FoldCounts,omitempty"`
	IntroCount  int32   `protobuf:"varint,11,opt,name=IntroCount,proto3" json:"IntroCount,omitempty"`
}

func (m *GameInfo) Reset()      { *m = GameInfo{} }
func (*GameInfo) ProtoMessage() {}
func (*GameInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{4}
}
func (m *GameInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameInfo.Merge(m, src)
}
func (m *GameInfo) XXX_Size() int {
	return m.Size()
}
func (m *GameInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GameInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GameInfo proto.InternalMessageInfo

func (m *GameInfo) GetGameType() int32 {
	if m != nil {
		return m.GameType
	}
	return 0
}

func (m *GameInfo) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *GameInfo) GetWinCount() int32 {
	if m != nil {
		return m.WinCount
	}
	return 0
}

func (m *GameInfo) GetMaxWin() int32 {
	if m != nil {
		return m.MaxWin
	}
	return 0
}

func (m *GameInfo) GetTotalWin() int32 {
	if m != nil {
		return m.TotalWin
	}
	return 0
}

func (m *GameInfo) GetCards() []int32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *GameInfo) GetCardType() int32 {
	if m != nil {
		return m.CardType
	}
	return 0
}

func (m *GameInfo) GetRaiseCount() int32 {
	if m != nil {
		return m.RaiseCount
	}
	return 0
}

func (m *GameInfo) GetRaiseCounts() []int32 {
	if m != nil {
		return m.RaiseCounts
	}
	return nil
}

func (m *GameInfo) GetFoldCounts() []int32 {
	if m != nil {
		return m.FoldCounts
	}
	return nil
}

func (m *GameInfo) GetIntroCount() int32 {
	if m != nil {
		return m.IntroCount
	}
	return 0
}

type RoomOptions struct {
	Id         int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	AutoBuy    bool  `protobuf:"varint,2,opt,name=AutoBuy,proto3" json:"AutoBuy,omitempty"`
	AutoBuyMax bool  `protobuf:"varint,3,opt,name=AutoBuyMax,proto3" json:"AutoBuyMax,omitempty"`
	Buy        int32 `protobuf:"varint,4,opt,name=Buy,proto3" json:"Buy,omitempty"`
}

func (m *RoomOptions) Reset()      { *m = RoomOptions{} }
func (*RoomOptions) ProtoMessage() {}
func (*RoomOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{5}
}
func (m *RoomOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomOptions.Merge(m, src)
}
func (m *RoomOptions) XXX_Size() int {
	return m.Size()
}
func (m *RoomOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RoomOptions proto.InternalMessageInfo

func (m *RoomOptions) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoomOptions) GetAutoBuy() bool {
	if m != nil {
		return m.AutoBuy
	}
	return false
}

func (m *RoomOptions) GetAutoBuyMax() bool {
	if m != nil {
		return m.AutoBuyMax
	}
	return false
}

func (m *RoomOptions) GetBuy() int32 {
	if m != nil {
		return m.Buy
	}
	return 0
}

// 玩家房间数据
type PlayerRoom struct {
	Options []*RoomOptions `protobuf:"bytes,1,rep,name=Options,proto3" json:"Options,omitempty"`
}

func (m *PlayerRoom) Reset()      { *m = PlayerRoom{} }
func (*PlayerRoom) ProtoMessage() {}
func (*PlayerRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{6}
}
func (m *PlayerRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerRoom.Merge(m, src)
}
func (m *PlayerRoom) XXX_Size() int {
	return m.Size()
}
func (m *PlayerRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerRoom.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerRoom proto.InternalMessageInfo

func (m *PlayerRoom) GetOptions() []*RoomOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// 邮件相关
type C2SGetMailList struct {
	Start int32 `protobuf:"varint,1,opt,name=Start,proto3" json:"Start,omitempty"`
	Count int32 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *C2SGetMailList) Reset()      { *m = C2SGetMailList{} }
func (*C2SGetMailList) ProtoMessage() {}
func (*C2SGetMailList) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{7}
}
func (m *C2SGetMailList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SGetMailList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SGetMailList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SGetMailList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SGetMailList.Merge(m, src)
}
func (m *C2SGetMailList) XXX_Size() int {
	return m.Size()
}
func (m *C2SGetMailList) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SGetMailList.DiscardUnknown(m)
}

var xxx_messageInfo_C2SGetMailList proto.InternalMessageInfo

func (m *C2SGetMailList) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *C2SGetMailList) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type S2CGetMailList struct {
	MailList []*Mail `protobuf:"bytes,1,rep,name=MailList,proto3" json:"MailList,omitempty"`
}

func (m *S2CGetMailList) Reset()      { *m = S2CGetMailList{} }
func (*S2CGetMailList) ProtoMessage() {}
func (*S2CGetMailList) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{8}
}
func (m *S2CGetMailList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGetMailList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGetMailList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CGetMailList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGetMailList.Merge(m, src)
}
func (m *S2CGetMailList) XXX_Size() int {
	return m.Size()
}
func (m *S2CGetMailList) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGetMailList.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGetMailList proto.InternalMessageInfo

func (m *S2CGetMailList) GetMailList() []*Mail {
	if m != nil {
		return m.MailList
	}
	return nil
}

type Mail struct {
	Id             int64          `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Title          string         `protobuf:"bytes,2,opt,name=Title,proto3" json:"Title,omitempty"`
	IsRead         bool           `protobuf:"varint,3,opt,name=IsRead,proto3" json:"IsRead,omitempty"`
	IsReceiveAward bool           `protobuf:"varint,4,opt,name=IsReceiveAward,proto3" json:"IsReceiveAward,omitempty"`
	CreateTime     int64          `protobuf:"varint,5,opt,name=CreateTime,proto3" json:"CreateTime,omitempty"`
	WithAward      bool           `protobuf:"varint,6,opt,name=WithAward,proto3" json:"WithAward,omitempty"`
	Sender         string         `protobuf:"bytes,7,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Award          *AccessoryInfo `protobuf:"bytes,8,opt,name=Award,proto3" json:"Award,omitempty"`
}

func (m *Mail) Reset()      { *m = Mail{} }
func (*Mail) ProtoMessage() {}
func (*Mail) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{9}
}
func (m *Mail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Mail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Mail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Mail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Mail.Merge(m, src)
}
func (m *Mail) XXX_Size() int {
	return m.Size()
}
func (m *Mail) XXX_DiscardUnknown() {
	xxx_messageInfo_Mail.DiscardUnknown(m)
}

var xxx_messageInfo_Mail proto.InternalMessageInfo

func (m *Mail) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Mail) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Mail) GetIsRead() bool {
	if m != nil {
		return m.IsRead
	}
	return false
}

func (m *Mail) GetIsReceiveAward() bool {
	if m != nil {
		return m.IsReceiveAward
	}
	return false
}

func (m *Mail) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Mail) GetWithAward() bool {
	if m != nil {
		return m.WithAward
	}
	return false
}

func (m *Mail) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Mail) GetAward() *AccessoryInfo {
	if m != nil {
		return m.Award
	}
	return nil
}

type C2SGetMailDetail struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C2SGetMailDetail) Reset()      { *m = C2SGetMailDetail{} }
func (*C2SGetMailDetail) ProtoMessage() {}
func (*C2SGetMailDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{10}
}
func (m *C2SGetMailDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SGetMailDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SGetMailDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SGetMailDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SGetMailDetail.Merge(m, src)
}
func (m *C2SGetMailDetail) XXX_Size() int {
	return m.Size()
}
func (m *C2SGetMailDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SGetMailDetail.DiscardUnknown(m)
}

var xxx_messageInfo_C2SGetMailDetail proto.InternalMessageInfo

func (m *C2SGetMailDetail) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type S2CGetMailDetail struct {
	Id             int64            `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	MailTitle      string           `protobuf:"bytes,2,opt,name=MailTitle,proto3" json:"MailTitle,omitempty"`
	MailContent    string           `protobuf:"bytes,3,opt,name=MailContent,proto3" json:"MailContent,omitempty"`
	Accessory      []*AccessoryInfo `protobuf:"bytes,4,rep,name=Accessory,proto3" json:"Accessory,omitempty"`
	IsReceiveAward bool             `protobuf:"varint,5,opt,name=IsReceiveAward,proto3" json:"IsReceiveAward,omitempty"`
}

func (m *S2CGetMailDetail) Reset()      { *m = S2CGetMailDetail{} }
func (*S2CGetMailDetail) ProtoMessage() {}
func (*S2CGetMailDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{11}
}
func (m *S2CGetMailDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGetMailDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGetMailDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CGetMailDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGetMailDetail.Merge(m, src)
}
func (m *S2CGetMailDetail) XXX_Size() int {
	return m.Size()
}
func (m *S2CGetMailDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGetMailDetail.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGetMailDetail proto.InternalMessageInfo

func (m *S2CGetMailDetail) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *S2CGetMailDetail) GetMailTitle() string {
	if m != nil {
		return m.MailTitle
	}
	return ""
}

func (m *S2CGetMailDetail) GetMailContent() string {
	if m != nil {
		return m.MailContent
	}
	return ""
}

func (m *S2CGetMailDetail) GetAccessory() []*AccessoryInfo {
	if m != nil {
		return m.Accessory
	}
	return nil
}

func (m *S2CGetMailDetail) GetIsReceiveAward() bool {
	if m != nil {
		return m.IsReceiveAward
	}
	return false
}

type AccessoryInfo struct {
	ItemId     int32 `protobuf:"varint,1,opt,name=ItemId,proto3" json:"ItemId,omitempty"`
	ItemNumber int32 `protobuf:"varint,2,opt,name=ItemNumber,proto3" json:"ItemNumber,omitempty"`
}

func (m *AccessoryInfo) Reset()      { *m = AccessoryInfo{} }
func (*AccessoryInfo) ProtoMessage() {}
func (*AccessoryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{12}
}
func (m *AccessoryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessoryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessoryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessoryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessoryInfo.Merge(m, src)
}
func (m *AccessoryInfo) XXX_Size() int {
	return m.Size()
}
func (m *AccessoryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessoryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AccessoryInfo proto.InternalMessageInfo

func (m *AccessoryInfo) GetItemId() int32 {
	if m != nil {
		return m.ItemId
	}
	return 0
}

func (m *AccessoryInfo) GetItemNumber() int32 {
	if m != nil {
		return m.ItemNumber
	}
	return 0
}

type S2CNewMail struct {
}

func (m *S2CNewMail) Reset()      { *m = S2CNewMail{} }
func (*S2CNewMail) ProtoMessage() {}
func (*S2CNewMail) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{13}
}
func (m *S2CNewMail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNewMail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNewMail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNewMail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNewMail.Merge(m, src)
}
func (m *S2CNewMail) XXX_Size() int {
	return m.Size()
}
func (m *S2CNewMail) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNewMail.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNewMail proto.InternalMessageInfo

type C2SDeleteMail struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C2SDeleteMail) Reset()      { *m = C2SDeleteMail{} }
func (*C2SDeleteMail) ProtoMessage() {}
func (*C2SDeleteMail) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{14}
}
func (m *C2SDeleteMail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SDeleteMail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SDeleteMail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SDeleteMail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SDeleteMail.Merge(m, src)
}
func (m *C2SDeleteMail) XXX_Size() int {
	return m.Size()
}
func (m *C2SDeleteMail) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SDeleteMail.DiscardUnknown(m)
}

var xxx_messageInfo_C2SDeleteMail proto.InternalMessageInfo

func (m *C2SDeleteMail) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type S2CDeleteMail struct {
	Access bool `protobuf:"varint,1,opt,name=Access,proto3" json:"Access,omitempty"`
}

func (m *S2CDeleteMail) Reset()      { *m = S2CDeleteMail{} }
func (*S2CDeleteMail) ProtoMessage() {}
func (*S2CDeleteMail) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{15}
}
func (m *S2CDeleteMail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CDeleteMail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CDeleteMail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CDeleteMail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CDeleteMail.Merge(m, src)
}
func (m *S2CDeleteMail) XXX_Size() int {
	return m.Size()
}
func (m *S2CDeleteMail) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CDeleteMail.DiscardUnknown(m)
}

var xxx_messageInfo_S2CDeleteMail proto.InternalMessageInfo

func (m *S2CDeleteMail) GetAccess() bool {
	if m != nil {
		return m.Access
	}
	return false
}

type C2SReceiveMailAward struct {
	Id int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C2SReceiveMailAward) Reset()      { *m = C2SReceiveMailAward{} }
func (*C2SReceiveMailAward) ProtoMessage() {}
func (*C2SReceiveMailAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{16}
}
func (m *C2SReceiveMailAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SReceiveMailAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SReceiveMailAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SReceiveMailAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SReceiveMailAward.Merge(m, src)
}
func (m *C2SReceiveMailAward) XXX_Size() int {
	return m.Size()
}
func (m *C2SReceiveMailAward) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SReceiveMailAward.DiscardUnknown(m)
}

var xxx_messageInfo_C2SReceiveMailAward proto.InternalMessageInfo

func (m *C2SReceiveMailAward) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type S2CReceiveMailAward struct {
	Access bool `protobuf:"varint,1,opt,name=Access,proto3" json:"Access,omitempty"`
}

func (m *S2CReceiveMailAward) Reset()      { *m = S2CReceiveMailAward{} }
func (*S2CReceiveMailAward) ProtoMessage() {}
func (*S2CReceiveMailAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{17}
}
func (m *S2CReceiveMailAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CReceiveMailAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CReceiveMailAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CReceiveMailAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CReceiveMailAward.Merge(m, src)
}
func (m *S2CReceiveMailAward) XXX_Size() int {
	return m.Size()
}
func (m *S2CReceiveMailAward) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CReceiveMailAward.DiscardUnknown(m)
}

var xxx_messageInfo_S2CReceiveMailAward proto.InternalMessageInfo

func (m *S2CReceiveMailAward) GetAccess() bool {
	if m != nil {
		return m.Access
	}
	return false
}

// 背包相关
type Item struct {
	Id    int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Count int32 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *Item) Reset()      { *m = Item{} }
func (*Item) ProtoMessage() {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{18}
}
func (m *Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return m.Size()
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Item) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type PlayerBag struct {
	Items []*Item `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
}

func (m *PlayerBag) Reset()      { *m = PlayerBag{} }
func (*PlayerBag) ProtoMessage() {}
func (*PlayerBag) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{19}
}
func (m *PlayerBag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerBag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerBag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerBag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerBag.Merge(m, src)
}
func (m *PlayerBag) XXX_Size() int {
	return m.Size()
}
func (m *PlayerBag) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerBag.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerBag proto.InternalMessageInfo

func (m *PlayerBag) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type S2CBag struct {
	Update *Item `protobuf:"bytes,1,opt,name=Update,proto3" json:"Update,omitempty"`
}

func (m *S2CBag) Reset()      { *m = S2CBag{} }
func (*S2CBag) ProtoMessage() {}
func (*S2CBag) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{20}
}
func (m *S2CBag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CBag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CBag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CBag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CBag.Merge(m, src)
}
func (m *S2CBag) XXX_Size() int {
	return m.Size()
}
func (m *S2CBag) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CBag.DiscardUnknown(m)
}

var xxx_messageInfo_S2CBag proto.InternalMessageInfo

func (m *S2CBag) GetUpdate() *Item {
	if m != nil {
		return m.Update
	}
	return nil
}

// 走马灯
type S2CNotice struct {
	Type     int32    `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Priority int32    `protobuf:"varint,2,opt,name=Priority,proto3" json:"Priority,omitempty"`
	Times    int32    `protobuf:"varint,3,opt,name=Times,proto3" json:"Times,omitempty"`
	TimeSpan int32    `protobuf:"varint,4,opt,name=TimeSpan,proto3" json:"TimeSpan,omitempty"`
	Content  string   `protobuf:"bytes,5,opt,name=Content,proto3" json:"Content,omitempty"`
	Params   []string `protobuf:"bytes,6,rep,name=Params,proto3" json:"Params,omitempty"`
}

func (m *S2CNotice) Reset()      { *m = S2CNotice{} }
func (*S2CNotice) ProtoMessage() {}
func (*S2CNotice) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{21}
}
func (m *S2CNotice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNotice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNotice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNotice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNotice.Merge(m, src)
}
func (m *S2CNotice) XXX_Size() int {
	return m.Size()
}
func (m *S2CNotice) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNotice.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNotice proto.InternalMessageInfo

func (m *S2CNotice) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *S2CNotice) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *S2CNotice) GetTimes() int32 {
	if m != nil {
		return m.Times
	}
	return 0
}

func (m *S2CNotice) GetTimeSpan() int32 {
	if m != nil {
		return m.TimeSpan
	}
	return 0
}

func (m *S2CNotice) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *S2CNotice) GetParams() []string {
	if m != nil {
		return m.Params
	}
	return nil
}

// GM
type C2SGMCommand struct {
	Command string `protobuf:"bytes,1,opt,name=Command,proto3" json:"Command,omitempty"`
}

func (m *C2SGMCommand) Reset()      { *m = C2SGMCommand{} }
func (*C2SGMCommand) ProtoMessage() {}
func (*C2SGMCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{22}
}
func (m *C2SGMCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SGMCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SGMCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SGMCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SGMCommand.Merge(m, src)
}
func (m *C2SGMCommand) XXX_Size() int {
	return m.Size()
}
func (m *C2SGMCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SGMCommand.DiscardUnknown(m)
}

var xxx_messageInfo_C2SGMCommand proto.InternalMessageInfo

func (m *C2SGMCommand) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

// 头像、名字
type C2SPlayerRename struct {
	NewName string `protobuf:"bytes,1,opt,name=NewName,proto3" json:"NewName,omitempty"`
}

func (m *C2SPlayerRename) Reset()      { *m = C2SPlayerRename{} }
func (*C2SPlayerRename) ProtoMessage() {}
func (*C2SPlayerRename) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{23}
}
func (m *C2SPlayerRename) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SPlayerRename) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SPlayerRename.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SPlayerRename) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SPlayerRename.Merge(m, src)
}
func (m *C2SPlayerRename) XXX_Size() int {
	return m.Size()
}
func (m *C2SPlayerRename) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SPlayerRename.DiscardUnknown(m)
}

var xxx_messageInfo_C2SPlayerRename proto.InternalMessageInfo

func (m *C2SPlayerRename) GetNewName() string {
	if m != nil {
		return m.NewName
	}
	return ""
}

type S2CPlayerRename struct {
	Success bool   `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
	NewName string `protobuf:"bytes,2,opt,name=NewName,proto3" json:"NewName,omitempty"`
}

func (m *S2CPlayerRename) Reset()      { *m = S2CPlayerRename{} }
func (*S2CPlayerRename) ProtoMessage() {}
func (*S2CPlayerRename) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{24}
}
func (m *S2CPlayerRename) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CPlayerRename) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CPlayerRename.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CPlayerRename) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CPlayerRename.Merge(m, src)
}
func (m *S2CPlayerRename) XXX_Size() int {
	return m.Size()
}
func (m *S2CPlayerRename) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CPlayerRename.DiscardUnknown(m)
}

var xxx_messageInfo_S2CPlayerRename proto.InternalMessageInfo

func (m *S2CPlayerRename) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *S2CPlayerRename) GetNewName() string {
	if m != nil {
		return m.NewName
	}
	return ""
}

type C2SChangeHead struct {
	Head string `protobuf:"bytes,1,opt,name=Head,proto3" json:"Head,omitempty"`
}

func (m *C2SChangeHead) Reset()      { *m = C2SChangeHead{} }
func (*C2SChangeHead) ProtoMessage() {}
func (*C2SChangeHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{25}
}
func (m *C2SChangeHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SChangeHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SChangeHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SChangeHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SChangeHead.Merge(m, src)
}
func (m *C2SChangeHead) XXX_Size() int {
	return m.Size()
}
func (m *C2SChangeHead) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SChangeHead.DiscardUnknown(m)
}

var xxx_messageInfo_C2SChangeHead proto.InternalMessageInfo

func (m *C2SChangeHead) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

type S2CChangeHead struct {
	Success bool   `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
	NewHead string `protobuf:"bytes,2,opt,name=NewHead,proto3" json:"NewHead,omitempty"`
}

func (m *S2CChangeHead) Reset()      { *m = S2CChangeHead{} }
func (*S2CChangeHead) ProtoMessage() {}
func (*S2CChangeHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{26}
}
func (m *S2CChangeHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CChangeHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CChangeHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CChangeHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CChangeHead.Merge(m, src)
}
func (m *S2CChangeHead) XXX_Size() int {
	return m.Size()
}
func (m *S2CChangeHead) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CChangeHead.DiscardUnknown(m)
}

var xxx_messageInfo_S2CChangeHead proto.InternalMessageInfo

func (m *S2CChangeHead) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *S2CChangeHead) GetNewHead() string {
	if m != nil {
		return m.NewHead
	}
	return ""
}

// 任务
type C2SGetAllTask struct {
}

func (m *C2SGetAllTask) Reset()      { *m = C2SGetAllTask{} }
func (*C2SGetAllTask) ProtoMessage() {}
func (*C2SGetAllTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{27}
}
func (m *C2SGetAllTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SGetAllTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SGetAllTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SGetAllTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SGetAllTask.Merge(m, src)
}
func (m *C2SGetAllTask) XXX_Size() int {
	return m.Size()
}
func (m *C2SGetAllTask) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SGetAllTask.DiscardUnknown(m)
}

var xxx_messageInfo_C2SGetAllTask proto.InternalMessageInfo

type S2CGetAllTask struct {
	TaskList []*Task `protobuf:"bytes,1,rep,name=TaskList,proto3" json:"TaskList,omitempty"`
}

func (m *S2CGetAllTask) Reset()      { *m = S2CGetAllTask{} }
func (*S2CGetAllTask) ProtoMessage() {}
func (*S2CGetAllTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{28}
}
func (m *S2CGetAllTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGetAllTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGetAllTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CGetAllTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGetAllTask.Merge(m, src)
}
func (m *S2CGetAllTask) XXX_Size() int {
	return m.Size()
}
func (m *S2CGetAllTask) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGetAllTask.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGetAllTask proto.InternalMessageInfo

func (m *S2CGetAllTask) GetTaskList() []*Task {
	if m != nil {
		return m.TaskList
	}
	return nil
}

type C2SReceiveTaskAward struct {
	Id int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *C2SReceiveTaskAward) Reset()      { *m = C2SReceiveTaskAward{} }
func (*C2SReceiveTaskAward) ProtoMessage() {}
func (*C2SReceiveTaskAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{29}
}
func (m *C2SReceiveTaskAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SReceiveTaskAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SReceiveTaskAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SReceiveTaskAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SReceiveTaskAward.Merge(m, src)
}
func (m *C2SReceiveTaskAward) XXX_Size() int {
	return m.Size()
}
func (m *C2SReceiveTaskAward) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SReceiveTaskAward.DiscardUnknown(m)
}

var xxx_messageInfo_C2SReceiveTaskAward proto.InternalMessageInfo

func (m *C2SReceiveTaskAward) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type S2CReceiveTaskAward struct {
	Success bool             `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
	Award   []*AccessoryInfo `protobuf:"bytes,2,rep,name=Award,proto3" json:"Award,omitempty"`
}

func (m *S2CReceiveTaskAward) Reset()      { *m = S2CReceiveTaskAward{} }
func (*S2CReceiveTaskAward) ProtoMessage() {}
func (*S2CReceiveTaskAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{30}
}
func (m *S2CReceiveTaskAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CReceiveTaskAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CReceiveTaskAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CReceiveTaskAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CReceiveTaskAward.Merge(m, src)
}
func (m *S2CReceiveTaskAward) XXX_Size() int {
	return m.Size()
}
func (m *S2CReceiveTaskAward) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CReceiveTaskAward.DiscardUnknown(m)
}

var xxx_messageInfo_S2CReceiveTaskAward proto.InternalMessageInfo

func (m *S2CReceiveTaskAward) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *S2CReceiveTaskAward) GetAward() []*AccessoryInfo {
	if m != nil {
		return m.Award
	}
	return nil
}

type S2CTaskUpdate struct {
	TaskList []*Task `protobuf:"bytes,1,rep,name=TaskList,proto3" json:"TaskList,omitempty"`
}

func (m *S2CTaskUpdate) Reset()      { *m = S2CTaskUpdate{} }
func (*S2CTaskUpdate) ProtoMessage() {}
func (*S2CTaskUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{31}
}
func (m *S2CTaskUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CTaskUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CTaskUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CTaskUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CTaskUpdate.Merge(m, src)
}
func (m *S2CTaskUpdate) XXX_Size() int {
	return m.Size()
}
func (m *S2CTaskUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CTaskUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_S2CTaskUpdate proto.InternalMessageInfo

func (m *S2CTaskUpdate) GetTaskList() []*Task {
	if m != nil {
		return m.TaskList
	}
	return nil
}

type Task struct {
	Id       int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Type     int32 `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	TaskType int32 `protobuf:"varint,3,opt,name=TaskType,proto3" json:"TaskType,omitempty"`
	Count    int32 `protobuf:"varint,4,opt,name=Count,proto3" json:"Count,omitempty"`
	Target   int32 `protobuf:"varint,5,opt,name=Target,proto3" json:"Target,omitempty"`
	State    int32 `protobuf:"varint,6,opt,name=State,proto3" json:"State,omitempty"`
}

func (m *Task) Reset()      { *m = Task{} }
func (*Task) ProtoMessage() {}
func (*Task) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{32}
}
func (m *Task) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Task) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Task.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Task) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Task.Merge(m, src)
}
func (m *Task) XXX_Size() int {
	return m.Size()
}
func (m *Task) XXX_DiscardUnknown() {
	xxx_messageInfo_Task.DiscardUnknown(m)
}

var xxx_messageInfo_Task proto.InternalMessageInfo

func (m *Task) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Task) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Task) GetTaskType() int32 {
	if m != nil {
		return m.TaskType
	}
	return 0
}

func (m *Task) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Task) GetTarget() int32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *Task) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

type S2CResourceChanged struct {
	Types  []int32 `protobuf:"varint,1,rep,packed,name=Types,proto3" json:"Types,omitempty"`
	Values []int32 `protobuf:"varint,2,rep,packed,name=Values,proto3" json:"Values,omitempty"`
}

func (m *S2CResourceChanged) Reset()      { *m = S2CResourceChanged{} }
func (*S2CResourceChanged) ProtoMessage() {}
func (*S2CResourceChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{33}
}
func (m *S2CResourceChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CResourceChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CResourceChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CResourceChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CResourceChanged.Merge(m, src)
}
func (m *S2CResourceChanged) XXX_Size() int {
	return m.Size()
}
func (m *S2CResourceChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CResourceChanged.DiscardUnknown(m)
}

var xxx_messageInfo_S2CResourceChanged proto.InternalMessageInfo

func (m *S2CResourceChanged) GetTypes() []int32 {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *S2CResourceChanged) GetValues() []int32 {
	if m != nil {
		return m.Values
	}
	return nil
}

type S2CGameInfoChanged struct {
	Info *GameInfo `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
}

func (m *S2CGameInfoChanged) Reset()      { *m = S2CGameInfoChanged{} }
func (*S2CGameInfoChanged) ProtoMessage() {}
func (*S2CGameInfoChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{34}
}
func (m *S2CGameInfoChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGameInfoChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGameInfoChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CGameInfoChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGameInfoChanged.Merge(m, src)
}
func (m *S2CGameInfoChanged) XXX_Size() int {
	return m.Size()
}
func (m *S2CGameInfoChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGameInfoChanged.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGameInfoChanged proto.InternalMessageInfo

func (m *S2CGameInfoChanged) GetInfo() *GameInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// 公告
type S2CAnnouncement struct {
	Datas []*Announcement `protobuf:"bytes,1,rep,name=datas,proto3" json:"datas,omitempty"`
}

func (m *S2CAnnouncement) Reset()      { *m = S2CAnnouncement{} }
func (*S2CAnnouncement) ProtoMessage() {}
func (*S2CAnnouncement) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{35}
}
func (m *S2CAnnouncement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CAnnouncement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CAnnouncement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CAnnouncement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CAnnouncement.Merge(m, src)
}
func (m *S2CAnnouncement) XXX_Size() int {
	return m.Size()
}
func (m *S2CAnnouncement) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CAnnouncement.DiscardUnknown(m)
}

var xxx_messageInfo_S2CAnnouncement proto.InternalMessageInfo

func (m *S2CAnnouncement) GetDatas() []*Announcement {
	if m != nil {
		return m.Datas
	}
	return nil
}

type Announcement struct {
	Id        int64    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Type      int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	OpenTime  int64    `protobuf:"varint,3,opt,name=OpenTime,proto3" json:"OpenTime,omitempty"`
	CloseTime int64    `protobuf:"varint,4,opt,name=CloseTime,proto3" json:"CloseTime,omitempty"`
	Count     int32    `protobuf:"varint,5,opt,name=Count,proto3" json:"Count,omitempty"`
	Priority  int32    `protobuf:"varint,6,opt,name=Priority,proto3" json:"Priority,omitempty"`
	Channel   int32    `protobuf:"varint,7,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Title     string   `protobuf:"bytes,8,opt,name=Title,proto3" json:"Title,omitempty"`
	Content   string   `protobuf:"bytes,9,opt,name=Content,proto3" json:"Content,omitempty"`
	Version   []string `protobuf:"bytes,10,rep,name=Version,proto3" json:"Version,omitempty"`
	Language  string   `protobuf:"bytes,11,opt,name=Language,proto3" json:"Language,omitempty"`
}

func (m *Announcement) Reset()      { *m = Announcement{} }
func (*Announcement) ProtoMessage() {}
func (*Announcement) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{36}
}
func (m *Announcement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Announcement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Announcement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Announcement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Announcement.Merge(m, src)
}
func (m *Announcement) XXX_Size() int {
	return m.Size()
}
func (m *Announcement) XXX_DiscardUnknown() {
	xxx_messageInfo_Announcement.DiscardUnknown(m)
}

var xxx_messageInfo_Announcement proto.InternalMessageInfo

func (m *Announcement) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Announcement) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Announcement) GetOpenTime() int64 {
	if m != nil {
		return m.OpenTime
	}
	return 0
}

func (m *Announcement) GetCloseTime() int64 {
	if m != nil {
		return m.CloseTime
	}
	return 0
}

func (m *Announcement) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Announcement) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Announcement) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *Announcement) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Announcement) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Announcement) GetVersion() []string {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *Announcement) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

// 功能开启
type C2SGetFuncState struct {
}

func (m *C2SGetFuncState) Reset()      { *m = C2SGetFuncState{} }
func (*C2SGetFuncState) ProtoMessage() {}
func (*C2SGetFuncState) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{37}
}
func (m *C2SGetFuncState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SGetFuncState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SGetFuncState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SGetFuncState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SGetFuncState.Merge(m, src)
}
func (m *C2SGetFuncState) XXX_Size() int {
	return m.Size()
}
func (m *C2SGetFuncState) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SGetFuncState.DiscardUnknown(m)
}

var xxx_messageInfo_C2SGetFuncState proto.InternalMessageInfo

type S2CFuncOpen struct {
	List []*FuncState `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty"`
}

func (m *S2CFuncOpen) Reset()      { *m = S2CFuncOpen{} }
func (*S2CFuncOpen) ProtoMessage() {}
func (*S2CFuncOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{38}
}
func (m *S2CFuncOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CFuncOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CFuncOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CFuncOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CFuncOpen.Merge(m, src)
}
func (m *S2CFuncOpen) XXX_Size() int {
	return m.Size()
}
func (m *S2CFuncOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CFuncOpen.DiscardUnknown(m)
}

var xxx_messageInfo_S2CFuncOpen proto.InternalMessageInfo

func (m *S2CFuncOpen) GetList() []*FuncState {
	if m != nil {
		return m.List
	}
	return nil
}

type FuncState struct {
	Id    int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	State int32 `protobuf:"varint,2,opt,name=State,proto3" json:"State,omitempty"`
}

func (m *FuncState) Reset()      { *m = FuncState{} }
func (*FuncState) ProtoMessage() {}
func (*FuncState) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{39}
}
func (m *FuncState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FuncState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FuncState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FuncState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuncState.Merge(m, src)
}
func (m *FuncState) XXX_Size() int {
	return m.Size()
}
func (m *FuncState) XXX_DiscardUnknown() {
	xxx_messageInfo_FuncState.DiscardUnknown(m)
}

var xxx_messageInfo_FuncState proto.InternalMessageInfo

func (m *FuncState) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FuncState) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

// 获取其他玩家信息
type C2SGetRoomPlayerInfo struct {
	Id       int64 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	GameType int32 `protobuf:"varint,2,opt,name=GameType,proto3" json:"GameType,omitempty"`
}

func (m *C2SGetRoomPlayerInfo) Reset()      { *m = C2SGetRoomPlayerInfo{} }
func (*C2SGetRoomPlayerInfo) ProtoMessage() {}
func (*C2SGetRoomPlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{40}
}
func (m *C2SGetRoomPlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SGetRoomPlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SGetRoomPlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SGetRoomPlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SGetRoomPlayerInfo.Merge(m, src)
}
func (m *C2SGetRoomPlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *C2SGetRoomPlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SGetRoomPlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_C2SGetRoomPlayerInfo proto.InternalMessageInfo

func (m *C2SGetRoomPlayerInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *C2SGetRoomPlayerInfo) GetGameType() int32 {
	if m != nil {
		return m.GameType
	}
	return 0
}

type S2CGetRoomPlayerInfo struct {
	Id         int64  `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Head       string `protobuf:"bytes,2,opt,name=Head,proto3" json:"Head,omitempty"`
	Name       string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	WinCount   int32  `protobuf:"varint,4,opt,name=WinCount,proto3" json:"WinCount,omitempty"`
	TotalCount int32  `protobuf:"varint,5,opt,name=TotalCount,proto3" json:"TotalCount,omitempty"`
}

func (m *S2CGetRoomPlayerInfo) Reset()      { *m = S2CGetRoomPlayerInfo{} }
func (*S2CGetRoomPlayerInfo) ProtoMessage() {}
func (*S2CGetRoomPlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{41}
}
func (m *S2CGetRoomPlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGetRoomPlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGetRoomPlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CGetRoomPlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGetRoomPlayerInfo.Merge(m, src)
}
func (m *S2CGetRoomPlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *S2CGetRoomPlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGetRoomPlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGetRoomPlayerInfo proto.InternalMessageInfo

func (m *S2CGetRoomPlayerInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *S2CGetRoomPlayerInfo) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *S2CGetRoomPlayerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *S2CGetRoomPlayerInfo) GetWinCount() int32 {
	if m != nil {
		return m.WinCount
	}
	return 0
}

func (m *S2CGetRoomPlayerInfo) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

type S2CKick struct {
}

func (m *S2CKick) Reset()      { *m = S2CKick{} }
func (*S2CKick) ProtoMessage() {}
func (*S2CKick) Descriptor() ([]byte, []int) {
	return fileDescriptor_41d803d1b635d5c6, []int{42}
}
func (m *S2CKick) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CKick) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CKick.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CKick) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CKick.Merge(m, src)
}
func (m *S2CKick) XXX_Size() int {
	return m.Size()
}
func (m *S2CKick) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CKick.DiscardUnknown(m)
}

var xxx_messageInfo_S2CKick proto.InternalMessageInfo

func init() {
	proto.RegisterType((*GetPlayerData)(nil), "proto.player.GetPlayerData")
	proto.RegisterType((*PlayerData)(nil), "proto.player.PlayerData")
	proto.RegisterType((*PlayerBase)(nil), "proto.player.PlayerBase")
	proto.RegisterType((*PlayerGame)(nil), "proto.player.PlayerGame")
	proto.RegisterType((*GameInfo)(nil), "proto.player.GameInfo")
	proto.RegisterType((*RoomOptions)(nil), "proto.player.RoomOptions")
	proto.RegisterType((*PlayerRoom)(nil), "proto.player.PlayerRoom")
	proto.RegisterType((*C2SGetMailList)(nil), "proto.player.C2SGetMailList")
	proto.RegisterType((*S2CGetMailList)(nil), "proto.player.S2CGetMailList")
	proto.RegisterType((*Mail)(nil), "proto.player.Mail")
	proto.RegisterType((*C2SGetMailDetail)(nil), "proto.player.C2SGetMailDetail")
	proto.RegisterType((*S2CGetMailDetail)(nil), "proto.player.S2CGetMailDetail")
	proto.RegisterType((*AccessoryInfo)(nil), "proto.player.AccessoryInfo")
	proto.RegisterType((*S2CNewMail)(nil), "proto.player.S2CNewMail")
	proto.RegisterType((*C2SDeleteMail)(nil), "proto.player.C2SDeleteMail")
	proto.RegisterType((*S2CDeleteMail)(nil), "proto.player.S2CDeleteMail")
	proto.RegisterType((*C2SReceiveMailAward)(nil), "proto.player.C2SReceiveMailAward")
	proto.RegisterType((*S2CReceiveMailAward)(nil), "proto.player.S2CReceiveMailAward")
	proto.RegisterType((*Item)(nil), "proto.player.Item")
	proto.RegisterType((*PlayerBag)(nil), "proto.player.PlayerBag")
	proto.RegisterType((*S2CBag)(nil), "proto.player.S2CBag")
	proto.RegisterType((*S2CNotice)(nil), "proto.player.S2CNotice")
	proto.RegisterType((*C2SGMCommand)(nil), "proto.player.C2SGMCommand")
	proto.RegisterType((*C2SPlayerRename)(nil), "proto.player.C2SPlayerRename")
	proto.RegisterType((*S2CPlayerRename)(nil), "proto.player.S2CPlayerRename")
	proto.RegisterType((*C2SChangeHead)(nil), "proto.player.C2SChangeHead")
	proto.RegisterType((*S2CChangeHead)(nil), "proto.player.S2CChangeHead")
	proto.RegisterType((*C2SGetAllTask)(nil), "proto.player.C2SGetAllTask")
	proto.RegisterType((*S2CGetAllTask)(nil), "proto.player.S2CGetAllTask")
	proto.RegisterType((*C2SReceiveTaskAward)(nil), "proto.player.C2SReceiveTaskAward")
	proto.RegisterType((*S2CReceiveTaskAward)(nil), "proto.player.S2CReceiveTaskAward")
	proto.RegisterType((*S2CTaskUpdate)(nil), "proto.player.S2CTaskUpdate")
	proto.RegisterType((*Task)(nil), "proto.player.Task")
	proto.RegisterType((*S2CResourceChanged)(nil), "proto.player.S2CResourceChanged")
	proto.RegisterType((*S2CGameInfoChanged)(nil), "proto.player.S2CGameInfoChanged")
	proto.RegisterType((*S2CAnnouncement)(nil), "proto.player.S2CAnnouncement")
	proto.RegisterType((*Announcement)(nil), "proto.player.Announcement")
	proto.RegisterType((*C2SGetFuncState)(nil), "proto.player.C2SGetFuncState")
	proto.RegisterType((*S2CFuncOpen)(nil), "proto.player.S2CFuncOpen")
	proto.RegisterType((*FuncState)(nil), "proto.player.FuncState")
	proto.RegisterType((*C2SGetRoomPlayerInfo)(nil), "proto.player.C2SGetRoomPlayerInfo")
	proto.RegisterType((*S2CGetRoomPlayerInfo)(nil), "proto.player.S2CGetRoomPlayerInfo")
	proto.RegisterType((*S2CKick)(nil), "proto.player.S2CKick")
}

func init() { proto.RegisterFile("player.proto", fileDescriptor_41d803d1b635d5c6) }

var fileDescriptor_41d803d1b635d5c6 = []byte{
	// 1428 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0x5f, 0x27, 0x71, 0x36, 0x7e, 0xfb, 0xa7, 0xc5, 0x5d, 0x95, 0x50, 0x90, 0x59, 0x0d, 0x02,
	0x96, 0xb6, 0xac, 0xa8, 0x5b, 0x0e, 0x20, 0x10, 0xdd, 0x75, 0xe9, 0xb2, 0xa2, 0xbb, 0xad, 0xc6,
	0x4b, 0x7b, 0x9e, 0x26, 0xc3, 0xd6, 0x6a, 0x62, 0x47, 0xf6, 0xa4, 0x6d, 0x6e, 0x9c, 0x39, 0xf1,
	0x09, 0xe0, 0xca, 0x17, 0x41, 0x42, 0x9c, 0xca, 0xad, 0x47, 0x9a, 0x5e, 0x38, 0xf6, 0xc2, 0x1d,
	0xbd, 0x37, 0x63, 0x7b, 0x92, 0x26, 0x54, 0x9c, 0x3c, 0xbf, 0x37, 0xbf, 0x79, 0xf3, 0xe6, 0xcd,
	0xfb, 0x33, 0x86, 0xf5, 0xd1, 0x40, 0x4c, 0x64, 0xbe, 0x3b, 0xca, 0x33, 0x95, 0xf9, 0xeb, 0xf4,
	0xd9, 0xd5, 0x32, 0xf6, 0x25, 0x6c, 0x1c, 0x48, 0x75, 0x87, 0xc0, 0x0d, 0xa1, 0x84, 0x7f, 0x19,
	0x5a, 0xf8, 0xed, 0x3a, 0xdb, 0xce, 0xce, 0x5a, 0xd8, 0xdd, 0xb5, 0xd9, 0xbb, 0x35, 0x8f, 0x13,
	0x8b, 0xfd, 0xe9, 0x00, 0x58, 0x8b, 0x37, 0xa1, 0x71, 0xd8, 0xa7, 0xa5, 0x4d, 0xde, 0x38, 0xec,
	0xa3, 0xb2, 0x7d, 0x51, 0xc8, 0x6e, 0x63, 0xb9, 0x32, 0x9c, 0xe7, 0xc4, 0x42, 0x36, 0xcf, 0xb2,
	0x61, 0xb7, 0xb9, 0x9c, 0x8d, 0xf3, 0x9c, 0x58, 0xfe, 0x47, 0xd0, 0xdc, 0x17, 0xa7, 0xdd, 0x16,
	0x91, 0xdf, 0x5c, 0xac, 0xfa, 0x94, 0x23, 0x07, 0x15, 0x1f, 0x88, 0xa1, 0xec, 0xba, 0xcb, 0x15,
	0xe3, 0x3c, 0x27, 0x16, 0x53, 0xe5, 0x91, 0xc8, 0x28, 0x1f, 0x5a, 0xc7, 0xb8, 0x16, 0x0f, 0xe5,
	0x71, 0x1a, 0xfb, 0x5b, 0xe0, 0xde, 0x92, 0x8f, 0xe4, 0x80, 0xce, 0xe5, 0x72, 0x0d, 0x50, 0x7a,
	0x94, 0xa5, 0x72, 0x42, 0xf6, 0xbb, 0x5c, 0x03, 0x5c, 0x1f, 0x65, 0x49, 0x4a, 0x76, 0xba, 0x9c,
	0xc6, 0x28, 0xfb, 0x46, 0x8a, 0x3e, 0xd9, 0xe3, 0x71, 0x1a, 0xb3, 0xfd, 0x72, 0x57, 0xb4, 0xc1,
	0xbf, 0x06, 0x1e, 0x7e, 0x0f, 0xd3, 0xef, 0xb3, 0xa2, 0xeb, 0x6c, 0x37, 0x77, 0xd6, 0xc2, 0xf3,
	0xb3, 0x66, 0x97, 0xd3, 0xbc, 0x26, 0xb2, 0x3f, 0x1a, 0xd0, 0x29, 0x91, 0x7f, 0x41, 0x8f, 0x4f,
	0x26, 0x23, 0x6d, 0xbc, 0xcb, 0x2b, 0xec, 0x07, 0x00, 0x27, 0x99, 0x12, 0x83, 0x28, 0x1b, 0xa7,
	0xca, 0x9c, 0xc2, 0x92, 0xe0, 0xda, 0x7b, 0x49, 0xaa, 0x67, 0xf5, 0x69, 0x2a, 0xec, 0x9f, 0x87,
	0xf6, 0x91, 0x78, 0x72, 0xaf, 0x3a, 0x92, 0x41, 0xb8, 0x86, 0x34, 0xe0, 0x8c, 0xab, 0xd7, 0x94,
	0x18, 0x5d, 0x13, 0x89, 0xbc, 0x5f, 0x74, 0xdb, 0xdb, 0x4d, 0x74, 0x0d, 0x01, 0x5c, 0x81, 0x03,
	0xb2, 0x70, 0x55, 0xaf, 0x28, 0x31, 0x5a, 0xc8, 0x45, 0x52, 0x48, 0x6d, 0x43, 0x47, 0x5b, 0x58,
	0x4b, 0xfc, 0x6d, 0x58, 0xab, 0x51, 0xd1, 0xf5, 0x48, 0xaf, 0x2d, 0x42, 0x0d, 0x37, 0xb3, 0x41,
	0xdf, 0x10, 0x80, 0x08, 0x96, 0x04, 0xe7, 0x0f, 0x53, 0x95, 0x67, 0x7a, 0x87, 0x35, 0xbd, 0x43,
	0x2d, 0x61, 0x09, 0xac, 0x61, 0x9c, 0xdd, 0x1e, 0xa9, 0x24, 0x4b, 0x0b, 0x2b, 0xb4, 0x5d, 0x0a,
	0xed, 0x2e, 0xac, 0xee, 0x8d, 0x55, 0xb6, 0x3f, 0x9e, 0x90, 0xff, 0x3a, 0xbc, 0x84, 0xa8, 0xd8,
	0x0c, 0x8f, 0xc4, 0x13, 0x72, 0x5f, 0x87, 0x5b, 0x12, 0xff, 0x2c, 0x34, 0x71, 0x95, 0xf6, 0x1e,
	0x0e, 0xd9, 0x5e, 0x79, 0xf7, 0x14, 0xd8, 0x57, 0x61, 0xd5, 0x6c, 0x6a, 0x6e, 0xfe, 0xad, 0xd9,
	0x9b, 0xb7, 0xac, 0xe2, 0x25, 0x93, 0x7d, 0x01, 0x9b, 0x51, 0x18, 0x1f, 0x48, 0x75, 0x24, 0x92,
	0xc1, 0xad, 0xa4, 0x50, 0xe8, 0xf3, 0x58, 0x89, 0x5c, 0x19, 0x9b, 0x35, 0xa0, 0x9b, 0xb0, 0x2e,
	0x5d, 0x03, 0x76, 0x1d, 0x36, 0xe3, 0x30, 0xb2, 0x57, 0xef, 0x42, 0xa7, 0x1c, 0x1b, 0x2b, 0xfc,
	0x59, 0x2b, 0x70, 0x96, 0x57, 0x1c, 0xf6, 0x8f, 0x03, 0x2d, 0x04, 0xaf, 0x94, 0x80, 0x2d, 0x70,
	0x4f, 0x12, 0x35, 0xd0, 0x35, 0xc0, 0xe3, 0x1a, 0x60, 0x10, 0x1d, 0x16, 0x1c, 0x73, 0x40, 0xfb,
	0xc7, 0x20, 0xff, 0x03, 0xd8, 0xc4, 0x51, 0x4f, 0x26, 0x8f, 0xe4, 0xde, 0x63, 0x91, 0xf7, 0xc9,
	0x4d, 0x1d, 0x3e, 0x27, 0x45, 0x1f, 0x47, 0xb9, 0x14, 0x4a, 0x9e, 0x24, 0x26, 0xaf, 0x9b, 0xdc,
	0x92, 0xf8, 0xef, 0x80, 0x77, 0x2f, 0x51, 0x0f, 0xb4, 0x8a, 0x36, 0xa9, 0xa8, 0x05, 0xb8, 0x7b,
	0x2c, 0xd3, 0xbe, 0xcc, 0x29, 0xec, 0x3c, 0x6e, 0x90, 0x7f, 0x05, 0x5c, 0xbd, 0xa2, 0x43, 0x85,
	0xe2, 0xed, 0xd9, 0x13, 0xef, 0xf5, 0x7a, 0xb2, 0x28, 0xb2, 0x7c, 0x42, 0x69, 0xa7, 0x99, 0x8c,
	0xc1, 0xd9, 0xda, 0xef, 0x37, 0xa4, 0x5a, 0xe0, 0x02, 0xf6, 0x9b, 0x03, 0x67, 0x6b, 0xf7, 0x2e,
	0x26, 0xa1, 0xc5, 0x38, 0x6b, 0xfb, 0xaa, 0x16, 0x60, 0xb8, 0x23, 0x88, 0xb2, 0x54, 0x49, 0x93,
	0x93, 0x1e, 0xb7, 0x45, 0xfe, 0x67, 0xe0, 0x55, 0x06, 0x76, 0x5b, 0x74, 0x63, 0xff, 0x69, 0x7f,
	0xcd, 0x5e, 0xe0, 0x74, 0x77, 0x91, 0xd3, 0xd9, 0x01, 0x6c, 0xcc, 0xe8, 0xa0, 0x5b, 0x54, 0x72,
	0x58, 0xe5, 0x85, 0x41, 0x94, 0x5a, 0x4a, 0x0e, 0x8f, 0xc7, 0xc3, 0xfb, 0x32, 0x2f, 0xcb, 0x4b,
	0x2d, 0x61, 0xeb, 0x00, 0x71, 0x18, 0x1d, 0xcb, 0xc7, 0x78, 0x00, 0xf6, 0x2e, 0x6c, 0x44, 0x61,
	0x7c, 0x43, 0x0e, 0xa4, 0x92, 0x8b, 0x42, 0x88, 0x7d, 0x08, 0x1b, 0x71, 0x18, 0x59, 0x84, 0xf3,
	0xd0, 0xd6, 0x86, 0x10, 0xa9, 0xc3, 0x0d, 0x62, 0xef, 0xc3, 0xb9, 0x28, 0x8c, 0x8d, 0xcd, 0xc8,
	0xd4, 0xd7, 0x3d, 0xaf, 0xef, 0x63, 0x38, 0x17, 0x87, 0xd1, 0x2b, 0xb4, 0x65, 0x5a, 0x2f, 0x43,
	0x0b, 0x6d, 0x7f, 0xa5, 0x02, 0x2c, 0x4e, 0xa5, 0x4f, 0xc1, 0xab, 0xba, 0x8f, 0xbf, 0x03, 0x2e,
	0x2e, 0x2d, 0x16, 0xa7, 0x10, 0x4e, 0x71, 0x4d, 0x60, 0xd7, 0xa0, 0x1d, 0x87, 0x11, 0xae, 0xb9,
	0x08, 0xed, 0xef, 0x46, 0x7d, 0xa1, 0xa4, 0x69, 0xc1, 0x8b, 0x16, 0x19, 0x06, 0xfb, 0xc5, 0x01,
	0x0f, 0x3d, 0x99, 0xa9, 0xa4, 0x47, 0xad, 0xca, 0xaa, 0xf6, 0x34, 0xc6, 0x1a, 0x7b, 0x27, 0x4f,
	0xb2, 0x3c, 0x51, 0x13, 0x63, 0x67, 0x85, 0x75, 0x6a, 0x0e, 0x65, 0x51, 0x36, 0x2c, 0x02, 0x54,
	0xc7, 0x93, 0xa1, 0x8c, 0x47, 0xa2, 0xac, 0xf0, 0x15, 0xc6, 0xa2, 0x57, 0x86, 0xa0, 0xee, 0x5d,
	0x25, 0x44, 0xe7, 0xdd, 0x11, 0xb9, 0x18, 0xea, 0x12, 0xef, 0x71, 0x83, 0xd8, 0x0e, 0xac, 0x63,
	0x7e, 0x1c, 0x45, 0xd9, 0x70, 0x28, 0xd2, 0xbe, 0xd6, 0x40, 0x43, 0xd3, 0x51, 0x4b, 0xc8, 0x2e,
	0xc1, 0x99, 0x28, 0x8c, 0x4d, 0x1d, 0x94, 0x29, 0x76, 0xc1, 0x2e, 0xac, 0x1e, 0xcb, 0xc7, 0x56,
	0xfb, 0x2d, 0x21, 0xfb, 0x1a, 0xce, 0xc4, 0x61, 0x34, 0x4f, 0x8e, 0xc7, 0xf6, 0xfd, 0x95, 0xd0,
	0x56, 0xd3, 0x98, 0x55, 0xf3, 0x1e, 0x85, 0x5e, 0xf4, 0x40, 0xa4, 0xa7, 0x12, 0xbb, 0x70, 0xd5,
	0x99, 0x1d, 0xab, 0x33, 0x47, 0x14, 0x7e, 0x16, 0xe9, 0x75, 0x3b, 0x91, 0x86, 0x7a, 0x27, 0x52,
	0x72, 0x86, 0x76, 0x3a, 0x90, 0x6a, 0x6f, 0x30, 0x38, 0x11, 0xc5, 0x43, 0xf6, 0x15, 0x69, 0xad,
	0x05, 0x58, 0x71, 0xf1, 0xbb, 0xbc, 0xe2, 0xe2, 0x2c, 0xaf, 0x38, 0xb3, 0xc1, 0x8e, 0xd2, 0xf9,
	0x60, 0xa7, 0x28, 0x65, 0xf7, 0xed, 0x60, 0xaf, 0x69, 0xcb, 0xcf, 0x50, 0x15, 0xc1, 0xc6, 0xeb,
	0x8b, 0x88, 0x29, 0x82, 0xfa, 0x2c, 0xa8, 0x5c, 0xc7, 0xe5, 0xff, 0x3e, 0xcb, 0x8f, 0x0e, 0xb4,
	0xc8, 0x09, 0xf3, 0x39, 0x56, 0x86, 0x74, 0x63, 0x36, 0xa4, 0x91, 0x4b, 0x72, 0xf3, 0x38, 0x29,
	0x71, 0x9d, 0x93, 0x2d, 0x2b, 0x27, 0x31, 0x38, 0x4f, 0x44, 0x7e, 0x2a, 0x95, 0x79, 0x98, 0x18,
	0x64, 0x5a, 0xa4, 0x92, 0xd4, 0x21, 0x74, 0x8b, 0x54, 0x92, 0xed, 0x83, 0x4f, 0x1e, 0x2b, 0xb2,
	0x71, 0xde, 0x93, 0xfa, 0xde, 0x75, 0x1f, 0x9b, 0x8c, 0xa4, 0x4e, 0x65, 0x4c, 0x16, 0x04, 0xa8,
	0xf9, 0xae, 0x18, 0x8c, 0x65, 0x41, 0xde, 0x72, 0xb9, 0x41, 0xec, 0x3a, 0xe9, 0x28, 0xdf, 0x62,
	0xa5, 0x8e, 0x8b, 0xd0, 0x42, 0x68, 0x12, 0x7b, 0xd9, 0x83, 0x8e, 0x38, 0x2c, 0xa2, 0x08, 0xdf,
	0x4b, 0xd3, 0x6c, 0x9c, 0xf6, 0xe4, 0x10, 0x73, 0xec, 0x13, 0x70, 0xfb, 0x42, 0x89, 0xb2, 0x9a,
	0x5c, 0x98, 0xbb, 0x19, 0x8b, 0xca, 0x35, 0x91, 0xfd, 0xdc, 0x80, 0xf5, 0x19, 0x15, 0xf3, 0x5d,
	0x67, 0x89, 0x7f, 0x6f, 0x8f, 0x64, 0x4a, 0x9d, 0xb5, 0x49, 0xcc, 0x0a, 0x63, 0x97, 0x8a, 0x06,
	0x59, 0xa1, 0xdb, 0x6e, 0x8b, 0x26, 0x6b, 0x41, 0xed, 0x7d, 0xd7, 0xf6, 0xbe, 0x5d, 0x82, 0xda,
	0x73, 0x25, 0x08, 0xcb, 0xc1, 0x03, 0x91, 0xa6, 0x72, 0x60, 0x5e, 0x80, 0x25, 0xac, 0xdf, 0x0d,
	0x1d, 0xfb, 0xdd, 0x60, 0x15, 0x20, 0x6f, 0xb6, 0x00, 0x75, 0x61, 0xf5, 0xae, 0xcc, 0x8b, 0x24,
	0x4b, 0xe9, 0xad, 0xe7, 0xf1, 0x12, 0xe2, 0xfe, 0xb7, 0x44, 0x7a, 0x3a, 0x16, 0xa7, 0x92, 0x9e,
	0x79, 0x1e, 0xaf, 0x30, 0x7b, 0x83, 0x8a, 0xce, 0x81, 0x54, 0x37, 0xc7, 0x69, 0x4f, 0x5f, 0xff,
	0xe7, 0xb0, 0x16, 0x87, 0x11, 0x62, 0x3c, 0xb5, 0x7f, 0x09, 0x5a, 0x56, 0x18, 0xcf, 0xfd, 0x67,
	0x54, 0xab, 0x38, 0x91, 0xd8, 0x15, 0xf0, 0x2a, 0xd1, 0xa2, 0x7e, 0xa1, 0xa3, 0xad, 0x31, 0x1b,
	0x6d, 0x5b, 0xda, 0x02, 0x7c, 0xd6, 0xe9, 0x82, 0x46, 0xbd, 0x75, 0xfe, 0xa6, 0xec, 0xe7, 0x7c,
	0x63, 0xf6, 0x39, 0x8f, 0xe9, 0xb3, 0xa5, 0x8b, 0xc9, 0x6b, 0x94, 0x94, 0xe5, 0xad, 0x51, 0x97,
	0xb7, 0xea, 0x07, 0xa7, 0x69, 0xfd, 0xe0, 0xd8, 0xef, 0xff, 0xd6, 0xdc, 0xfb, 0x7f, 0xf6, 0xdf,
	0xc1, 0x9d, 0xff, 0x77, 0x60, 0x1e, 0xac, 0xc6, 0x61, 0xf4, 0x6d, 0xd2, 0x7b, 0xb8, 0x7f, 0xed,
	0xe9, 0xf3, 0x60, 0xe5, 0xd9, 0xf3, 0x60, 0xe5, 0xe5, 0xf3, 0xc0, 0xf9, 0x61, 0x1a, 0x38, 0xbf,
	0x4e, 0x03, 0xe7, 0xf7, 0x69, 0xe0, 0x3c, 0x9d, 0x06, 0xce, 0x5f, 0xd3, 0xc0, 0xf9, 0x7b, 0x1a,
	0xac, 0xbc, 0x9c, 0x06, 0xce, 0x4f, 0x2f, 0x82, 0x95, 0xa7, 0x2f, 0x82, 0x95, 0x67, 0x2f, 0x82,
	0x95, 0xfb, 0x6d, 0x72, 0xf1, 0xd5, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x77, 0xd8, 0x6a, 0xbb,
	0xb7, 0x0e, 0x00, 0x00,
}

func (this *GetPlayerData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetPlayerData)
	if !ok {
		that2, ok := that.(GetPlayerData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *PlayerData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerData)
	if !ok {
		that2, ok := that.(PlayerData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Base.Equal(that1.Base) {
		return false
	}
	if !this.Room.Equal(that1.Room) {
		return false
	}
	if !this.Bag.Equal(that1.Bag) {
		return false
	}
	if !this.Game.Equal(that1.Game) {
		return false
	}
	return true
}
func (this *PlayerBase) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerBase)
	if !ok {
		that2, ok := that.(PlayerBase)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Money != that1.Money {
		return false
	}
	if this.Coin != that1.Coin {
		return false
	}
	if this.Head != that1.Head {
		return false
	}
	return true
}
func (this *PlayerGame) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerGame)
	if !ok {
		that2, ok := that.(PlayerGame)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.GameInfos) != len(that1.GameInfos) {
		return false
	}
	for i := range this.GameInfos {
		if !this.GameInfos[i].Equal(that1.GameInfos[i]) {
			return false
		}
	}
	return true
}
func (this *GameInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GameInfo)
	if !ok {
		that2, ok := that.(GameInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GameType != that1.GameType {
		return false
	}
	if this.TotalCount != that1.TotalCount {
		return false
	}
	if this.WinCount != that1.WinCount {
		return false
	}
	if this.MaxWin != that1.MaxWin {
		return false
	}
	if this.TotalWin != that1.TotalWin {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.CardType != that1.CardType {
		return false
	}
	if this.RaiseCount != that1.RaiseCount {
		return false
	}
	if len(this.RaiseCounts) != len(that1.RaiseCounts) {
		return false
	}
	for i := range this.RaiseCounts {
		if this.RaiseCounts[i] != that1.RaiseCounts[i] {
			return false
		}
	}
	if len(this.FoldCounts) != len(that1.FoldCounts) {
		return false
	}
	for i := range this.FoldCounts {
		if this.FoldCounts[i] != that1.FoldCounts[i] {
			return false
		}
	}
	if this.IntroCount != that1.IntroCount {
		return false
	}
	return true
}
func (this *RoomOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoomOptions)
	if !ok {
		that2, ok := that.(RoomOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AutoBuy != that1.AutoBuy {
		return false
	}
	if this.AutoBuyMax != that1.AutoBuyMax {
		return false
	}
	if this.Buy != that1.Buy {
		return false
	}
	return true
}
func (this *PlayerRoom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerRoom)
	if !ok {
		that2, ok := that.(PlayerRoom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if !this.Options[i].Equal(that1.Options[i]) {
			return false
		}
	}
	return true
}
func (this *C2SGetMailList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SGetMailList)
	if !ok {
		that2, ok := that.(C2SGetMailList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *S2CGetMailList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CGetMailList)
	if !ok {
		that2, ok := that.(S2CGetMailList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.MailList) != len(that1.MailList) {
		return false
	}
	for i := range this.MailList {
		if !this.MailList[i].Equal(that1.MailList[i]) {
			return false
		}
	}
	return true
}
func (this *Mail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Mail)
	if !ok {
		that2, ok := that.(Mail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.IsRead != that1.IsRead {
		return false
	}
	if this.IsReceiveAward != that1.IsReceiveAward {
		return false
	}
	if this.CreateTime != that1.CreateTime {
		return false
	}
	if this.WithAward != that1.WithAward {
		return false
	}
	if this.Sender != that1.Sender {
		return false
	}
	if !this.Award.Equal(that1.Award) {
		return false
	}
	return true
}
func (this *C2SGetMailDetail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SGetMailDetail)
	if !ok {
		that2, ok := that.(C2SGetMailDetail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *S2CGetMailDetail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CGetMailDetail)
	if !ok {
		that2, ok := that.(S2CGetMailDetail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.MailTitle != that1.MailTitle {
		return false
	}
	if this.MailContent != that1.MailContent {
		return false
	}
	if len(this.Accessory) != len(that1.Accessory) {
		return false
	}
	for i := range this.Accessory {
		if !this.Accessory[i].Equal(that1.Accessory[i]) {
			return false
		}
	}
	if this.IsReceiveAward != that1.IsReceiveAward {
		return false
	}
	return true
}
func (this *AccessoryInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessoryInfo)
	if !ok {
		that2, ok := that.(AccessoryInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ItemId != that1.ItemId {
		return false
	}
	if this.ItemNumber != that1.ItemNumber {
		return false
	}
	return true
}
func (this *S2CNewMail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CNewMail)
	if !ok {
		that2, ok := that.(S2CNewMail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *C2SDeleteMail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SDeleteMail)
	if !ok {
		that2, ok := that.(C2SDeleteMail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *S2CDeleteMail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CDeleteMail)
	if !ok {
		that2, ok := that.(S2CDeleteMail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Access != that1.Access {
		return false
	}
	return true
}
func (this *C2SReceiveMailAward) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SReceiveMailAward)
	if !ok {
		that2, ok := that.(C2SReceiveMailAward)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *S2CReceiveMailAward) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CReceiveMailAward)
	if !ok {
		that2, ok := that.(S2CReceiveMailAward)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Access != that1.Access {
		return false
	}
	return true
}
func (this *Item) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Item)
	if !ok {
		that2, ok := that.(Item)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	return true
}
func (this *PlayerBag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerBag)
	if !ok {
		that2, ok := that.(PlayerBag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *S2CBag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CBag)
	if !ok {
		that2, ok := that.(S2CBag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Update.Equal(that1.Update) {
		return false
	}
	return true
}
func (this *S2CNotice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CNotice)
	if !ok {
		that2, ok := that.(S2CNotice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Times != that1.Times {
		return false
	}
	if this.TimeSpan != that1.TimeSpan {
		return false
	}
	if this.Content != that1.Content {
		return false
	}
	if len(this.Params) != len(that1.Params) {
		return false
	}
	for i := range this.Params {
		if this.Params[i] != that1.Params[i] {
			return false
		}
	}
	return true
}
func (this *C2SGMCommand) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SGMCommand)
	if !ok {
		that2, ok := that.(C2SGMCommand)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Command != that1.Command {
		return false
	}
	return true
}
func (this *C2SPlayerRename) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SPlayerRename)
	if !ok {
		that2, ok := that.(C2SPlayerRename)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NewName != that1.NewName {
		return false
	}
	return true
}
func (this *S2CPlayerRename) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CPlayerRename)
	if !ok {
		that2, ok := that.(S2CPlayerRename)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if this.NewName != that1.NewName {
		return false
	}
	return true
}
func (this *C2SChangeHead) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SChangeHead)
	if !ok {
		that2, ok := that.(C2SChangeHead)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Head != that1.Head {
		return false
	}
	return true
}
func (this *S2CChangeHead) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CChangeHead)
	if !ok {
		that2, ok := that.(S2CChangeHead)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if this.NewHead != that1.NewHead {
		return false
	}
	return true
}
func (this *C2SGetAllTask) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SGetAllTask)
	if !ok {
		that2, ok := that.(C2SGetAllTask)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *S2CGetAllTask) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CGetAllTask)
	if !ok {
		that2, ok := that.(S2CGetAllTask)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.TaskList) != len(that1.TaskList) {
		return false
	}
	for i := range this.TaskList {
		if !this.TaskList[i].Equal(that1.TaskList[i]) {
			return false
		}
	}
	return true
}
func (this *C2SReceiveTaskAward) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SReceiveTaskAward)
	if !ok {
		that2, ok := that.(C2SReceiveTaskAward)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *S2CReceiveTaskAward) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CReceiveTaskAward)
	if !ok {
		that2, ok := that.(S2CReceiveTaskAward)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if len(this.Award) != len(that1.Award) {
		return false
	}
	for i := range this.Award {
		if !this.Award[i].Equal(that1.Award[i]) {
			return false
		}
	}
	return true
}
func (this *S2CTaskUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CTaskUpdate)
	if !ok {
		that2, ok := that.(S2CTaskUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.TaskList) != len(that1.TaskList) {
		return false
	}
	for i := range this.TaskList {
		if !this.TaskList[i].Equal(that1.TaskList[i]) {
			return false
		}
	}
	return true
}
func (this *Task) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Task)
	if !ok {
		that2, ok := that.(Task)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.TaskType != that1.TaskType {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Target != that1.Target {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *S2CResourceChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CResourceChanged)
	if !ok {
		that2, ok := that.(S2CResourceChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Types) != len(that1.Types) {
		return false
	}
	for i := range this.Types {
		if this.Types[i] != that1.Types[i] {
			return false
		}
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if this.Values[i] != that1.Values[i] {
			return false
		}
	}
	return true
}
func (this *S2CGameInfoChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CGameInfoChanged)
	if !ok {
		that2, ok := that.(S2CGameInfoChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	return true
}
func (this *S2CAnnouncement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CAnnouncement)
	if !ok {
		that2, ok := that.(S2CAnnouncement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Datas) != len(that1.Datas) {
		return false
	}
	for i := range this.Datas {
		if !this.Datas[i].Equal(that1.Datas[i]) {
			return false
		}
	}
	return true
}
func (this *Announcement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Announcement)
	if !ok {
		that2, ok := that.(Announcement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.OpenTime != that1.OpenTime {
		return false
	}
	if this.CloseTime != that1.CloseTime {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Content != that1.Content {
		return false
	}
	if len(this.Version) != len(that1.Version) {
		return false
	}
	for i := range this.Version {
		if this.Version[i] != that1.Version[i] {
			return false
		}
	}
	if this.Language != that1.Language {
		return false
	}
	return true
}
func (this *C2SGetFuncState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SGetFuncState)
	if !ok {
		that2, ok := that.(C2SGetFuncState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *S2CFuncOpen) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CFuncOpen)
	if !ok {
		that2, ok := that.(S2CFuncOpen)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		if !this.List[i].Equal(that1.List[i]) {
			return false
		}
	}
	return true
}
func (this *FuncState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FuncState)
	if !ok {
		that2, ok := that.(FuncState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *C2SGetRoomPlayerInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SGetRoomPlayerInfo)
	if !ok {
		that2, ok := that.(C2SGetRoomPlayerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.GameType != that1.GameType {
		return false
	}
	return true
}
func (this *S2CGetRoomPlayerInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CGetRoomPlayerInfo)
	if !ok {
		that2, ok := that.(S2CGetRoomPlayerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Head != that1.Head {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.WinCount != that1.WinCount {
		return false
	}
	if this.TotalCount != that1.TotalCount {
		return false
	}
	return true
}
func (this *S2CKick) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CKick)
	if !ok {
		that2, ok := that.(S2CKick)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *GetPlayerData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.GetPlayerData{")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlayerData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto_player.PlayerData{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Base != nil {
		s = append(s, "Base: "+fmt.Sprintf("%#v", this.Base)+",\n")
	}
	if this.Room != nil {
		s = append(s, "Room: "+fmt.Sprintf("%#v", this.Room)+",\n")
	}
	if this.Bag != nil {
		s = append(s, "Bag: "+fmt.Sprintf("%#v", this.Bag)+",\n")
	}
	if this.Game != nil {
		s = append(s, "Game: "+fmt.Sprintf("%#v", this.Game)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlayerBase) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto_player.PlayerBase{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Money: "+fmt.Sprintf("%#v", this.Money)+",\n")
	s = append(s, "Coin: "+fmt.Sprintf("%#v", this.Coin)+",\n")
	s = append(s, "Head: "+fmt.Sprintf("%#v", this.Head)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlayerGame) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.PlayerGame{")
	if this.GameInfos != nil {
		s = append(s, "GameInfos: "+fmt.Sprintf("%#v", this.GameInfos)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GameInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&proto_player.GameInfo{")
	s = append(s, "GameType: "+fmt.Sprintf("%#v", this.GameType)+",\n")
	s = append(s, "TotalCount: "+fmt.Sprintf("%#v", this.TotalCount)+",\n")
	s = append(s, "WinCount: "+fmt.Sprintf("%#v", this.WinCount)+",\n")
	s = append(s, "MaxWin: "+fmt.Sprintf("%#v", this.MaxWin)+",\n")
	s = append(s, "TotalWin: "+fmt.Sprintf("%#v", this.TotalWin)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "CardType: "+fmt.Sprintf("%#v", this.CardType)+",\n")
	s = append(s, "RaiseCount: "+fmt.Sprintf("%#v", this.RaiseCount)+",\n")
	s = append(s, "RaiseCounts: "+fmt.Sprintf("%#v", this.RaiseCounts)+",\n")
	s = append(s, "FoldCounts: "+fmt.Sprintf("%#v", this.FoldCounts)+",\n")
	s = append(s, "IntroCount: "+fmt.Sprintf("%#v", this.IntroCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto_player.RoomOptions{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "AutoBuy: "+fmt.Sprintf("%#v", this.AutoBuy)+",\n")
	s = append(s, "AutoBuyMax: "+fmt.Sprintf("%#v", this.AutoBuyMax)+",\n")
	s = append(s, "Buy: "+fmt.Sprintf("%#v", this.Buy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlayerRoom) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.PlayerRoom{")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SGetMailList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_player.C2SGetMailList{")
	s = append(s, "Start: "+fmt.Sprintf("%#v", this.Start)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CGetMailList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.S2CGetMailList{")
	if this.MailList != nil {
		s = append(s, "MailList: "+fmt.Sprintf("%#v", this.MailList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Mail) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&proto_player.Mail{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "IsRead: "+fmt.Sprintf("%#v", this.IsRead)+",\n")
	s = append(s, "IsReceiveAward: "+fmt.Sprintf("%#v", this.IsReceiveAward)+",\n")
	s = append(s, "CreateTime: "+fmt.Sprintf("%#v", this.CreateTime)+",\n")
	s = append(s, "WithAward: "+fmt.Sprintf("%#v", this.WithAward)+",\n")
	s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	if this.Award != nil {
		s = append(s, "Award: "+fmt.Sprintf("%#v", this.Award)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SGetMailDetail) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.C2SGetMailDetail{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CGetMailDetail) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto_player.S2CGetMailDetail{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "MailTitle: "+fmt.Sprintf("%#v", this.MailTitle)+",\n")
	s = append(s, "MailContent: "+fmt.Sprintf("%#v", this.MailContent)+",\n")
	if this.Accessory != nil {
		s = append(s, "Accessory: "+fmt.Sprintf("%#v", this.Accessory)+",\n")
	}
	s = append(s, "IsReceiveAward: "+fmt.Sprintf("%#v", this.IsReceiveAward)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccessoryInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_player.AccessoryInfo{")
	s = append(s, "ItemId: "+fmt.Sprintf("%#v", this.ItemId)+",\n")
	s = append(s, "ItemNumber: "+fmt.Sprintf("%#v", this.ItemNumber)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CNewMail) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_player.S2CNewMail{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SDeleteMail) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.C2SDeleteMail{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CDeleteMail) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.S2CDeleteMail{")
	s = append(s, "Access: "+fmt.Sprintf("%#v", this.Access)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SReceiveMailAward) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.C2SReceiveMailAward{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CReceiveMailAward) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.S2CReceiveMailAward{")
	s = append(s, "Access: "+fmt.Sprintf("%#v", this.Access)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Item) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_player.Item{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlayerBag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.PlayerBag{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CBag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.S2CBag{")
	if this.Update != nil {
		s = append(s, "Update: "+fmt.Sprintf("%#v", this.Update)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CNotice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proto_player.S2CNotice{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "Times: "+fmt.Sprintf("%#v", this.Times)+",\n")
	s = append(s, "TimeSpan: "+fmt.Sprintf("%#v", this.TimeSpan)+",\n")
	s = append(s, "Content: "+fmt.Sprintf("%#v", this.Content)+",\n")
	s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SGMCommand) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.C2SGMCommand{")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SPlayerRename) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.C2SPlayerRename{")
	s = append(s, "NewName: "+fmt.Sprintf("%#v", this.NewName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CPlayerRename) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_player.S2CPlayerRename{")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	s = append(s, "NewName: "+fmt.Sprintf("%#v", this.NewName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SChangeHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.C2SChangeHead{")
	s = append(s, "Head: "+fmt.Sprintf("%#v", this.Head)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CChangeHead) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_player.S2CChangeHead{")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	s = append(s, "NewHead: "+fmt.Sprintf("%#v", this.NewHead)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SGetAllTask) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_player.C2SGetAllTask{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CGetAllTask) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.S2CGetAllTask{")
	if this.TaskList != nil {
		s = append(s, "TaskList: "+fmt.Sprintf("%#v", this.TaskList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SReceiveTaskAward) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.C2SReceiveTaskAward{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CReceiveTaskAward) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_player.S2CReceiveTaskAward{")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	if this.Award != nil {
		s = append(s, "Award: "+fmt.Sprintf("%#v", this.Award)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CTaskUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.S2CTaskUpdate{")
	if this.TaskList != nil {
		s = append(s, "TaskList: "+fmt.Sprintf("%#v", this.TaskList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Task) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proto_player.Task{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "TaskType: "+fmt.Sprintf("%#v", this.TaskType)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CResourceChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_player.S2CResourceChanged{")
	s = append(s, "Types: "+fmt.Sprintf("%#v", this.Types)+",\n")
	s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CGameInfoChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.S2CGameInfoChanged{")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CAnnouncement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.S2CAnnouncement{")
	if this.Datas != nil {
		s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Announcement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&proto_player.Announcement{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "OpenTime: "+fmt.Sprintf("%#v", this.OpenTime)+",\n")
	s = append(s, "CloseTime: "+fmt.Sprintf("%#v", this.CloseTime)+",\n")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "Content: "+fmt.Sprintf("%#v", this.Content)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Language: "+fmt.Sprintf("%#v", this.Language)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SGetFuncState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_player.C2SGetFuncState{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CFuncOpen) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_player.S2CFuncOpen{")
	if this.List != nil {
		s = append(s, "List: "+fmt.Sprintf("%#v", this.List)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FuncState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_player.FuncState{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SGetRoomPlayerInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_player.C2SGetRoomPlayerInfo{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "GameType: "+fmt.Sprintf("%#v", this.GameType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CGetRoomPlayerInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto_player.S2CGetRoomPlayerInfo{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Head: "+fmt.Sprintf("%#v", this.Head)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "WinCount: "+fmt.Sprintf("%#v", this.WinCount)+",\n")
	s = append(s, "TotalCount: "+fmt.Sprintf("%#v", this.TotalCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CKick) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_player.S2CKick{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPlayer(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GetPlayerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPlayerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPlayerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Game != nil {
		{
			size, err := m.Game.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Bag != nil {
		{
			size, err := m.Bag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Room != nil {
		{
			size, err := m.Room.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayerBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Coin != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Coin))
		i--
		dAtA[i] = 0x20
	}
	if m.Money != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayerGame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerGame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerGame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GameInfos) > 0 {
		for iNdEx := len(m.GameInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GameInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GameInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IntroCount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.IntroCount))
		i--
		dAtA[i] = 0x58
	}
	if len(m.FoldCounts) > 0 {
		dAtA7 := make([]byte, len(m.FoldCounts)*10)
		var j6 int
		for _, num1 := range m.FoldCounts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintPlayer(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x52
	}
	if len(m.RaiseCounts) > 0 {
		dAtA9 := make([]byte, len(m.RaiseCounts)*10)
		var j8 int
		for _, num1 := range m.RaiseCounts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintPlayer(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x4a
	}
	if m.RaiseCount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.RaiseCount))
		i--
		dAtA[i] = 0x40
	}
	if m.CardType != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.CardType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Cards) > 0 {
		dAtA11 := make([]byte, len(m.Cards)*10)
		var j10 int
		for _, num1 := range m.Cards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintPlayer(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x32
	}
	if m.TotalWin != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.TotalWin))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxWin != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.MaxWin))
		i--
		dAtA[i] = 0x20
	}
	if m.WinCount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.WinCount))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalCount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x10
	}
	if m.GameType != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.GameType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoomOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Buy != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Buy))
		i--
		dAtA[i] = 0x20
	}
	if m.AutoBuyMax {
		i--
		if m.AutoBuyMax {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AutoBuy {
		i--
		if m.AutoBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayerRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Options) > 0 {
		for iNdEx := len(m.Options) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Options[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C2SGetMailList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SGetMailList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SGetMailList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CGetMailList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGetMailList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CGetMailList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MailList) > 0 {
		for iNdEx := len(m.MailList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MailList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Mail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Mail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Award != nil {
		{
			size, err := m.Award.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x3a
	}
	if m.WithAward {
		i--
		if m.WithAward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.CreateTime != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x28
	}
	if m.IsReceiveAward {
		i--
		if m.IsReceiveAward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsRead {
		i--
		if m.IsRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SGetMailDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SGetMailDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SGetMailDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CGetMailDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGetMailDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CGetMailDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsReceiveAward {
		i--
		if m.IsReceiveAward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Accessory) > 0 {
		for iNdEx := len(m.Accessory) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Accessory[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MailContent) > 0 {
		i -= len(m.MailContent)
		copy(dAtA[i:], m.MailContent)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.MailContent)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MailTitle) > 0 {
		i -= len(m.MailTitle)
		copy(dAtA[i:], m.MailTitle)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.MailTitle)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccessoryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessoryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessoryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ItemNumber != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.ItemNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.ItemId != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.ItemId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNewMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNewMail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNewMail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *C2SDeleteMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SDeleteMail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SDeleteMail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CDeleteMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CDeleteMail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CDeleteMail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Access {
		i--
		if m.Access {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SReceiveMailAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SReceiveMailAward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SReceiveMailAward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CReceiveMailAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CReceiveMailAward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CReceiveMailAward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Access {
		i--
		if m.Access {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayerBag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerBag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerBag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *S2CBag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CBag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CBag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CNotice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNotice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNotice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Params[iNdEx])
			copy(dAtA[i:], m.Params[iNdEx])
			i = encodeVarintPlayer(dAtA, i, uint64(len(m.Params[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TimeSpan != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.TimeSpan))
		i--
		dAtA[i] = 0x20
	}
	if m.Times != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Times))
		i--
		dAtA[i] = 0x18
	}
	if m.Priority != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SGMCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SGMCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SGMCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C2SPlayerRename) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SPlayerRename) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SPlayerRename) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewName) > 0 {
		i -= len(m.NewName)
		copy(dAtA[i:], m.NewName)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.NewName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CPlayerRename) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CPlayerRename) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CPlayerRename) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewName) > 0 {
		i -= len(m.NewName)
		copy(dAtA[i:], m.NewName)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.NewName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SChangeHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SChangeHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SChangeHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CChangeHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CChangeHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CChangeHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewHead) > 0 {
		i -= len(m.NewHead)
		copy(dAtA[i:], m.NewHead)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.NewHead)))
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SGetAllTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SGetAllTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SGetAllTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *S2CGetAllTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGetAllTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CGetAllTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TaskList) > 0 {
		for iNdEx := len(m.TaskList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TaskList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C2SReceiveTaskAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SReceiveTaskAward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SReceiveTaskAward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CReceiveTaskAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CReceiveTaskAward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CReceiveTaskAward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Award) > 0 {
		for iNdEx := len(m.Award) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Award[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CTaskUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CTaskUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CTaskUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TaskList) > 0 {
		for iNdEx := len(m.TaskList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TaskList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Task) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Task) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Task) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if m.Target != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Target))
		i--
		dAtA[i] = 0x28
	}
	if m.Count != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x20
	}
	if m.TaskType != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.TaskType))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CResourceChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CResourceChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CResourceChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		dAtA15 := make([]byte, len(m.Values)*10)
		var j14 int
		for _, num1 := range m.Values {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintPlayer(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Types) > 0 {
		dAtA17 := make([]byte, len(m.Types)*10)
		var j16 int
		for _, num1 := range m.Types {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintPlayer(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CGameInfoChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGameInfoChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CGameInfoChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CAnnouncement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CAnnouncement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CAnnouncement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Datas) > 0 {
		for iNdEx := len(m.Datas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Datas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Announcement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Announcement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Announcement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Version) > 0 {
		for iNdEx := len(m.Version) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Version[iNdEx])
			copy(dAtA[i:], m.Version[iNdEx])
			i = encodeVarintPlayer(dAtA, i, uint64(len(m.Version[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x42
	}
	if m.Channel != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x38
	}
	if m.Priority != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x30
	}
	if m.Count != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x28
	}
	if m.CloseTime != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.CloseTime))
		i--
		dAtA[i] = 0x20
	}
	if m.OpenTime != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.OpenTime))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SGetFuncState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SGetFuncState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SGetFuncState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *S2CFuncOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CFuncOpen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CFuncOpen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FuncState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FuncState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FuncState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SGetRoomPlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SGetRoomPlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SGetRoomPlayerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GameType != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.GameType))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CGetRoomPlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGetRoomPlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CGetRoomPlayerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalCount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x28
	}
	if m.WinCount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.WinCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CKick) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CKick) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CKick) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintPlayer(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlayer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetPlayerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *PlayerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Room != nil {
		l = m.Room.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Bag != nil {
		l = m.Bag.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Game != nil {
		l = m.Game.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *PlayerBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovPlayer(uint64(m.Level))
	}
	if m.Money != 0 {
		n += 1 + sovPlayer(uint64(m.Money))
	}
	if m.Coin != 0 {
		n += 1 + sovPlayer(uint64(m.Coin))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *PlayerGame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GameInfos) > 0 {
		for _, e := range m.GameInfos {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *GameInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameType != 0 {
		n += 1 + sovPlayer(uint64(m.GameType))
	}
	if m.TotalCount != 0 {
		n += 1 + sovPlayer(uint64(m.TotalCount))
	}
	if m.WinCount != 0 {
		n += 1 + sovPlayer(uint64(m.WinCount))
	}
	if m.MaxWin != 0 {
		n += 1 + sovPlayer(uint64(m.MaxWin))
	}
	if m.TotalWin != 0 {
		n += 1 + sovPlayer(uint64(m.TotalWin))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovPlayer(uint64(e))
		}
		n += 1 + sovPlayer(uint64(l)) + l
	}
	if m.CardType != 0 {
		n += 1 + sovPlayer(uint64(m.CardType))
	}
	if m.RaiseCount != 0 {
		n += 1 + sovPlayer(uint64(m.RaiseCount))
	}
	if len(m.RaiseCounts) > 0 {
		l = 0
		for _, e := range m.RaiseCounts {
			l += sovPlayer(uint64(e))
		}
		n += 1 + sovPlayer(uint64(l)) + l
	}
	if len(m.FoldCounts) > 0 {
		l = 0
		for _, e := range m.FoldCounts {
			l += sovPlayer(uint64(e))
		}
		n += 1 + sovPlayer(uint64(l)) + l
	}
	if m.IntroCount != 0 {
		n += 1 + sovPlayer(uint64(m.IntroCount))
	}
	return n
}

func (m *RoomOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	if m.AutoBuy {
		n += 2
	}
	if m.AutoBuyMax {
		n += 2
	}
	if m.Buy != 0 {
		n += 1 + sovPlayer(uint64(m.Buy))
	}
	return n
}

func (m *PlayerRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Options) > 0 {
		for _, e := range m.Options {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *C2SGetMailList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovPlayer(uint64(m.Start))
	}
	if m.Count != 0 {
		n += 1 + sovPlayer(uint64(m.Count))
	}
	return n
}

func (m *S2CGetMailList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MailList) > 0 {
		for _, e := range m.MailList {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *Mail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.IsRead {
		n += 2
	}
	if m.IsReceiveAward {
		n += 2
	}
	if m.CreateTime != 0 {
		n += 1 + sovPlayer(uint64(m.CreateTime))
	}
	if m.WithAward {
		n += 2
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Award != nil {
		l = m.Award.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *C2SGetMailDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	return n
}

func (m *S2CGetMailDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	l = len(m.MailTitle)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.MailContent)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if len(m.Accessory) > 0 {
		for _, e := range m.Accessory {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	if m.IsReceiveAward {
		n += 2
	}
	return n
}

func (m *AccessoryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemId != 0 {
		n += 1 + sovPlayer(uint64(m.ItemId))
	}
	if m.ItemNumber != 0 {
		n += 1 + sovPlayer(uint64(m.ItemNumber))
	}
	return n
}

func (m *S2CNewMail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *C2SDeleteMail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	return n
}

func (m *S2CDeleteMail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Access {
		n += 2
	}
	return n
}

func (m *C2SReceiveMailAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	return n
}

func (m *S2CReceiveMailAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Access {
		n += 2
	}
	return n
}

func (m *Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	if m.Count != 0 {
		n += 1 + sovPlayer(uint64(m.Count))
	}
	return n
}

func (m *PlayerBag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *S2CBag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *S2CNotice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPlayer(uint64(m.Type))
	}
	if m.Priority != 0 {
		n += 1 + sovPlayer(uint64(m.Priority))
	}
	if m.Times != 0 {
		n += 1 + sovPlayer(uint64(m.Times))
	}
	if m.TimeSpan != 0 {
		n += 1 + sovPlayer(uint64(m.TimeSpan))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if len(m.Params) > 0 {
		for _, s := range m.Params {
			l = len(s)
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *C2SGMCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *C2SPlayerRename) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NewName)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *S2CPlayerRename) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.NewName)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *C2SChangeHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *S2CChangeHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.NewHead)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *C2SGetAllTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2CGetAllTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TaskList) > 0 {
		for _, e := range m.TaskList {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *C2SReceiveTaskAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	return n
}

func (m *S2CReceiveTaskAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if len(m.Award) > 0 {
		for _, e := range m.Award {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *S2CTaskUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TaskList) > 0 {
		for _, e := range m.TaskList {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *Task) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovPlayer(uint64(m.Type))
	}
	if m.TaskType != 0 {
		n += 1 + sovPlayer(uint64(m.TaskType))
	}
	if m.Count != 0 {
		n += 1 + sovPlayer(uint64(m.Count))
	}
	if m.Target != 0 {
		n += 1 + sovPlayer(uint64(m.Target))
	}
	if m.State != 0 {
		n += 1 + sovPlayer(uint64(m.State))
	}
	return n
}

func (m *S2CResourceChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovPlayer(uint64(e))
		}
		n += 1 + sovPlayer(uint64(l)) + l
	}
	if len(m.Values) > 0 {
		l = 0
		for _, e := range m.Values {
			l += sovPlayer(uint64(e))
		}
		n += 1 + sovPlayer(uint64(l)) + l
	}
	return n
}

func (m *S2CGameInfoChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *S2CAnnouncement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Datas) > 0 {
		for _, e := range m.Datas {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *Announcement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovPlayer(uint64(m.Type))
	}
	if m.OpenTime != 0 {
		n += 1 + sovPlayer(uint64(m.OpenTime))
	}
	if m.CloseTime != 0 {
		n += 1 + sovPlayer(uint64(m.CloseTime))
	}
	if m.Count != 0 {
		n += 1 + sovPlayer(uint64(m.Count))
	}
	if m.Priority != 0 {
		n += 1 + sovPlayer(uint64(m.Priority))
	}
	if m.Channel != 0 {
		n += 1 + sovPlayer(uint64(m.Channel))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if len(m.Version) > 0 {
		for _, s := range m.Version {
			l = len(s)
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *C2SGetFuncState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2CFuncOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *FuncState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	if m.State != 0 {
		n += 1 + sovPlayer(uint64(m.State))
	}
	return n
}

func (m *C2SGetRoomPlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	if m.GameType != 0 {
		n += 1 + sovPlayer(uint64(m.GameType))
	}
	return n
}

func (m *S2CGetRoomPlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.WinCount != 0 {
		n += 1 + sovPlayer(uint64(m.WinCount))
	}
	if m.TotalCount != 0 {
		n += 1 + sovPlayer(uint64(m.TotalCount))
	}
	return n
}

func (m *S2CKick) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovPlayer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlayer(x uint64) (n int) {
	return sovPlayer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GetPlayerData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetPlayerData{`,
		`Data:` + strings.Replace(this.Data.String(), "PlayerData", "PlayerData", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayerData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlayerData{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Base:` + strings.Replace(this.Base.String(), "PlayerBase", "PlayerBase", 1) + `,`,
		`Room:` + strings.Replace(this.Room.String(), "PlayerRoom", "PlayerRoom", 1) + `,`,
		`Bag:` + strings.Replace(this.Bag.String(), "PlayerBag", "PlayerBag", 1) + `,`,
		`Game:` + strings.Replace(this.Game.String(), "PlayerGame", "PlayerGame", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayerBase) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlayerBase{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`Coin:` + fmt.Sprintf("%v", this.Coin) + `,`,
		`Head:` + fmt.Sprintf("%v", this.Head) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayerGame) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGameInfos := "[]*GameInfo{"
	for _, f := range this.GameInfos {
		repeatedStringForGameInfos += strings.Replace(f.String(), "GameInfo", "GameInfo", 1) + ","
	}
	repeatedStringForGameInfos += "}"
	s := strings.Join([]string{`&PlayerGame{`,
		`GameInfos:` + repeatedStringForGameInfos + `,`,
		`}`,
	}, "")
	return s
}
func (this *GameInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GameInfo{`,
		`GameType:` + fmt.Sprintf("%v", this.GameType) + `,`,
		`TotalCount:` + fmt.Sprintf("%v", this.TotalCount) + `,`,
		`WinCount:` + fmt.Sprintf("%v", this.WinCount) + `,`,
		`MaxWin:` + fmt.Sprintf("%v", this.MaxWin) + `,`,
		`TotalWin:` + fmt.Sprintf("%v", this.TotalWin) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`CardType:` + fmt.Sprintf("%v", this.CardType) + `,`,
		`RaiseCount:` + fmt.Sprintf("%v", this.RaiseCount) + `,`,
		`RaiseCounts:` + fmt.Sprintf("%v", this.RaiseCounts) + `,`,
		`FoldCounts:` + fmt.Sprintf("%v", this.FoldCounts) + `,`,
		`IntroCount:` + fmt.Sprintf("%v", this.IntroCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoomOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoomOptions{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`AutoBuy:` + fmt.Sprintf("%v", this.AutoBuy) + `,`,
		`AutoBuyMax:` + fmt.Sprintf("%v", this.AutoBuyMax) + `,`,
		`Buy:` + fmt.Sprintf("%v", this.Buy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayerRoom) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOptions := "[]*RoomOptions{"
	for _, f := range this.Options {
		repeatedStringForOptions += strings.Replace(f.String(), "RoomOptions", "RoomOptions", 1) + ","
	}
	repeatedStringForOptions += "}"
	s := strings.Join([]string{`&PlayerRoom{`,
		`Options:` + repeatedStringForOptions + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SGetMailList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SGetMailList{`,
		`Start:` + fmt.Sprintf("%v", this.Start) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CGetMailList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMailList := "[]*Mail{"
	for _, f := range this.MailList {
		repeatedStringForMailList += strings.Replace(f.String(), "Mail", "Mail", 1) + ","
	}
	repeatedStringForMailList += "}"
	s := strings.Join([]string{`&S2CGetMailList{`,
		`MailList:` + repeatedStringForMailList + `,`,
		`}`,
	}, "")
	return s
}
func (this *Mail) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Mail{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`IsRead:` + fmt.Sprintf("%v", this.IsRead) + `,`,
		`IsReceiveAward:` + fmt.Sprintf("%v", this.IsReceiveAward) + `,`,
		`CreateTime:` + fmt.Sprintf("%v", this.CreateTime) + `,`,
		`WithAward:` + fmt.Sprintf("%v", this.WithAward) + `,`,
		`Sender:` + fmt.Sprintf("%v", this.Sender) + `,`,
		`Award:` + strings.Replace(this.Award.String(), "AccessoryInfo", "AccessoryInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SGetMailDetail) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SGetMailDetail{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CGetMailDetail) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAccessory := "[]*AccessoryInfo{"
	for _, f := range this.Accessory {
		repeatedStringForAccessory += strings.Replace(f.String(), "AccessoryInfo", "AccessoryInfo", 1) + ","
	}
	repeatedStringForAccessory += "}"
	s := strings.Join([]string{`&S2CGetMailDetail{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`MailTitle:` + fmt.Sprintf("%v", this.MailTitle) + `,`,
		`MailContent:` + fmt.Sprintf("%v", this.MailContent) + `,`,
		`Accessory:` + repeatedStringForAccessory + `,`,
		`IsReceiveAward:` + fmt.Sprintf("%v", this.IsReceiveAward) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccessoryInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccessoryInfo{`,
		`ItemId:` + fmt.Sprintf("%v", this.ItemId) + `,`,
		`ItemNumber:` + fmt.Sprintf("%v", this.ItemNumber) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CNewMail) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CNewMail{`,
		`}`,
	}, "")
	return s
}
func (this *C2SDeleteMail) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SDeleteMail{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CDeleteMail) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CDeleteMail{`,
		`Access:` + fmt.Sprintf("%v", this.Access) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SReceiveMailAward) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SReceiveMailAward{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CReceiveMailAward) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CReceiveMailAward{`,
		`Access:` + fmt.Sprintf("%v", this.Access) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Item) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Item{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayerBag) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*Item{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "Item", "Item", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&PlayerBag{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CBag) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CBag{`,
		`Update:` + strings.Replace(this.Update.String(), "Item", "Item", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CNotice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CNotice{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`Times:` + fmt.Sprintf("%v", this.Times) + `,`,
		`TimeSpan:` + fmt.Sprintf("%v", this.TimeSpan) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`Params:` + fmt.Sprintf("%v", this.Params) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SGMCommand) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SGMCommand{`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SPlayerRename) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SPlayerRename{`,
		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CPlayerRename) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CPlayerRename{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SChangeHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SChangeHead{`,
		`Head:` + fmt.Sprintf("%v", this.Head) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CChangeHead) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CChangeHead{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`NewHead:` + fmt.Sprintf("%v", this.NewHead) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SGetAllTask) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SGetAllTask{`,
		`}`,
	}, "")
	return s
}
func (this *S2CGetAllTask) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTaskList := "[]*Task{"
	for _, f := range this.TaskList {
		repeatedStringForTaskList += strings.Replace(f.String(), "Task", "Task", 1) + ","
	}
	repeatedStringForTaskList += "}"
	s := strings.Join([]string{`&S2CGetAllTask{`,
		`TaskList:` + repeatedStringForTaskList + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SReceiveTaskAward) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SReceiveTaskAward{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CReceiveTaskAward) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAward := "[]*AccessoryInfo{"
	for _, f := range this.Award {
		repeatedStringForAward += strings.Replace(f.String(), "AccessoryInfo", "AccessoryInfo", 1) + ","
	}
	repeatedStringForAward += "}"
	s := strings.Join([]string{`&S2CReceiveTaskAward{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`Award:` + repeatedStringForAward + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CTaskUpdate) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTaskList := "[]*Task{"
	for _, f := range this.TaskList {
		repeatedStringForTaskList += strings.Replace(f.String(), "Task", "Task", 1) + ","
	}
	repeatedStringForTaskList += "}"
	s := strings.Join([]string{`&S2CTaskUpdate{`,
		`TaskList:` + repeatedStringForTaskList + `,`,
		`}`,
	}, "")
	return s
}
func (this *Task) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Task{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`TaskType:` + fmt.Sprintf("%v", this.TaskType) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Target:` + fmt.Sprintf("%v", this.Target) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CResourceChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CResourceChanged{`,
		`Types:` + fmt.Sprintf("%v", this.Types) + `,`,
		`Values:` + fmt.Sprintf("%v", this.Values) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CGameInfoChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CGameInfoChanged{`,
		`Info:` + strings.Replace(this.Info.String(), "GameInfo", "GameInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CAnnouncement) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDatas := "[]*Announcement{"
	for _, f := range this.Datas {
		repeatedStringForDatas += strings.Replace(f.String(), "Announcement", "Announcement", 1) + ","
	}
	repeatedStringForDatas += "}"
	s := strings.Join([]string{`&S2CAnnouncement{`,
		`Datas:` + repeatedStringForDatas + `,`,
		`}`,
	}, "")
	return s
}
func (this *Announcement) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Announcement{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`OpenTime:` + fmt.Sprintf("%v", this.OpenTime) + `,`,
		`CloseTime:` + fmt.Sprintf("%v", this.CloseTime) + `,`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Language:` + fmt.Sprintf("%v", this.Language) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SGetFuncState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SGetFuncState{`,
		`}`,
	}, "")
	return s
}
func (this *S2CFuncOpen) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForList := "[]*FuncState{"
	for _, f := range this.List {
		repeatedStringForList += strings.Replace(f.String(), "FuncState", "FuncState", 1) + ","
	}
	repeatedStringForList += "}"
	s := strings.Join([]string{`&S2CFuncOpen{`,
		`List:` + repeatedStringForList + `,`,
		`}`,
	}, "")
	return s
}
func (this *FuncState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FuncState{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SGetRoomPlayerInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SGetRoomPlayerInfo{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`GameType:` + fmt.Sprintf("%v", this.GameType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CGetRoomPlayerInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CGetRoomPlayerInfo{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Head:` + fmt.Sprintf("%v", this.Head) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`WinCount:` + fmt.Sprintf("%v", this.WinCount) + `,`,
		`TotalCount:` + fmt.Sprintf("%v", this.TotalCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CKick) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CKick{`,
		`}`,
	}, "")
	return s
}
func valueToStringPlayer(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GetPlayerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPlayerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPlayerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &PlayerData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &PlayerBase{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Room == nil {
				m.Room = &PlayerRoom{}
			}
			if err := m.Room.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bag == nil {
				m.Bag = &PlayerBag{}
			}
			if err := m.Bag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Game", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Game == nil {
				m.Game = &PlayerGame{}
			}
			if err := m.Game.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerGame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerGame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerGame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameInfos = append(m.GameInfos, &GameInfo{})
			if err := m.GameInfos[len(m.GameInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameType", wireType)
			}
			m.GameType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinCount", wireType)
			}
			m.WinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWin", wireType)
			}
			m.MaxWin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWin", wireType)
			}
			m.TotalWin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalWin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlayer
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlayer
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cards) == 0 {
					m.Cards = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardType", wireType)
			}
			m.CardType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaiseCount", wireType)
			}
			m.RaiseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaiseCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RaiseCounts = append(m.RaiseCounts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlayer
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlayer
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RaiseCounts) == 0 {
					m.RaiseCounts = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RaiseCounts = append(m.RaiseCounts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RaiseCounts", wireType)
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FoldCounts = append(m.FoldCounts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlayer
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlayer
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FoldCounts) == 0 {
					m.FoldCounts = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FoldCounts = append(m.FoldCounts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FoldCounts", wireType)
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntroCount", wireType)
			}
			m.IntroCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntroCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoBuy = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoBuyMax", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoBuyMax = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buy", wireType)
			}
			m.Buy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Buy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, &RoomOptions{})
			if err := m.Options[len(m.Options)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SGetMailList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SGetMailList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SGetMailList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGetMailList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGetMailList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGetMailList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailList = append(m.MailList, &Mail{})
			if err := m.MailList[len(m.MailList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRead = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReceiveAward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReceiveAward = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithAward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithAward = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Award", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Award == nil {
				m.Award = &AccessoryInfo{}
			}
			if err := m.Award.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SGetMailDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SGetMailDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SGetMailDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGetMailDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGetMailDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGetMailDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MailContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accessory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accessory = append(m.Accessory, &AccessoryInfo{})
			if err := m.Accessory[len(m.Accessory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReceiveAward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReceiveAward = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessoryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessoryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessoryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			m.ItemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemNumber", wireType)
			}
			m.ItemNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNewMail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CNewMail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CNewMail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SDeleteMail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SDeleteMail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SDeleteMail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CDeleteMail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CDeleteMail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CDeleteMail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Access = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SReceiveMailAward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SReceiveMailAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SReceiveMailAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CReceiveMailAward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CReceiveMailAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CReceiveMailAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Access = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerBag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerBag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerBag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CBag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CBag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CBag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Update == nil {
				m.Update = &Item{}
			}
			if err := m.Update.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNotice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CNotice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CNotice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Times", wireType)
			}
			m.Times = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Times |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSpan", wireType)
			}
			m.TimeSpan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSpan |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SGMCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SGMCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SGMCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SPlayerRename) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SPlayerRename: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SPlayerRename: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CPlayerRename) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CPlayerRename: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CPlayerRename: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SChangeHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SChangeHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SChangeHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CChangeHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CChangeHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CChangeHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewHead", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewHead = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SGetAllTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SGetAllTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SGetAllTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGetAllTask) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGetAllTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGetAllTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskList = append(m.TaskList, &Task{})
			if err := m.TaskList[len(m.TaskList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SReceiveTaskAward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SReceiveTaskAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SReceiveTaskAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CReceiveTaskAward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CReceiveTaskAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CReceiveTaskAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Award", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Award = append(m.Award, &AccessoryInfo{})
			if err := m.Award[len(m.Award)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CTaskUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CTaskUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CTaskUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskList = append(m.TaskList, &Task{})
			if err := m.TaskList[len(m.TaskList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Task) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskType", wireType)
			}
			m.TaskType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CResourceChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CResourceChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CResourceChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlayer
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlayer
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Values = append(m.Values, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlayer
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPlayer
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Values = append(m.Values, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGameInfoChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGameInfoChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGameInfoChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &GameInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CAnnouncement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CAnnouncement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CAnnouncement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas, &Announcement{})
			if err := m.Datas[len(m.Datas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Announcement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Announcement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Announcement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTime", wireType)
			}
			m.OpenTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseTime", wireType)
			}
			m.CloseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloseTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = append(m.Version, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SGetFuncState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SGetFuncState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SGetFuncState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CFuncOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CFuncOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CFuncOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &FuncState{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FuncState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FuncState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FuncState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SGetRoomPlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SGetRoomPlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SGetRoomPlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameType", wireType)
			}
			m.GameType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGetRoomPlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGetRoomPlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGetRoomPlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinCount", wireType)
			}
			m.WinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CKick) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CKick: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CKick: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlayer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlayer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlayer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlayer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlayer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlayer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlayer = fmt.Errorf("proto: unexpected end of group")
)
