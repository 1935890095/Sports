// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto_node/node.proto

package proto_node

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Ping struct {
	Index   int32  `protobuf:"varint,1,opt,name=Index,proto3" json:"Index,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
	Id      string `protobuf:"bytes,3,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *Ping) Reset()      { *m = Ping{} }
func (*Ping) ProtoMessage() {}
func (*Ping) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{0}
}
func (m *Ping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ping.Merge(m, src)
}
func (m *Ping) XXX_Size() int {
	return m.Size()
}
func (m *Ping) XXX_DiscardUnknown() {
	xxx_messageInfo_Ping.DiscardUnknown(m)
}

var xxx_messageInfo_Ping proto.InternalMessageInfo

func (m *Ping) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Ping) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Ping) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Pong struct {
	Index int32 `protobuf:"varint,1,opt,name=Index,proto3" json:"Index,omitempty"`
}

func (m *Pong) Reset()      { *m = Pong{} }
func (*Pong) ProtoMessage() {}
func (*Pong) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{1}
}
func (m *Pong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pong.Merge(m, src)
}
func (m *Pong) XXX_Size() int {
	return m.Size()
}
func (m *Pong) XXX_DiscardUnknown() {
	xxx_messageInfo_Pong.DiscardUnknown(m)
}

var xxx_messageInfo_Pong proto.InternalMessageInfo

func (m *Pong) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

type PID struct {
	Address string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Id      string `protobuf:"bytes,2,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *PID) Reset()      { *m = PID{} }
func (*PID) ProtoMessage() {}
func (*PID) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{2}
}
func (m *PID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PID.Merge(m, src)
}
func (m *PID) XXX_Size() int {
	return m.Size()
}
func (m *PID) XXX_DiscardUnknown() {
	xxx_messageInfo_PID.DiscardUnknown(m)
}

var xxx_messageInfo_PID proto.InternalMessageInfo

func (m *PID) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *PID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// 节点之间流通的玩家数据
type Player struct {
	IsRobot bool   `protobuf:"varint,1,opt,name=IsRobot,proto3" json:"IsRobot,omitempty"`
	Id      int64  `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	Name    string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Level   int32  `protobuf:"varint,4,opt,name=Level,proto3" json:"Level,omitempty"`
	Money   int32  `protobuf:"varint,5,opt,name=Money,proto3" json:"Money,omitempty"`
	Head    string `protobuf:"bytes,6,opt,name=Head,proto3" json:"Head,omitempty"`
}

func (m *Player) Reset()      { *m = Player{} }
func (*Player) ProtoMessage() {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{3}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetIsRobot() bool {
	if m != nil {
		return m.IsRobot
	}
	return false
}

func (m *Player) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Player) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Player) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *Player) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

// 大厅请求匹配
type L2MRequest struct {
	New          bool    `protobuf:"varint,1,opt,name=New,proto3" json:"New,omitempty"`
	Player       *Player `protobuf:"bytes,2,opt,name=Player,proto3" json:"Player,omitempty"`
	RoomId       int32   `protobuf:"varint,3,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
	NumOfPlayers int32   `protobuf:"varint,4,opt,name=NumOfPlayers,proto3" json:"NumOfPlayers,omitempty"`
	ExcludeId    int64   `protobuf:"varint,5,opt,name=ExcludeId,proto3" json:"ExcludeId,omitempty"`
}

func (m *L2MRequest) Reset()      { *m = L2MRequest{} }
func (*L2MRequest) ProtoMessage() {}
func (*L2MRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{4}
}
func (m *L2MRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2MRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2MRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2MRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2MRequest.Merge(m, src)
}
func (m *L2MRequest) XXX_Size() int {
	return m.Size()
}
func (m *L2MRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_L2MRequest.DiscardUnknown(m)
}

var xxx_messageInfo_L2MRequest proto.InternalMessageInfo

func (m *L2MRequest) GetNew() bool {
	if m != nil {
		return m.New
	}
	return false
}

func (m *L2MRequest) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *L2MRequest) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *L2MRequest) GetNumOfPlayers() int32 {
	if m != nil {
		return m.NumOfPlayers
	}
	return 0
}

func (m *L2MRequest) GetExcludeId() int64 {
	if m != nil {
		return m.ExcludeId
	}
	return 0
}

// 大厅匹配结果
type L2MResponse struct {
	Success bool `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
	RoomPID *PID `protobuf:"bytes,2,opt,name=RoomPID,proto3" json:"RoomPID,omitempty"`
}

func (m *L2MResponse) Reset()      { *m = L2MResponse{} }
func (*L2MResponse) ProtoMessage() {}
func (*L2MResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{5}
}
func (m *L2MResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2MResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2MResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2MResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2MResponse.Merge(m, src)
}
func (m *L2MResponse) XXX_Size() int {
	return m.Size()
}
func (m *L2MResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_L2MResponse.DiscardUnknown(m)
}

var xxx_messageInfo_L2MResponse proto.InternalMessageInfo

func (m *L2MResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *L2MResponse) GetRoomPID() *PID {
	if m != nil {
		return m.RoomPID
	}
	return nil
}

// match请求创建游戏
type M2GCreateRequest struct {
	Player       *Player `protobuf:"bytes,1,opt,name=Player,proto3" json:"Player,omitempty"`
	GameId       int64   `protobuf:"varint,2,opt,name=GameId,proto3" json:"GameId,omitempty"`
	RoomId       int32   `protobuf:"varint,3,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
	MatchPID     *PID    `protobuf:"bytes,4,opt,name=MatchPID,proto3" json:"MatchPID,omitempty"`
	NumOfPlayers int32   `protobuf:"varint,5,opt,name=NumOfPlayers,proto3" json:"NumOfPlayers,omitempty"`
}

func (m *M2GCreateRequest) Reset()      { *m = M2GCreateRequest{} }
func (*M2GCreateRequest) ProtoMessage() {}
func (*M2GCreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{6}
}
func (m *M2GCreateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *M2GCreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_M2GCreateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *M2GCreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_M2GCreateRequest.Merge(m, src)
}
func (m *M2GCreateRequest) XXX_Size() int {
	return m.Size()
}
func (m *M2GCreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_M2GCreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_M2GCreateRequest proto.InternalMessageInfo

func (m *M2GCreateRequest) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *M2GCreateRequest) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *M2GCreateRequest) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *M2GCreateRequest) GetMatchPID() *PID {
	if m != nil {
		return m.MatchPID
	}
	return nil
}

func (m *M2GCreateRequest) GetNumOfPlayers() int32 {
	if m != nil {
		return m.NumOfPlayers
	}
	return 0
}

// match创建游戏结果
type M2GCreateResponse struct {
	Success bool `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
	RoomPID *PID `protobuf:"bytes,2,opt,name=RoomPID,proto3" json:"RoomPID,omitempty"`
}

func (m *M2GCreateResponse) Reset()      { *m = M2GCreateResponse{} }
func (*M2GCreateResponse) ProtoMessage() {}
func (*M2GCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{7}
}
func (m *M2GCreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *M2GCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_M2GCreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *M2GCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_M2GCreateResponse.Merge(m, src)
}
func (m *M2GCreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *M2GCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_M2GCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_M2GCreateResponse proto.InternalMessageInfo

func (m *M2GCreateResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *M2GCreateResponse) GetRoomPID() *PID {
	if m != nil {
		return m.RoomPID
	}
	return nil
}

// match请求game允许玩家进入房间
type M2GEnterRequest struct {
	PlayerId int64 `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
}

func (m *M2GEnterRequest) Reset()      { *m = M2GEnterRequest{} }
func (*M2GEnterRequest) ProtoMessage() {}
func (*M2GEnterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{8}
}
func (m *M2GEnterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *M2GEnterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_M2GEnterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *M2GEnterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_M2GEnterRequest.Merge(m, src)
}
func (m *M2GEnterRequest) XXX_Size() int {
	return m.Size()
}
func (m *M2GEnterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_M2GEnterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_M2GEnterRequest proto.InternalMessageInfo

func (m *M2GEnterRequest) GetPlayerId() int64 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

type M2GEnterResponse struct {
}

func (m *M2GEnterResponse) Reset()      { *m = M2GEnterResponse{} }
func (*M2GEnterResponse) ProtoMessage() {}
func (*M2GEnterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{9}
}
func (m *M2GEnterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *M2GEnterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_M2GEnterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *M2GEnterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_M2GEnterResponse.Merge(m, src)
}
func (m *M2GEnterResponse) XXX_Size() int {
	return m.Size()
}
func (m *M2GEnterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_M2GEnterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_M2GEnterResponse proto.InternalMessageInfo

// 大厅玩家请求进入
type L2GEnterRequest struct {
	Player *Player `protobuf:"bytes,1,opt,name=Player,proto3" json:"Player,omitempty"`
	PID    *PID    `protobuf:"bytes,2,opt,name=PID,proto3" json:"PID,omitempty"`
}

func (m *L2GEnterRequest) Reset()      { *m = L2GEnterRequest{} }
func (*L2GEnterRequest) ProtoMessage() {}
func (*L2GEnterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{10}
}
func (m *L2GEnterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2GEnterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2GEnterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2GEnterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2GEnterRequest.Merge(m, src)
}
func (m *L2GEnterRequest) XXX_Size() int {
	return m.Size()
}
func (m *L2GEnterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_L2GEnterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_L2GEnterRequest proto.InternalMessageInfo

func (m *L2GEnterRequest) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *L2GEnterRequest) GetPID() *PID {
	if m != nil {
		return m.PID
	}
	return nil
}

type L2GEnterResponse struct {
	Success bool  `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
	GameId  int64 `protobuf:"varint,2,opt,name=GameId,proto3" json:"GameId,omitempty"`
}

func (m *L2GEnterResponse) Reset()      { *m = L2GEnterResponse{} }
func (*L2GEnterResponse) ProtoMessage() {}
func (*L2GEnterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{11}
}
func (m *L2GEnterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2GEnterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2GEnterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2GEnterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2GEnterResponse.Merge(m, src)
}
func (m *L2GEnterResponse) XXX_Size() int {
	return m.Size()
}
func (m *L2GEnterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_L2GEnterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_L2GEnterResponse proto.InternalMessageInfo

func (m *L2GEnterResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *L2GEnterResponse) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

// 大厅玩家请求退出
type L2GLeaveRequest struct {
	Player *Player `protobuf:"bytes,1,opt,name=Player,proto3" json:"Player,omitempty"`
}

func (m *L2GLeaveRequest) Reset()      { *m = L2GLeaveRequest{} }
func (*L2GLeaveRequest) ProtoMessage() {}
func (*L2GLeaveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{12}
}
func (m *L2GLeaveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2GLeaveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2GLeaveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2GLeaveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2GLeaveRequest.Merge(m, src)
}
func (m *L2GLeaveRequest) XXX_Size() int {
	return m.Size()
}
func (m *L2GLeaveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_L2GLeaveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_L2GLeaveRequest proto.InternalMessageInfo

func (m *L2GLeaveRequest) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

type L2GLeaveResponse struct {
}

func (m *L2GLeaveResponse) Reset()      { *m = L2GLeaveResponse{} }
func (*L2GLeaveResponse) ProtoMessage() {}
func (*L2GLeaveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{13}
}
func (m *L2GLeaveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2GLeaveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2GLeaveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2GLeaveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2GLeaveResponse.Merge(m, src)
}
func (m *L2GLeaveResponse) XXX_Size() int {
	return m.Size()
}
func (m *L2GLeaveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_L2GLeaveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_L2GLeaveResponse proto.InternalMessageInfo

type L2GPlayerMessage struct {
	PlayerId    int64      `protobuf:"varint,1,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	RealMessage *types.Any `protobuf:"bytes,2,opt,name=RealMessage,proto3" json:"RealMessage,omitempty"`
}

func (m *L2GPlayerMessage) Reset()      { *m = L2GPlayerMessage{} }
func (*L2GPlayerMessage) ProtoMessage() {}
func (*L2GPlayerMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{14}
}
func (m *L2GPlayerMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2GPlayerMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2GPlayerMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2GPlayerMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2GPlayerMessage.Merge(m, src)
}
func (m *L2GPlayerMessage) XXX_Size() int {
	return m.Size()
}
func (m *L2GPlayerMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_L2GPlayerMessage.DiscardUnknown(m)
}

var xxx_messageInfo_L2GPlayerMessage proto.InternalMessageInfo

func (m *L2GPlayerMessage) GetPlayerId() int64 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *L2GPlayerMessage) GetRealMessage() *types.Any {
	if m != nil {
		return m.RealMessage
	}
	return nil
}

type G2LGameMessage struct {
	RealMessage *types.Any `protobuf:"bytes,1,opt,name=RealMessage,proto3" json:"RealMessage,omitempty"`
}

func (m *G2LGameMessage) Reset()      { *m = G2LGameMessage{} }
func (*G2LGameMessage) ProtoMessage() {}
func (*G2LGameMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{15}
}
func (m *G2LGameMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2LGameMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2LGameMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2LGameMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2LGameMessage.Merge(m, src)
}
func (m *G2LGameMessage) XXX_Size() int {
	return m.Size()
}
func (m *G2LGameMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_G2LGameMessage.DiscardUnknown(m)
}

var xxx_messageInfo_G2LGameMessage proto.InternalMessageInfo

func (m *G2LGameMessage) GetRealMessage() *types.Any {
	if m != nil {
		return m.RealMessage
	}
	return nil
}

// 玩家进入
type G2MPlayerEnter struct {
	GameId     int64 `protobuf:"varint,1,opt,name=GameId,proto3" json:"GameId,omitempty"`
	PlayerId   int64 `protobuf:"varint,2,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	NumOfPlay  int32 `protobuf:"varint,3,opt,name=NumOfPlay,proto3" json:"NumOfPlay,omitempty"`
	NumOfWatch int32 `protobuf:"varint,4,opt,name=NumOfWatch,proto3" json:"NumOfWatch,omitempty"`
}

func (m *G2MPlayerEnter) Reset()      { *m = G2MPlayerEnter{} }
func (*G2MPlayerEnter) ProtoMessage() {}
func (*G2MPlayerEnter) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{16}
}
func (m *G2MPlayerEnter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2MPlayerEnter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2MPlayerEnter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2MPlayerEnter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2MPlayerEnter.Merge(m, src)
}
func (m *G2MPlayerEnter) XXX_Size() int {
	return m.Size()
}
func (m *G2MPlayerEnter) XXX_DiscardUnknown() {
	xxx_messageInfo_G2MPlayerEnter.DiscardUnknown(m)
}

var xxx_messageInfo_G2MPlayerEnter proto.InternalMessageInfo

func (m *G2MPlayerEnter) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *G2MPlayerEnter) GetPlayerId() int64 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *G2MPlayerEnter) GetNumOfPlay() int32 {
	if m != nil {
		return m.NumOfPlay
	}
	return 0
}

func (m *G2MPlayerEnter) GetNumOfWatch() int32 {
	if m != nil {
		return m.NumOfWatch
	}
	return 0
}

// 玩家离开
type G2MPlayerLeave struct {
	GameId     int64 `protobuf:"varint,1,opt,name=GameId,proto3" json:"GameId,omitempty"`
	PlayerId   int64 `protobuf:"varint,2,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	NumOfPlay  int32 `protobuf:"varint,3,opt,name=NumOfPlay,proto3" json:"NumOfPlay,omitempty"`
	NumOfWatch int32 `protobuf:"varint,4,opt,name=NumOfWatch,proto3" json:"NumOfWatch,omitempty"`
}

func (m *G2MPlayerLeave) Reset()      { *m = G2MPlayerLeave{} }
func (*G2MPlayerLeave) ProtoMessage() {}
func (*G2MPlayerLeave) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{17}
}
func (m *G2MPlayerLeave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2MPlayerLeave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2MPlayerLeave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2MPlayerLeave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2MPlayerLeave.Merge(m, src)
}
func (m *G2MPlayerLeave) XXX_Size() int {
	return m.Size()
}
func (m *G2MPlayerLeave) XXX_DiscardUnknown() {
	xxx_messageInfo_G2MPlayerLeave.DiscardUnknown(m)
}

var xxx_messageInfo_G2MPlayerLeave proto.InternalMessageInfo

func (m *G2MPlayerLeave) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *G2MPlayerLeave) GetPlayerId() int64 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *G2MPlayerLeave) GetNumOfPlay() int32 {
	if m != nil {
		return m.NumOfPlay
	}
	return 0
}

func (m *G2MPlayerLeave) GetNumOfWatch() int32 {
	if m != nil {
		return m.NumOfWatch
	}
	return 0
}

// 打牌观战人数变化
type G2MPlayerChanged struct {
	GameId     int64 `protobuf:"varint,1,opt,name=GameId,proto3" json:"GameId,omitempty"`
	NumOfPlay  int32 `protobuf:"varint,2,opt,name=NumOfPlay,proto3" json:"NumOfPlay,omitempty"`
	NumOfWatch int32 `protobuf:"varint,3,opt,name=NumOfWatch,proto3" json:"NumOfWatch,omitempty"`
}

func (m *G2MPlayerChanged) Reset()      { *m = G2MPlayerChanged{} }
func (*G2MPlayerChanged) ProtoMessage() {}
func (*G2MPlayerChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{18}
}
func (m *G2MPlayerChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2MPlayerChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2MPlayerChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2MPlayerChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2MPlayerChanged.Merge(m, src)
}
func (m *G2MPlayerChanged) XXX_Size() int {
	return m.Size()
}
func (m *G2MPlayerChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_G2MPlayerChanged.DiscardUnknown(m)
}

var xxx_messageInfo_G2MPlayerChanged proto.InternalMessageInfo

func (m *G2MPlayerChanged) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *G2MPlayerChanged) GetNumOfPlay() int32 {
	if m != nil {
		return m.NumOfPlay
	}
	return 0
}

func (m *G2MPlayerChanged) GetNumOfWatch() int32 {
	if m != nil {
		return m.NumOfWatch
	}
	return 0
}

type G2LKickPlayer struct {
	Reason int32 `protobuf:"varint,1,opt,name=Reason,proto3" json:"Reason,omitempty"`
}

func (m *G2LKickPlayer) Reset()      { *m = G2LKickPlayer{} }
func (*G2LKickPlayer) ProtoMessage() {}
func (*G2LKickPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{19}
}
func (m *G2LKickPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2LKickPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2LKickPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2LKickPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2LKickPlayer.Merge(m, src)
}
func (m *G2LKickPlayer) XXX_Size() int {
	return m.Size()
}
func (m *G2LKickPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_G2LKickPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_G2LKickPlayer proto.InternalMessageInfo

func (m *G2LKickPlayer) GetReason() int32 {
	if m != nil {
		return m.Reason
	}
	return 0
}

type G2LCostRequest struct {
	Money int32 `protobuf:"varint,1,opt,name=Money,proto3" json:"Money,omitempty"`
}

func (m *G2LCostRequest) Reset()      { *m = G2LCostRequest{} }
func (*G2LCostRequest) ProtoMessage() {}
func (*G2LCostRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{20}
}
func (m *G2LCostRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2LCostRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2LCostRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2LCostRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2LCostRequest.Merge(m, src)
}
func (m *G2LCostRequest) XXX_Size() int {
	return m.Size()
}
func (m *G2LCostRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_G2LCostRequest.DiscardUnknown(m)
}

var xxx_messageInfo_G2LCostRequest proto.InternalMessageInfo

func (m *G2LCostRequest) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

type G2LCostResponse struct {
	Success bool  `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
	Money   int32 `protobuf:"varint,2,opt,name=Money,proto3" json:"Money,omitempty"`
}

func (m *G2LCostResponse) Reset()      { *m = G2LCostResponse{} }
func (*G2LCostResponse) ProtoMessage() {}
func (*G2LCostResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{21}
}
func (m *G2LCostResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2LCostResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2LCostResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2LCostResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2LCostResponse.Merge(m, src)
}
func (m *G2LCostResponse) XXX_Size() int {
	return m.Size()
}
func (m *G2LCostResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_G2LCostResponse.DiscardUnknown(m)
}

var xxx_messageInfo_G2LCostResponse proto.InternalMessageInfo

func (m *G2LCostResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *G2LCostResponse) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

type L2MCountsRequest struct {
}

func (m *L2MCountsRequest) Reset()      { *m = L2MCountsRequest{} }
func (*L2MCountsRequest) ProtoMessage() {}
func (*L2MCountsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{22}
}
func (m *L2MCountsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2MCountsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2MCountsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2MCountsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2MCountsRequest.Merge(m, src)
}
func (m *L2MCountsRequest) XXX_Size() int {
	return m.Size()
}
func (m *L2MCountsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_L2MCountsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_L2MCountsRequest proto.InternalMessageInfo

type L2MCountsResponse struct {
	RoomIds []int32 `protobuf:"varint,1,rep,packed,name=RoomIds,proto3" json:"RoomIds,omitempty"`
	Counts  []int32 `protobuf:"varint,2,rep,packed,name=Counts,proto3" json:"Counts,omitempty"`
}

func (m *L2MCountsResponse) Reset()      { *m = L2MCountsResponse{} }
func (*L2MCountsResponse) ProtoMessage() {}
func (*L2MCountsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{23}
}
func (m *L2MCountsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2MCountsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2MCountsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2MCountsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2MCountsResponse.Merge(m, src)
}
func (m *L2MCountsResponse) XXX_Size() int {
	return m.Size()
}
func (m *L2MCountsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_L2MCountsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_L2MCountsResponse proto.InternalMessageInfo

func (m *L2MCountsResponse) GetRoomIds() []int32 {
	if m != nil {
		return m.RoomIds
	}
	return nil
}

func (m *L2MCountsResponse) GetCounts() []int32 {
	if m != nil {
		return m.Counts
	}
	return nil
}

type L2GPlayerDisconnected struct {
}

func (m *L2GPlayerDisconnected) Reset()      { *m = L2GPlayerDisconnected{} }
func (*L2GPlayerDisconnected) ProtoMessage() {}
func (*L2GPlayerDisconnected) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{24}
}
func (m *L2GPlayerDisconnected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2GPlayerDisconnected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2GPlayerDisconnected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2GPlayerDisconnected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2GPlayerDisconnected.Merge(m, src)
}
func (m *L2GPlayerDisconnected) XXX_Size() int {
	return m.Size()
}
func (m *L2GPlayerDisconnected) XXX_DiscardUnknown() {
	xxx_messageInfo_L2GPlayerDisconnected.DiscardUnknown(m)
}

var xxx_messageInfo_L2GPlayerDisconnected proto.InternalMessageInfo

type G2MAllocRobot struct {
	Address string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	Id      string `protobuf:"bytes,2,opt,name=Id,proto3" json:"Id,omitempty"`
	RoomId  int32  `protobuf:"varint,3,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
}

func (m *G2MAllocRobot) Reset()      { *m = G2MAllocRobot{} }
func (*G2MAllocRobot) ProtoMessage() {}
func (*G2MAllocRobot) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{25}
}
func (m *G2MAllocRobot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2MAllocRobot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2MAllocRobot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2MAllocRobot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2MAllocRobot.Merge(m, src)
}
func (m *G2MAllocRobot) XXX_Size() int {
	return m.Size()
}
func (m *G2MAllocRobot) XXX_DiscardUnknown() {
	xxx_messageInfo_G2MAllocRobot.DiscardUnknown(m)
}

var xxx_messageInfo_G2MAllocRobot proto.InternalMessageInfo

func (m *G2MAllocRobot) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *G2MAllocRobot) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *G2MAllocRobot) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type G2LAutoBuyRequest struct {
	RoomId int32 `protobuf:"varint,1,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
}

func (m *G2LAutoBuyRequest) Reset()      { *m = G2LAutoBuyRequest{} }
func (*G2LAutoBuyRequest) ProtoMessage() {}
func (*G2LAutoBuyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{26}
}
func (m *G2LAutoBuyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2LAutoBuyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2LAutoBuyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2LAutoBuyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2LAutoBuyRequest.Merge(m, src)
}
func (m *G2LAutoBuyRequest) XXX_Size() int {
	return m.Size()
}
func (m *G2LAutoBuyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_G2LAutoBuyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_G2LAutoBuyRequest proto.InternalMessageInfo

func (m *G2LAutoBuyRequest) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type G2LAutoBuyResponse struct {
	Money   int32 `protobuf:"varint,1,opt,name=Money,proto3" json:"Money,omitempty"`
	Success bool  `protobuf:"varint,2,opt,name=Success,proto3" json:"Success,omitempty"`
}

func (m *G2LAutoBuyResponse) Reset()      { *m = G2LAutoBuyResponse{} }
func (*G2LAutoBuyResponse) ProtoMessage() {}
func (*G2LAutoBuyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d11ed378bb9742ff, []int{27}
}
func (m *G2LAutoBuyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *G2LAutoBuyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_G2LAutoBuyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *G2LAutoBuyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_G2LAutoBuyResponse.Merge(m, src)
}
func (m *G2LAutoBuyResponse) XXX_Size() int {
	return m.Size()
}
func (m *G2LAutoBuyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_G2LAutoBuyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_G2LAutoBuyResponse proto.InternalMessageInfo

func (m *G2LAutoBuyResponse) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *G2LAutoBuyResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func init() {
	proto.RegisterType((*Ping)(nil), "proto.node.Ping")
	proto.RegisterType((*Pong)(nil), "proto.node.Pong")
	proto.RegisterType((*PID)(nil), "proto.node.PID")
	proto.RegisterType((*Player)(nil), "proto.node.Player")
	proto.RegisterType((*L2MRequest)(nil), "proto.node.L2MRequest")
	proto.RegisterType((*L2MResponse)(nil), "proto.node.L2MResponse")
	proto.RegisterType((*M2GCreateRequest)(nil), "proto.node.M2GCreateRequest")
	proto.RegisterType((*M2GCreateResponse)(nil), "proto.node.M2GCreateResponse")
	proto.RegisterType((*M2GEnterRequest)(nil), "proto.node.M2GEnterRequest")
	proto.RegisterType((*M2GEnterResponse)(nil), "proto.node.M2GEnterResponse")
	proto.RegisterType((*L2GEnterRequest)(nil), "proto.node.L2GEnterRequest")
	proto.RegisterType((*L2GEnterResponse)(nil), "proto.node.L2GEnterResponse")
	proto.RegisterType((*L2GLeaveRequest)(nil), "proto.node.L2GLeaveRequest")
	proto.RegisterType((*L2GLeaveResponse)(nil), "proto.node.L2GLeaveResponse")
	proto.RegisterType((*L2GPlayerMessage)(nil), "proto.node.L2GPlayerMessage")
	proto.RegisterType((*G2LGameMessage)(nil), "proto.node.G2LGameMessage")
	proto.RegisterType((*G2MPlayerEnter)(nil), "proto.node.G2MPlayerEnter")
	proto.RegisterType((*G2MPlayerLeave)(nil), "proto.node.G2MPlayerLeave")
	proto.RegisterType((*G2MPlayerChanged)(nil), "proto.node.G2MPlayerChanged")
	proto.RegisterType((*G2LKickPlayer)(nil), "proto.node.G2LKickPlayer")
	proto.RegisterType((*G2LCostRequest)(nil), "proto.node.G2LCostRequest")
	proto.RegisterType((*G2LCostResponse)(nil), "proto.node.G2LCostResponse")
	proto.RegisterType((*L2MCountsRequest)(nil), "proto.node.L2MCountsRequest")
	proto.RegisterType((*L2MCountsResponse)(nil), "proto.node.L2MCountsResponse")
	proto.RegisterType((*L2GPlayerDisconnected)(nil), "proto.node.L2GPlayerDisconnected")
	proto.RegisterType((*G2MAllocRobot)(nil), "proto.node.G2MAllocRobot")
	proto.RegisterType((*G2LAutoBuyRequest)(nil), "proto.node.G2LAutoBuyRequest")
	proto.RegisterType((*G2LAutoBuyResponse)(nil), "proto.node.G2LAutoBuyResponse")
}

func init() { proto.RegisterFile("proto_node/node.proto", fileDescriptor_d11ed378bb9742ff) }

var fileDescriptor_d11ed378bb9742ff = []byte{
	// 823 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x55, 0x3f, 0x53, 0xe3, 0x46,
	0x14, 0xf7, 0x4a, 0xb6, 0x31, 0x8f, 0x04, 0x9b, 0x1d, 0x48, 0x14, 0x86, 0xd1, 0x90, 0x2d, 0x12,
	0x12, 0x26, 0xf6, 0x8c, 0x93, 0x49, 0x97, 0xc2, 0xd8, 0xc4, 0x68, 0x22, 0x11, 0x67, 0x53, 0x24,
	0x5d, 0x22, 0xa4, 0xc5, 0x30, 0xb1, 0xb5, 0xc4, 0x92, 0x08, 0xee, 0x32, 0x29, 0x52, 0xdf, 0x87,
	0xb8, 0xe2, 0xbe, 0xc5, 0xb5, 0x57, 0x52, 0x52, 0x1e, 0xa6, 0xb9, 0x92, 0x8f, 0x70, 0xb3, 0xab,
	0x95, 0x2c, 0x1b, 0xcc, 0x71, 0x37, 0x37, 0x73, 0x8d, 0xad, 0xdf, 0xdb, 0xf7, 0xe7, 0xf7, 0x7e,
	0x7a, 0xfb, 0x04, 0x1b, 0x67, 0x23, 0x1e, 0xf1, 0x3f, 0x02, 0xee, 0xb3, 0x86, 0xf8, 0xa9, 0x4b,
	0x8c, 0x41, 0xfe, 0xd5, 0x85, 0x65, 0xf3, 0xb3, 0x3e, 0xe7, 0xfd, 0x01, 0x6b, 0x48, 0xd3, 0x51,
	0x7c, 0xdc, 0x70, 0x83, 0x71, 0xe2, 0x46, 0x7e, 0x84, 0x62, 0xef, 0x34, 0xe8, 0xe3, 0x75, 0x28,
	0x59, 0x81, 0xcf, 0x2e, 0x0c, 0xb4, 0x8d, 0x76, 0x4a, 0x34, 0x01, 0xd8, 0x80, 0xa5, 0x96, 0xef,
	0x8f, 0x58, 0x18, 0x1a, 0xda, 0x36, 0xda, 0x59, 0xa6, 0x29, 0xc4, 0xab, 0xa0, 0x59, 0xbe, 0xa1,
	0x4b, 0xa3, 0x66, 0xf9, 0x64, 0x0b, 0x8a, 0x3d, 0xbe, 0x28, 0x0f, 0x69, 0x80, 0xde, 0xb3, 0x3a,
	0xf9, 0x74, 0xe8, 0xbe, 0x74, 0x5a, 0x96, 0xee, 0x7f, 0x04, 0xe5, 0xde, 0xc0, 0x1d, 0xb3, 0x91,
	0x08, 0xb2, 0x42, 0xca, 0x8f, 0x78, 0x24, 0x83, 0x2a, 0x34, 0x85, 0xb9, 0x20, 0x5d, 0x04, 0x61,
	0x0c, 0xc5, 0x43, 0x77, 0xc8, 0x14, 0x2b, 0xf9, 0x2c, 0xf8, 0xd8, 0xec, 0x9c, 0x0d, 0x8c, 0x62,
	0xc2, 0x47, 0x02, 0x61, 0x75, 0x78, 0xc0, 0xc6, 0x46, 0x29, 0xb1, 0x4a, 0x20, 0xe2, 0x0f, 0x98,
	0xeb, 0x1b, 0xe5, 0x24, 0x5e, 0x3c, 0x93, 0xa7, 0x08, 0xc0, 0x6e, 0x3a, 0x94, 0xfd, 0x1d, 0xb3,
	0x30, 0xc2, 0x35, 0xd0, 0x0f, 0xd9, 0x3f, 0x8a, 0x88, 0x78, 0xc4, 0x5f, 0xa7, 0x44, 0x25, 0x91,
	0x95, 0x26, 0xae, 0x4f, 0x85, 0xaf, 0x27, 0x27, 0x34, 0x6d, 0xe5, 0x13, 0x28, 0x53, 0xce, 0x87,
	0x4a, 0xb8, 0x12, 0x55, 0x08, 0x13, 0xf8, 0xe8, 0x30, 0x1e, 0xfe, 0x7c, 0x9c, 0xb8, 0x85, 0x8a,
	0xeb, 0x8c, 0x0d, 0x6f, 0xc1, 0xf2, 0xfe, 0x85, 0x37, 0x88, 0x7d, 0x66, 0xf9, 0x92, 0xb6, 0x4e,
	0xa7, 0x06, 0x42, 0x61, 0x45, 0xb2, 0x0c, 0xcf, 0x78, 0x10, 0x32, 0xa1, 0xd9, 0xaf, 0xb1, 0xe7,
	0xa5, 0x42, 0x57, 0x68, 0x0a, 0xf1, 0x57, 0xb0, 0x24, 0x8a, 0xf6, 0xac, 0x8e, 0xe2, 0x5b, 0x9d,
	0xe1, 0x6b, 0x75, 0x68, 0x7a, 0x4e, 0x9e, 0x23, 0xa8, 0x39, 0xcd, 0x6e, 0x7b, 0xc4, 0xdc, 0x88,
	0xa5, 0x02, 0x4c, 0xdb, 0x45, 0x8f, 0x69, 0xb7, 0xeb, 0x0e, 0x59, 0xf6, 0x8e, 0x14, 0x5a, 0x28,
	0xc3, 0x2e, 0x54, 0x1c, 0x37, 0xf2, 0x4e, 0x04, 0xb9, 0xe2, 0xfd, 0xe4, 0x32, 0x87, 0x3b, 0x9a,
	0x95, 0xee, 0x6a, 0x46, 0x7e, 0x87, 0xb5, 0x5c, 0x03, 0xef, 0x53, 0x9b, 0x6f, 0xa0, 0xea, 0x34,
	0xbb, 0xfb, 0x41, 0xc4, 0x46, 0xa9, 0x32, 0x9b, 0x50, 0x49, 0xea, 0x5a, 0xbe, 0x4c, 0xac, 0xd3,
	0x0c, 0x13, 0x2c, 0x95, 0x54, 0xee, 0x09, 0x0f, 0xf2, 0x27, 0x54, 0xed, 0xb9, 0x14, 0x6f, 0x23,
	0xee, 0xe7, 0xf2, 0x4a, 0x2d, 0x22, 0x2a, 0xce, 0x48, 0x07, 0x6a, 0xf6, 0x5c, 0xd5, 0x07, 0xba,
	0x5f, 0xf0, 0xb6, 0xc8, 0x0f, 0x92, 0xa7, 0xcd, 0xdc, 0xf3, 0x77, 0x19, 0x02, 0xd1, 0xfa, 0x34,
	0x5c, 0xb5, 0x7e, 0x2c, 0x6d, 0x89, 0x83, 0xc3, 0xc2, 0xd0, 0xed, 0xb3, 0x87, 0xe4, 0xc3, 0xdf,
	0xc3, 0x0a, 0x65, 0xee, 0x40, 0xb9, 0xaa, 0x9e, 0xd7, 0xeb, 0xc9, 0x56, 0xab, 0xa7, 0x5b, 0xad,
	0xde, 0x0a, 0xc6, 0x34, 0xef, 0x48, 0x0e, 0x60, 0xb5, 0xdb, 0xb4, 0x45, 0x1f, 0x69, 0x95, 0xb9,
	0x4c, 0xe8, 0xb1, 0x99, 0xfe, 0x43, 0x22, 0x95, 0x93, 0x30, 0x92, 0x8a, 0xe6, 0xf4, 0x42, 0x33,
	0xd3, 0x9d, 0x6f, 0x44, 0x9b, 0x6b, 0x64, 0x0b, 0x96, 0xb3, 0x01, 0x55, 0xc3, 0x3f, 0x35, 0x60,
	0x13, 0x40, 0x82, 0xdf, 0xc4, 0x8c, 0xab, 0x25, 0x90, 0xb3, 0xcc, 0x92, 0x90, 0x8a, 0x7e, 0x00,
	0x12, 0x27, 0x50, 0xcb, 0x38, 0xb4, 0x4f, 0xdc, 0xa0, 0xcf, 0xfc, 0x85, 0x2c, 0x66, 0x2a, 0x69,
	0x0f, 0x57, 0xd2, 0xef, 0x54, 0xfa, 0x12, 0x3e, 0xee, 0x36, 0xed, 0x9f, 0x4e, 0xbd, 0xbf, 0x72,
	0xeb, 0x93, 0xb9, 0x21, 0x0f, 0xd4, 0xc7, 0x45, 0x21, 0xf2, 0x85, 0x7c, 0xcd, 0x6d, 0x1e, 0x46,
	0xe9, 0x80, 0x66, 0xfb, 0x1d, 0xe5, 0xf6, 0x3b, 0x69, 0x41, 0x35, 0xf3, 0x7b, 0xe3, 0x75, 0xc8,
	0x52, 0x68, 0xf9, 0x14, 0x72, 0x9a, 0x9d, 0x36, 0x8f, 0x83, 0x28, 0x54, 0xc5, 0xc8, 0x3e, 0xac,
	0xe5, 0x6c, 0xd3, 0xc4, 0xc9, 0x56, 0x13, 0x89, 0xf5, 0x9d, 0x12, 0x4d, 0xa1, 0xe8, 0x22, 0xf1,
	0x35, 0x34, 0x79, 0xa0, 0x10, 0xf9, 0x14, 0x36, 0xb2, 0x4b, 0xd1, 0x39, 0x0d, 0x3d, 0x1e, 0x04,
	0xcc, 0x8b, 0x98, 0x4f, 0x7e, 0x11, 0x3a, 0x38, 0xad, 0xc1, 0x80, 0x7b, 0xc9, 0x77, 0xef, 0xd1,
	0x9f, 0xd1, 0x45, 0x9b, 0x96, 0xec, 0xc2, 0x5a, 0xb7, 0x69, 0xb7, 0xe2, 0x88, 0xef, 0xc5, 0xe3,
	0x54, 0xb4, 0xa9, 0x33, 0x9a, 0x71, 0xee, 0x00, 0xce, 0x3b, 0xab, 0x06, 0xef, 0x95, 0x38, 0xaf,
	0xa7, 0x36, 0xa3, 0xe7, 0xde, 0x77, 0x97, 0xd7, 0x66, 0xe1, 0xea, 0xda, 0x2c, 0xdc, 0x5e, 0x9b,
	0xe8, 0xdf, 0x89, 0x89, 0x9e, 0x4d, 0x4c, 0xf4, 0x62, 0x62, 0xa2, 0xcb, 0x89, 0x89, 0x5e, 0x4e,
	0x4c, 0xf4, 0x6a, 0x62, 0x16, 0x6e, 0x27, 0x26, 0x7a, 0x72, 0x63, 0x16, 0x2e, 0x6f, 0xcc, 0xc2,
	0xd5, 0x8d, 0x59, 0x38, 0x2a, 0xcb, 0x2b, 0xf9, 0xed, 0xeb, 0x00, 0x00, 0x00, 0xff, 0xff, 0x57,
	0xa7, 0x07, 0x6d, 0xe5, 0x08, 0x00, 0x00,
}

func (this *Ping) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Ping)
	if !ok {
		that2, ok := that.(Ping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *Pong) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Pong)
	if !ok {
		that2, ok := that.(Pong)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	return true
}
func (this *PID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PID)
	if !ok {
		that2, ok := that.(PID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *Player) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Player)
	if !ok {
		that2, ok := that.(Player)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsRobot != that1.IsRobot {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Money != that1.Money {
		return false
	}
	if this.Head != that1.Head {
		return false
	}
	return true
}
func (this *L2MRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2MRequest)
	if !ok {
		that2, ok := that.(L2MRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.New != that1.New {
		return false
	}
	if !this.Player.Equal(that1.Player) {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	if this.NumOfPlayers != that1.NumOfPlayers {
		return false
	}
	if this.ExcludeId != that1.ExcludeId {
		return false
	}
	return true
}
func (this *L2MResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2MResponse)
	if !ok {
		that2, ok := that.(L2MResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if !this.RoomPID.Equal(that1.RoomPID) {
		return false
	}
	return true
}
func (this *M2GCreateRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*M2GCreateRequest)
	if !ok {
		that2, ok := that.(M2GCreateRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Player.Equal(that1.Player) {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	if !this.MatchPID.Equal(that1.MatchPID) {
		return false
	}
	if this.NumOfPlayers != that1.NumOfPlayers {
		return false
	}
	return true
}
func (this *M2GCreateResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*M2GCreateResponse)
	if !ok {
		that2, ok := that.(M2GCreateResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if !this.RoomPID.Equal(that1.RoomPID) {
		return false
	}
	return true
}
func (this *M2GEnterRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*M2GEnterRequest)
	if !ok {
		that2, ok := that.(M2GEnterRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PlayerId != that1.PlayerId {
		return false
	}
	return true
}
func (this *M2GEnterResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*M2GEnterResponse)
	if !ok {
		that2, ok := that.(M2GEnterResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *L2GEnterRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2GEnterRequest)
	if !ok {
		that2, ok := that.(L2GEnterRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Player.Equal(that1.Player) {
		return false
	}
	if !this.PID.Equal(that1.PID) {
		return false
	}
	return true
}
func (this *L2GEnterResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2GEnterResponse)
	if !ok {
		that2, ok := that.(L2GEnterResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	return true
}
func (this *L2GLeaveRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2GLeaveRequest)
	if !ok {
		that2, ok := that.(L2GLeaveRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Player.Equal(that1.Player) {
		return false
	}
	return true
}
func (this *L2GLeaveResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2GLeaveResponse)
	if !ok {
		that2, ok := that.(L2GLeaveResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *L2GPlayerMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2GPlayerMessage)
	if !ok {
		that2, ok := that.(L2GPlayerMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PlayerId != that1.PlayerId {
		return false
	}
	if !this.RealMessage.Equal(that1.RealMessage) {
		return false
	}
	return true
}
func (this *G2LGameMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2LGameMessage)
	if !ok {
		that2, ok := that.(G2LGameMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RealMessage.Equal(that1.RealMessage) {
		return false
	}
	return true
}
func (this *G2MPlayerEnter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2MPlayerEnter)
	if !ok {
		that2, ok := that.(G2MPlayerEnter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	if this.PlayerId != that1.PlayerId {
		return false
	}
	if this.NumOfPlay != that1.NumOfPlay {
		return false
	}
	if this.NumOfWatch != that1.NumOfWatch {
		return false
	}
	return true
}
func (this *G2MPlayerLeave) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2MPlayerLeave)
	if !ok {
		that2, ok := that.(G2MPlayerLeave)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	if this.PlayerId != that1.PlayerId {
		return false
	}
	if this.NumOfPlay != that1.NumOfPlay {
		return false
	}
	if this.NumOfWatch != that1.NumOfWatch {
		return false
	}
	return true
}
func (this *G2MPlayerChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2MPlayerChanged)
	if !ok {
		that2, ok := that.(G2MPlayerChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	if this.NumOfPlay != that1.NumOfPlay {
		return false
	}
	if this.NumOfWatch != that1.NumOfWatch {
		return false
	}
	return true
}
func (this *G2LKickPlayer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2LKickPlayer)
	if !ok {
		that2, ok := that.(G2LKickPlayer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *G2LCostRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2LCostRequest)
	if !ok {
		that2, ok := that.(G2LCostRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Money != that1.Money {
		return false
	}
	return true
}
func (this *G2LCostResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2LCostResponse)
	if !ok {
		that2, ok := that.(G2LCostResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if this.Money != that1.Money {
		return false
	}
	return true
}
func (this *L2MCountsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2MCountsRequest)
	if !ok {
		that2, ok := that.(L2MCountsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *L2MCountsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2MCountsResponse)
	if !ok {
		that2, ok := that.(L2MCountsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RoomIds) != len(that1.RoomIds) {
		return false
	}
	for i := range this.RoomIds {
		if this.RoomIds[i] != that1.RoomIds[i] {
			return false
		}
	}
	if len(this.Counts) != len(that1.Counts) {
		return false
	}
	for i := range this.Counts {
		if this.Counts[i] != that1.Counts[i] {
			return false
		}
	}
	return true
}
func (this *L2GPlayerDisconnected) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L2GPlayerDisconnected)
	if !ok {
		that2, ok := that.(L2GPlayerDisconnected)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *G2MAllocRobot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2MAllocRobot)
	if !ok {
		that2, ok := that.(G2MAllocRobot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	return true
}
func (this *G2LAutoBuyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2LAutoBuyRequest)
	if !ok {
		that2, ok := that.(G2LAutoBuyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	return true
}
func (this *G2LAutoBuyResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*G2LAutoBuyResponse)
	if !ok {
		that2, ok := that.(G2LAutoBuyResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Money != that1.Money {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *Ping) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto_node.Ping{")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Pong) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_node.Pong{")
	s = append(s, "Index: "+fmt.Sprintf("%#v", this.Index)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_node.PID{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Player) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proto_node.Player{")
	s = append(s, "IsRobot: "+fmt.Sprintf("%#v", this.IsRobot)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Money: "+fmt.Sprintf("%#v", this.Money)+",\n")
	s = append(s, "Head: "+fmt.Sprintf("%#v", this.Head)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2MRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto_node.L2MRequest{")
	s = append(s, "New: "+fmt.Sprintf("%#v", this.New)+",\n")
	if this.Player != nil {
		s = append(s, "Player: "+fmt.Sprintf("%#v", this.Player)+",\n")
	}
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	s = append(s, "NumOfPlayers: "+fmt.Sprintf("%#v", this.NumOfPlayers)+",\n")
	s = append(s, "ExcludeId: "+fmt.Sprintf("%#v", this.ExcludeId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2MResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_node.L2MResponse{")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	if this.RoomPID != nil {
		s = append(s, "RoomPID: "+fmt.Sprintf("%#v", this.RoomPID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *M2GCreateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto_node.M2GCreateRequest{")
	if this.Player != nil {
		s = append(s, "Player: "+fmt.Sprintf("%#v", this.Player)+",\n")
	}
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	if this.MatchPID != nil {
		s = append(s, "MatchPID: "+fmt.Sprintf("%#v", this.MatchPID)+",\n")
	}
	s = append(s, "NumOfPlayers: "+fmt.Sprintf("%#v", this.NumOfPlayers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *M2GCreateResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_node.M2GCreateResponse{")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	if this.RoomPID != nil {
		s = append(s, "RoomPID: "+fmt.Sprintf("%#v", this.RoomPID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *M2GEnterRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_node.M2GEnterRequest{")
	s = append(s, "PlayerId: "+fmt.Sprintf("%#v", this.PlayerId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *M2GEnterResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_node.M2GEnterResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2GEnterRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_node.L2GEnterRequest{")
	if this.Player != nil {
		s = append(s, "Player: "+fmt.Sprintf("%#v", this.Player)+",\n")
	}
	if this.PID != nil {
		s = append(s, "PID: "+fmt.Sprintf("%#v", this.PID)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2GEnterResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_node.L2GEnterResponse{")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2GLeaveRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_node.L2GLeaveRequest{")
	if this.Player != nil {
		s = append(s, "Player: "+fmt.Sprintf("%#v", this.Player)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2GLeaveResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_node.L2GLeaveResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2GPlayerMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_node.L2GPlayerMessage{")
	s = append(s, "PlayerId: "+fmt.Sprintf("%#v", this.PlayerId)+",\n")
	if this.RealMessage != nil {
		s = append(s, "RealMessage: "+fmt.Sprintf("%#v", this.RealMessage)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2LGameMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_node.G2LGameMessage{")
	if this.RealMessage != nil {
		s = append(s, "RealMessage: "+fmt.Sprintf("%#v", this.RealMessage)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2MPlayerEnter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto_node.G2MPlayerEnter{")
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "PlayerId: "+fmt.Sprintf("%#v", this.PlayerId)+",\n")
	s = append(s, "NumOfPlay: "+fmt.Sprintf("%#v", this.NumOfPlay)+",\n")
	s = append(s, "NumOfWatch: "+fmt.Sprintf("%#v", this.NumOfWatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2MPlayerLeave) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto_node.G2MPlayerLeave{")
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "PlayerId: "+fmt.Sprintf("%#v", this.PlayerId)+",\n")
	s = append(s, "NumOfPlay: "+fmt.Sprintf("%#v", this.NumOfPlay)+",\n")
	s = append(s, "NumOfWatch: "+fmt.Sprintf("%#v", this.NumOfWatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2MPlayerChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto_node.G2MPlayerChanged{")
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "NumOfPlay: "+fmt.Sprintf("%#v", this.NumOfPlay)+",\n")
	s = append(s, "NumOfWatch: "+fmt.Sprintf("%#v", this.NumOfWatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2LKickPlayer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_node.G2LKickPlayer{")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2LCostRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_node.G2LCostRequest{")
	s = append(s, "Money: "+fmt.Sprintf("%#v", this.Money)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2LCostResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_node.G2LCostResponse{")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	s = append(s, "Money: "+fmt.Sprintf("%#v", this.Money)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2MCountsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_node.L2MCountsRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2MCountsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_node.L2MCountsResponse{")
	s = append(s, "RoomIds: "+fmt.Sprintf("%#v", this.RoomIds)+",\n")
	s = append(s, "Counts: "+fmt.Sprintf("%#v", this.Counts)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *L2GPlayerDisconnected) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_node.L2GPlayerDisconnected{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2MAllocRobot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto_node.G2MAllocRobot{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2LAutoBuyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_node.G2LAutoBuyRequest{")
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *G2LAutoBuyResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_node.G2LAutoBuyResponse{")
	s = append(s, "Money: "+fmt.Sprintf("%#v", this.Money)+",\n")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringNode(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Ping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Player) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x32
	}
	if m.Money != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x28
	}
	if m.Level != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.IsRobot {
		i--
		if m.IsRobot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L2MRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2MRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2MRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExcludeId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.ExcludeId))
		i--
		dAtA[i] = 0x28
	}
	if m.NumOfPlayers != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NumOfPlayers))
		i--
		dAtA[i] = 0x20
	}
	if m.RoomId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x18
	}
	if m.Player != nil {
		{
			size, err := m.Player.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.New {
		i--
		if m.New {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L2MResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2MResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2MResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoomPID != nil {
		{
			size, err := m.RoomPID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *M2GCreateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *M2GCreateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *M2GCreateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumOfPlayers != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NumOfPlayers))
		i--
		dAtA[i] = 0x28
	}
	if m.MatchPID != nil {
		{
			size, err := m.MatchPID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RoomId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x18
	}
	if m.GameId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.Player != nil {
		{
			size, err := m.Player.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *M2GCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *M2GCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *M2GCreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoomPID != nil {
		{
			size, err := m.RoomPID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *M2GEnterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *M2GEnterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *M2GEnterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlayerId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *M2GEnterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *M2GEnterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *M2GEnterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *L2GEnterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2GEnterRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2GEnterRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PID != nil {
		{
			size, err := m.PID.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Player != nil {
		{
			size, err := m.Player.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L2GEnterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2GEnterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2GEnterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GameId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L2GLeaveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2GLeaveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2GLeaveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Player != nil {
		{
			size, err := m.Player.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L2GLeaveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2GLeaveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2GLeaveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *L2GPlayerMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2GPlayerMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2GPlayerMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RealMessage != nil {
		{
			size, err := m.RealMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PlayerId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *G2LGameMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2LGameMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2LGameMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RealMessage != nil {
		{
			size, err := m.RealMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *G2MPlayerEnter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2MPlayerEnter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2MPlayerEnter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumOfWatch != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NumOfWatch))
		i--
		dAtA[i] = 0x20
	}
	if m.NumOfPlay != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NumOfPlay))
		i--
		dAtA[i] = 0x18
	}
	if m.PlayerId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *G2MPlayerLeave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2MPlayerLeave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2MPlayerLeave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumOfWatch != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NumOfWatch))
		i--
		dAtA[i] = 0x20
	}
	if m.NumOfPlay != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NumOfPlay))
		i--
		dAtA[i] = 0x18
	}
	if m.PlayerId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x10
	}
	if m.GameId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *G2MPlayerChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2MPlayerChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2MPlayerChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumOfWatch != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NumOfWatch))
		i--
		dAtA[i] = 0x18
	}
	if m.NumOfPlay != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.NumOfPlay))
		i--
		dAtA[i] = 0x10
	}
	if m.GameId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *G2LKickPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2LKickPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2LKickPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *G2LCostRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2LCostRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2LCostRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Money != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *G2LCostResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2LCostResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2LCostResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Money != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L2MCountsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2MCountsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2MCountsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *L2MCountsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2MCountsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2MCountsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Counts) > 0 {
		dAtA12 := make([]byte, len(m.Counts)*10)
		var j11 int
		for _, num1 := range m.Counts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintNode(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RoomIds) > 0 {
		dAtA14 := make([]byte, len(m.RoomIds)*10)
		var j13 int
		for _, num1 := range m.RoomIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintNode(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L2GPlayerDisconnected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2GPlayerDisconnected) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2GPlayerDisconnected) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *G2MAllocRobot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2MAllocRobot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2MAllocRobot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *G2LAutoBuyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2LAutoBuyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2LAutoBuyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *G2LAutoBuyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *G2LAutoBuyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *G2LAutoBuyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Money != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNode(dAtA []byte, offset int, v uint64) int {
	offset -= sovNode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Ping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovNode(uint64(m.Index))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *Pong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovNode(uint64(m.Index))
	}
	return n
}

func (m *PID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsRobot {
		n += 2
	}
	if m.Id != 0 {
		n += 1 + sovNode(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovNode(uint64(m.Level))
	}
	if m.Money != 0 {
		n += 1 + sovNode(uint64(m.Money))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *L2MRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.New {
		n += 2
	}
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.RoomId != 0 {
		n += 1 + sovNode(uint64(m.RoomId))
	}
	if m.NumOfPlayers != 0 {
		n += 1 + sovNode(uint64(m.NumOfPlayers))
	}
	if m.ExcludeId != 0 {
		n += 1 + sovNode(uint64(m.ExcludeId))
	}
	return n
}

func (m *L2MResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.RoomPID != nil {
		l = m.RoomPID.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *M2GCreateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.GameId != 0 {
		n += 1 + sovNode(uint64(m.GameId))
	}
	if m.RoomId != 0 {
		n += 1 + sovNode(uint64(m.RoomId))
	}
	if m.MatchPID != nil {
		l = m.MatchPID.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.NumOfPlayers != 0 {
		n += 1 + sovNode(uint64(m.NumOfPlayers))
	}
	return n
}

func (m *M2GCreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.RoomPID != nil {
		l = m.RoomPID.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *M2GEnterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovNode(uint64(m.PlayerId))
	}
	return n
}

func (m *M2GEnterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *L2GEnterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.PID != nil {
		l = m.PID.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *L2GEnterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.GameId != 0 {
		n += 1 + sovNode(uint64(m.GameId))
	}
	return n
}

func (m *L2GLeaveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *L2GLeaveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *L2GPlayerMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerId != 0 {
		n += 1 + sovNode(uint64(m.PlayerId))
	}
	if m.RealMessage != nil {
		l = m.RealMessage.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *G2LGameMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RealMessage != nil {
		l = m.RealMessage.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *G2MPlayerEnter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovNode(uint64(m.GameId))
	}
	if m.PlayerId != 0 {
		n += 1 + sovNode(uint64(m.PlayerId))
	}
	if m.NumOfPlay != 0 {
		n += 1 + sovNode(uint64(m.NumOfPlay))
	}
	if m.NumOfWatch != 0 {
		n += 1 + sovNode(uint64(m.NumOfWatch))
	}
	return n
}

func (m *G2MPlayerLeave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovNode(uint64(m.GameId))
	}
	if m.PlayerId != 0 {
		n += 1 + sovNode(uint64(m.PlayerId))
	}
	if m.NumOfPlay != 0 {
		n += 1 + sovNode(uint64(m.NumOfPlay))
	}
	if m.NumOfWatch != 0 {
		n += 1 + sovNode(uint64(m.NumOfWatch))
	}
	return n
}

func (m *G2MPlayerChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameId != 0 {
		n += 1 + sovNode(uint64(m.GameId))
	}
	if m.NumOfPlay != 0 {
		n += 1 + sovNode(uint64(m.NumOfPlay))
	}
	if m.NumOfWatch != 0 {
		n += 1 + sovNode(uint64(m.NumOfWatch))
	}
	return n
}

func (m *G2LKickPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reason != 0 {
		n += 1 + sovNode(uint64(m.Reason))
	}
	return n
}

func (m *G2LCostRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Money != 0 {
		n += 1 + sovNode(uint64(m.Money))
	}
	return n
}

func (m *G2LCostResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.Money != 0 {
		n += 1 + sovNode(uint64(m.Money))
	}
	return n
}

func (m *L2MCountsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *L2MCountsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		l = 0
		for _, e := range m.RoomIds {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if len(m.Counts) > 0 {
		l = 0
		for _, e := range m.Counts {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	return n
}

func (m *L2GPlayerDisconnected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *G2MAllocRobot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.RoomId != 0 {
		n += 1 + sovNode(uint64(m.RoomId))
	}
	return n
}

func (m *G2LAutoBuyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNode(uint64(m.RoomId))
	}
	return n
}

func (m *G2LAutoBuyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Money != 0 {
		n += 1 + sovNode(uint64(m.Money))
	}
	if m.Success {
		n += 2
	}
	return n
}

func sovNode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNode(x uint64) (n int) {
	return sovNode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Ping) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Ping{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Pong) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Pong{`,
		`Index:` + fmt.Sprintf("%v", this.Index) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PID{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Player) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Player{`,
		`IsRobot:` + fmt.Sprintf("%v", this.IsRobot) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`Head:` + fmt.Sprintf("%v", this.Head) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L2MRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2MRequest{`,
		`New:` + fmt.Sprintf("%v", this.New) + `,`,
		`Player:` + strings.Replace(this.Player.String(), "Player", "Player", 1) + `,`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`NumOfPlayers:` + fmt.Sprintf("%v", this.NumOfPlayers) + `,`,
		`ExcludeId:` + fmt.Sprintf("%v", this.ExcludeId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L2MResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2MResponse{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`RoomPID:` + strings.Replace(this.RoomPID.String(), "PID", "PID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *M2GCreateRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&M2GCreateRequest{`,
		`Player:` + strings.Replace(this.Player.String(), "Player", "Player", 1) + `,`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`MatchPID:` + strings.Replace(this.MatchPID.String(), "PID", "PID", 1) + `,`,
		`NumOfPlayers:` + fmt.Sprintf("%v", this.NumOfPlayers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *M2GCreateResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&M2GCreateResponse{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`RoomPID:` + strings.Replace(this.RoomPID.String(), "PID", "PID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *M2GEnterRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&M2GEnterRequest{`,
		`PlayerId:` + fmt.Sprintf("%v", this.PlayerId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *M2GEnterResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&M2GEnterResponse{`,
		`}`,
	}, "")
	return s
}
func (this *L2GEnterRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2GEnterRequest{`,
		`Player:` + strings.Replace(this.Player.String(), "Player", "Player", 1) + `,`,
		`PID:` + strings.Replace(this.PID.String(), "PID", "PID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L2GEnterResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2GEnterResponse{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L2GLeaveRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2GLeaveRequest{`,
		`Player:` + strings.Replace(this.Player.String(), "Player", "Player", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L2GLeaveResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2GLeaveResponse{`,
		`}`,
	}, "")
	return s
}
func (this *L2GPlayerMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2GPlayerMessage{`,
		`PlayerId:` + fmt.Sprintf("%v", this.PlayerId) + `,`,
		`RealMessage:` + strings.Replace(fmt.Sprintf("%v", this.RealMessage), "Any", "types.Any", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *G2LGameMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2LGameMessage{`,
		`RealMessage:` + strings.Replace(fmt.Sprintf("%v", this.RealMessage), "Any", "types.Any", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *G2MPlayerEnter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2MPlayerEnter{`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`PlayerId:` + fmt.Sprintf("%v", this.PlayerId) + `,`,
		`NumOfPlay:` + fmt.Sprintf("%v", this.NumOfPlay) + `,`,
		`NumOfWatch:` + fmt.Sprintf("%v", this.NumOfWatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *G2MPlayerLeave) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2MPlayerLeave{`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`PlayerId:` + fmt.Sprintf("%v", this.PlayerId) + `,`,
		`NumOfPlay:` + fmt.Sprintf("%v", this.NumOfPlay) + `,`,
		`NumOfWatch:` + fmt.Sprintf("%v", this.NumOfWatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *G2MPlayerChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2MPlayerChanged{`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`NumOfPlay:` + fmt.Sprintf("%v", this.NumOfPlay) + `,`,
		`NumOfWatch:` + fmt.Sprintf("%v", this.NumOfWatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *G2LKickPlayer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2LKickPlayer{`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *G2LCostRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2LCostRequest{`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`}`,
	}, "")
	return s
}
func (this *G2LCostResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2LCostResponse{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L2MCountsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2MCountsRequest{`,
		`}`,
	}, "")
	return s
}
func (this *L2MCountsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2MCountsResponse{`,
		`RoomIds:` + fmt.Sprintf("%v", this.RoomIds) + `,`,
		`Counts:` + fmt.Sprintf("%v", this.Counts) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L2GPlayerDisconnected) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L2GPlayerDisconnected{`,
		`}`,
	}, "")
	return s
}
func (this *G2MAllocRobot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2MAllocRobot{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *G2LAutoBuyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2LAutoBuyRequest{`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *G2LAutoBuyResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&G2LAutoBuyResponse{`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringNode(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Ping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRobot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRobot = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2MRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2MRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2MRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.New = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPlayers", wireType)
			}
			m.NumOfPlayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPlayers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeId", wireType)
			}
			m.ExcludeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExcludeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2MResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2MResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2MResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomPID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoomPID == nil {
				m.RoomPID = &PID{}
			}
			if err := m.RoomPID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *M2GCreateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: M2GCreateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: M2GCreateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchPID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchPID == nil {
				m.MatchPID = &PID{}
			}
			if err := m.MatchPID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPlayers", wireType)
			}
			m.NumOfPlayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPlayers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *M2GCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: M2GCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: M2GCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomPID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoomPID == nil {
				m.RoomPID = &PID{}
			}
			if err := m.RoomPID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *M2GEnterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: M2GEnterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: M2GEnterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *M2GEnterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: M2GEnterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: M2GEnterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2GEnterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2GEnterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2GEnterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PID == nil {
				m.PID = &PID{}
			}
			if err := m.PID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2GEnterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2GEnterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2GEnterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2GLeaveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2GLeaveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2GLeaveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2GLeaveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2GLeaveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2GLeaveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2GPlayerMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2GPlayerMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2GPlayerMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RealMessage == nil {
				m.RealMessage = &types.Any{}
			}
			if err := m.RealMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2LGameMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2LGameMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2LGameMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RealMessage == nil {
				m.RealMessage = &types.Any{}
			}
			if err := m.RealMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2MPlayerEnter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2MPlayerEnter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2MPlayerEnter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPlay", wireType)
			}
			m.NumOfPlay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPlay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfWatch", wireType)
			}
			m.NumOfWatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfWatch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2MPlayerLeave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2MPlayerLeave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2MPlayerLeave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPlay", wireType)
			}
			m.NumOfPlay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPlay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfWatch", wireType)
			}
			m.NumOfWatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfWatch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2MPlayerChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2MPlayerChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2MPlayerChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPlay", wireType)
			}
			m.NumOfPlay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPlay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfWatch", wireType)
			}
			m.NumOfWatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfWatch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2LKickPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2LKickPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2LKickPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2LCostRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2LCostRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2LCostRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2LCostResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2LCostResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2LCostResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2MCountsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2MCountsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2MCountsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2MCountsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2MCountsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2MCountsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoomIds = append(m.RoomIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoomIds) == 0 {
					m.RoomIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoomIds = append(m.RoomIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomIds", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Counts = append(m.Counts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Counts) == 0 {
					m.Counts = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Counts = append(m.Counts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Counts", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2GPlayerDisconnected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2GPlayerDisconnected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2GPlayerDisconnected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2MAllocRobot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2MAllocRobot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2MAllocRobot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2LAutoBuyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2LAutoBuyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2LAutoBuyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *G2LAutoBuyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: G2LAutoBuyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: G2LAutoBuyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNode = fmt.Errorf("proto: unexpected end of group")
)
