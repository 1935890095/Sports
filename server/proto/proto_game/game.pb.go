// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: game.proto

package proto_game

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type EnterResult int32

const (
	EnterSuccess        EnterResult = 0
	EnterFail           EnterResult = 1
	EnterNotEnoughMoney EnterResult = 2
)

var EnterResult_name = map[int32]string{
	0: "EnterSuccess",
	1: "EnterFail",
	2: "EnterNotEnoughMoney",
}

var EnterResult_value = map[string]int32{
	"EnterSuccess":        0,
	"EnterFail":           1,
	"EnterNotEnoughMoney": 2,
}

func (EnterResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{0}
}

// 玩家操作类型
type Ops int32

const (
	OpsNone        Ops = 0
	OpsFold        Ops = 1
	OpsCheck       Ops = 2
	OpsCall        Ops = 4
	OpsRaise       Ops = 8
	OpsAllIn       Ops = 16
	OpsCheckOrFold Ops = 32
	OpsCallAny     Ops = 64
)

var Ops_name = map[int32]string{
	0:  "OpsNone",
	1:  "OpsFold",
	2:  "OpsCheck",
	4:  "OpsCall",
	8:  "OpsRaise",
	16: "OpsAllIn",
	32: "OpsCheckOrFold",
	64: "OpsCallAny",
}

var Ops_value = map[string]int32{
	"OpsNone":        0,
	"OpsFold":        1,
	"OpsCheck":       2,
	"OpsCall":        4,
	"OpsRaise":       8,
	"OpsAllIn":       16,
	"OpsCheckOrFold": 32,
	"OpsCallAny":     64,
}

func (Ops) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{1}
}

// 玩家状态类型
type States int32

const (
	StatesNone      States = 0
	StatesOperating States = 1
	StatesWait      States = 2
	StatesAllin     States = 3
	StatesFold      States = 4
	StatesWin       States = 5
	StatesWaitGame  States = 6
)

var States_name = map[int32]string{
	0: "StatesNone",
	1: "StatesOperating",
	2: "StatesWait",
	3: "StatesAllin",
	4: "StatesFold",
	5: "StatesWin",
	6: "StatesWaitGame",
}

var States_value = map[string]int32{
	"StatesNone":      0,
	"StatesOperating": 1,
	"StatesWait":      2,
	"StatesAllin":     3,
	"StatesFold":      4,
	"StatesWin":       5,
	"StatesWaitGame":  6,
}

func (States) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{2}
}

// 发牌类型
type DealCardsType int32

const (
	DealCardsTypeHole   DealCardsType = 0
	DealCardsTypePublic DealCardsType = 1
)

var DealCardsType_name = map[int32]string{
	0: "DealCardsTypeHole",
	1: "DealCardsTypePublic",
}

var DealCardsType_value = map[string]int32{
	"DealCardsTypeHole":   0,
	"DealCardsTypePublic": 1,
}

func (DealCardsType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{3}
}

// 牌型
type CardTypes int32

const (
	CardTypesNone          CardTypes = 0
	CardTypesHighCard      CardTypes = 1
	CardTypesOnePair       CardTypes = 2
	CardTypesTwoPair       CardTypes = 3
	CardTypesThreeOfAKind  CardTypes = 4
	CardTypesStraight      CardTypes = 5
	CardTypesFlush         CardTypes = 6
	CardTypesFullHouse     CardTypes = 7
	CardTypesFourOfAKind   CardTypes = 8
	CardTypesStraightFlush CardTypes = 9
	CardTypesRoyalFlush    CardTypes = 10
)

var CardTypes_name = map[int32]string{
	0:  "CardTypesNone",
	1:  "CardTypesHighCard",
	2:  "CardTypesOnePair",
	3:  "CardTypesTwoPair",
	4:  "CardTypesThreeOfAKind",
	5:  "CardTypesStraight",
	6:  "CardTypesFlush",
	7:  "CardTypesFullHouse",
	8:  "CardTypesFourOfAKind",
	9:  "CardTypesStraightFlush",
	10: "CardTypesRoyalFlush",
}

var CardTypes_value = map[string]int32{
	"CardTypesNone":          0,
	"CardTypesHighCard":      1,
	"CardTypesOnePair":       2,
	"CardTypesTwoPair":       3,
	"CardTypesThreeOfAKind":  4,
	"CardTypesStraight":      5,
	"CardTypesFlush":         6,
	"CardTypesFullHouse":     7,
	"CardTypesFourOfAKind":   8,
	"CardTypesStraightFlush": 9,
	"CardTypesRoyalFlush":    10,
}

func (CardTypes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{4}
}

type KickType int32

const (
	Closed KickType = 0
)

var KickType_name = map[int32]string{
	0: "Closed",
}

var KickType_value = map[string]int32{
	"Closed": 0,
}

func (KickType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{5}
}

// 请求切换房间设置
type C2SRoomOptions struct {
	Id         int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	AutoBuy    bool  `protobuf:"varint,2,opt,name=AutoBuy,proto3" json:"AutoBuy,omitempty"`
	AutoBuyMax bool  `protobuf:"varint,3,opt,name=AutoBuyMax,proto3" json:"AutoBuyMax,omitempty"`
	Buy        int32 `protobuf:"varint,4,opt,name=Buy,proto3" json:"Buy,omitempty"`
}

func (m *C2SRoomOptions) Reset()      { *m = C2SRoomOptions{} }
func (*C2SRoomOptions) ProtoMessage() {}
func (*C2SRoomOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{0}
}
func (m *C2SRoomOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SRoomOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SRoomOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SRoomOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SRoomOptions.Merge(m, src)
}
func (m *C2SRoomOptions) XXX_Size() int {
	return m.Size()
}
func (m *C2SRoomOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SRoomOptions.DiscardUnknown(m)
}

var xxx_messageInfo_C2SRoomOptions proto.InternalMessageInfo

func (m *C2SRoomOptions) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *C2SRoomOptions) GetAutoBuy() bool {
	if m != nil {
		return m.AutoBuy
	}
	return false
}

func (m *C2SRoomOptions) GetAutoBuyMax() bool {
	if m != nil {
		return m.AutoBuyMax
	}
	return false
}

func (m *C2SRoomOptions) GetBuy() int32 {
	if m != nil {
		return m.Buy
	}
	return 0
}

// 房间设置结果
type S2CRoomOptions struct {
	Id         int32 `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	AutoBuy    bool  `protobuf:"varint,2,opt,name=AutoBuy,proto3" json:"AutoBuy,omitempty"`
	AutoBuyMax bool  `protobuf:"varint,3,opt,name=AutoBuyMax,proto3" json:"AutoBuyMax,omitempty"`
	Buy        int32 `protobuf:"varint,4,opt,name=Buy,proto3" json:"Buy,omitempty"`
}

func (m *S2CRoomOptions) Reset()      { *m = S2CRoomOptions{} }
func (*S2CRoomOptions) ProtoMessage() {}
func (*S2CRoomOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{1}
}
func (m *S2CRoomOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CRoomOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CRoomOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CRoomOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CRoomOptions.Merge(m, src)
}
func (m *S2CRoomOptions) XXX_Size() int {
	return m.Size()
}
func (m *S2CRoomOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CRoomOptions.DiscardUnknown(m)
}

var xxx_messageInfo_S2CRoomOptions proto.InternalMessageInfo

func (m *S2CRoomOptions) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *S2CRoomOptions) GetAutoBuy() bool {
	if m != nil {
		return m.AutoBuy
	}
	return false
}

func (m *S2CRoomOptions) GetAutoBuyMax() bool {
	if m != nil {
		return m.AutoBuyMax
	}
	return false
}

func (m *S2CRoomOptions) GetBuy() int32 {
	if m != nil {
		return m.Buy
	}
	return 0
}

// 请求进入房间
type C2SEnter struct {
	RoomId       int32 `protobuf:"varint,1,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
	Buy          int32 `protobuf:"varint,2,opt,name=Buy,proto3" json:"Buy,omitempty"`
	NumOfPlayers int32 `protobuf:"varint,3,opt,name=NumOfPlayers,proto3" json:"NumOfPlayers,omitempty"`
}

func (m *C2SEnter) Reset()      { *m = C2SEnter{} }
func (*C2SEnter) ProtoMessage() {}
func (*C2SEnter) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{2}
}
func (m *C2SEnter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SEnter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SEnter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SEnter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SEnter.Merge(m, src)
}
func (m *C2SEnter) XXX_Size() int {
	return m.Size()
}
func (m *C2SEnter) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SEnter.DiscardUnknown(m)
}

var xxx_messageInfo_C2SEnter proto.InternalMessageInfo

func (m *C2SEnter) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *C2SEnter) GetBuy() int32 {
	if m != nil {
		return m.Buy
	}
	return 0
}

func (m *C2SEnter) GetNumOfPlayers() int32 {
	if m != nil {
		return m.NumOfPlayers
	}
	return 0
}

// 弹出买入窗口
type S2CMoneyNotEnough struct {
	RoomId    int32 `protobuf:"varint,1,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
	LeftMoney int32 `protobuf:"varint,2,opt,name=LeftMoney,proto3" json:"LeftMoney,omitempty"`
}

func (m *S2CMoneyNotEnough) Reset()      { *m = S2CMoneyNotEnough{} }
func (*S2CMoneyNotEnough) ProtoMessage() {}
func (*S2CMoneyNotEnough) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{3}
}
func (m *S2CMoneyNotEnough) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CMoneyNotEnough) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CMoneyNotEnough.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CMoneyNotEnough) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CMoneyNotEnough.Merge(m, src)
}
func (m *S2CMoneyNotEnough) XXX_Size() int {
	return m.Size()
}
func (m *S2CMoneyNotEnough) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CMoneyNotEnough.DiscardUnknown(m)
}

var xxx_messageInfo_S2CMoneyNotEnough proto.InternalMessageInfo

func (m *S2CMoneyNotEnough) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2CMoneyNotEnough) GetLeftMoney() int32 {
	if m != nil {
		return m.LeftMoney
	}
	return 0
}

// 房间内买入
type C2SBuy struct {
	Buy     int32 `protobuf:"varint,1,opt,name=Buy,proto3" json:"Buy,omitempty"`
	AutoBuy bool  `protobuf:"varint,2,opt,name=AutoBuy,proto3" json:"AutoBuy,omitempty"`
}

func (m *C2SBuy) Reset()      { *m = C2SBuy{} }
func (*C2SBuy) ProtoMessage() {}
func (*C2SBuy) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{4}
}
func (m *C2SBuy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SBuy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SBuy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SBuy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SBuy.Merge(m, src)
}
func (m *C2SBuy) XXX_Size() int {
	return m.Size()
}
func (m *C2SBuy) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SBuy.DiscardUnknown(m)
}

var xxx_messageInfo_C2SBuy proto.InternalMessageInfo

func (m *C2SBuy) GetBuy() int32 {
	if m != nil {
		return m.Buy
	}
	return 0
}

func (m *C2SBuy) GetAutoBuy() bool {
	if m != nil {
		return m.AutoBuy
	}
	return false
}

type S2CBuy struct {
	Success bool `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
}

func (m *S2CBuy) Reset()      { *m = S2CBuy{} }
func (*S2CBuy) ProtoMessage() {}
func (*S2CBuy) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{5}
}
func (m *S2CBuy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CBuy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CBuy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CBuy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CBuy.Merge(m, src)
}
func (m *S2CBuy) XXX_Size() int {
	return m.Size()
}
func (m *S2CBuy) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CBuy.DiscardUnknown(m)
}

var xxx_messageInfo_S2CBuy proto.InternalMessageInfo

func (m *S2CBuy) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// 自动续费
type S2CAutoBuy struct {
	Idx   int32 `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
	Money int32 `protobuf:"varint,2,opt,name=Money,proto3" json:"Money,omitempty"`
}

func (m *S2CAutoBuy) Reset()      { *m = S2CAutoBuy{} }
func (*S2CAutoBuy) ProtoMessage() {}
func (*S2CAutoBuy) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{6}
}
func (m *S2CAutoBuy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CAutoBuy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CAutoBuy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CAutoBuy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CAutoBuy.Merge(m, src)
}
func (m *S2CAutoBuy) XXX_Size() int {
	return m.Size()
}
func (m *S2CAutoBuy) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CAutoBuy.DiscardUnknown(m)
}

var xxx_messageInfo_S2CAutoBuy proto.InternalMessageInfo

func (m *S2CAutoBuy) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *S2CAutoBuy) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

// 匹配结果
type S2CEnter struct {
	Result EnterResult `protobuf:"varint,1,opt,name=Result,proto3,enum=proto.game.EnterResult" json:"Result,omitempty"`
}

func (m *S2CEnter) Reset()      { *m = S2CEnter{} }
func (*S2CEnter) ProtoMessage() {}
func (*S2CEnter) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{7}
}
func (m *S2CEnter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CEnter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CEnter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CEnter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CEnter.Merge(m, src)
}
func (m *S2CEnter) XXX_Size() int {
	return m.Size()
}
func (m *S2CEnter) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CEnter.DiscardUnknown(m)
}

var xxx_messageInfo_S2CEnter proto.InternalMessageInfo

func (m *S2CEnter) GetResult() EnterResult {
	if m != nil {
		return m.Result
	}
	return EnterSuccess
}

type C2SLeave struct {
}

func (m *C2SLeave) Reset()      { *m = C2SLeave{} }
func (*C2SLeave) ProtoMessage() {}
func (*C2SLeave) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{8}
}
func (m *C2SLeave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SLeave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SLeave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SLeave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SLeave.Merge(m, src)
}
func (m *C2SLeave) XXX_Size() int {
	return m.Size()
}
func (m *C2SLeave) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SLeave.DiscardUnknown(m)
}

var xxx_messageInfo_C2SLeave proto.InternalMessageInfo

type S2CLeave struct {
}

func (m *S2CLeave) Reset()      { *m = S2CLeave{} }
func (*S2CLeave) ProtoMessage() {}
func (*S2CLeave) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{9}
}
func (m *S2CLeave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CLeave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CLeave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CLeave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CLeave.Merge(m, src)
}
func (m *S2CLeave) XXX_Size() int {
	return m.Size()
}
func (m *S2CLeave) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CLeave.DiscardUnknown(m)
}

var xxx_messageInfo_S2CLeave proto.InternalMessageInfo

// 获取房间在线人数
type C2SGetNumOfPlayers struct {
	RoomId int32 `protobuf:"varint,1,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
}

func (m *C2SGetNumOfPlayers) Reset()      { *m = C2SGetNumOfPlayers{} }
func (*C2SGetNumOfPlayers) ProtoMessage() {}
func (*C2SGetNumOfPlayers) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{10}
}
func (m *C2SGetNumOfPlayers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SGetNumOfPlayers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SGetNumOfPlayers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SGetNumOfPlayers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SGetNumOfPlayers.Merge(m, src)
}
func (m *C2SGetNumOfPlayers) XXX_Size() int {
	return m.Size()
}
func (m *C2SGetNumOfPlayers) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SGetNumOfPlayers.DiscardUnknown(m)
}

var xxx_messageInfo_C2SGetNumOfPlayers proto.InternalMessageInfo

func (m *C2SGetNumOfPlayers) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type S2CGetNumOfPlayers struct {
	RoomId       int32 `protobuf:"varint,1,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
	NumOfPlayers int32 `protobuf:"varint,2,opt,name=NumOfPlayers,proto3" json:"NumOfPlayers,omitempty"`
}

func (m *S2CGetNumOfPlayers) Reset()      { *m = S2CGetNumOfPlayers{} }
func (*S2CGetNumOfPlayers) ProtoMessage() {}
func (*S2CGetNumOfPlayers) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{11}
}
func (m *S2CGetNumOfPlayers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGetNumOfPlayers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGetNumOfPlayers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CGetNumOfPlayers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGetNumOfPlayers.Merge(m, src)
}
func (m *S2CGetNumOfPlayers) XXX_Size() int {
	return m.Size()
}
func (m *S2CGetNumOfPlayers) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGetNumOfPlayers.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGetNumOfPlayers proto.InternalMessageInfo

func (m *S2CGetNumOfPlayers) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2CGetNumOfPlayers) GetNumOfPlayers() int32 {
	if m != nil {
		return m.NumOfPlayers
	}
	return 0
}

type C2SCheckEnter struct {
}

func (m *C2SCheckEnter) Reset()      { *m = C2SCheckEnter{} }
func (*C2SCheckEnter) ProtoMessage() {}
func (*C2SCheckEnter) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{12}
}
func (m *C2SCheckEnter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SCheckEnter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SCheckEnter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SCheckEnter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SCheckEnter.Merge(m, src)
}
func (m *C2SCheckEnter) XXX_Size() int {
	return m.Size()
}
func (m *C2SCheckEnter) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SCheckEnter.DiscardUnknown(m)
}

var xxx_messageInfo_C2SCheckEnter proto.InternalMessageInfo

// 房间玩家对象
type Player struct {
	Idx          int32  `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
	Id           int64  `protobuf:"varint,2,opt,name=Id,proto3" json:"Id,omitempty"`
	Name         string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Head         string `protobuf:"bytes,4,opt,name=Head,proto3" json:"Head,omitempty"`
	Op           Ops    `protobuf:"varint,5,opt,name=Op,proto3,enum=proto.game.Ops" json:"Op,omitempty"`
	State        States `protobuf:"varint,6,opt,name=State,proto3,enum=proto.game.States" json:"State,omitempty"`
	RemainMoney  int32  `protobuf:"varint,7,opt,name=RemainMoney,proto3" json:"RemainMoney,omitempty"`
	OpMoney      int32  `protobuf:"varint,8,opt,name=OpMoney,proto3" json:"OpMoney,omitempty"`
	TotalOpMoney int32  `protobuf:"varint,9,opt,name=TotalOpMoney,proto3" json:"TotalOpMoney,omitempty"`
}

func (m *Player) Reset()      { *m = Player{} }
func (*Player) ProtoMessage() {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{13}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *Player) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Player) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player) GetHead() string {
	if m != nil {
		return m.Head
	}
	return ""
}

func (m *Player) GetOp() Ops {
	if m != nil {
		return m.Op
	}
	return OpsNone
}

func (m *Player) GetState() States {
	if m != nil {
		return m.State
	}
	return StatesNone
}

func (m *Player) GetRemainMoney() int32 {
	if m != nil {
		return m.RemainMoney
	}
	return 0
}

func (m *Player) GetOpMoney() int32 {
	if m != nil {
		return m.OpMoney
	}
	return 0
}

func (m *Player) GetTotalOpMoney() int32 {
	if m != nil {
		return m.TotalOpMoney
	}
	return 0
}

// 牌桌相关信息
type S2CTable struct {
	Id            int32     `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	GameId        int64     `protobuf:"varint,2,opt,name=GameId,proto3" json:"GameId,omitempty"`
	NumOfPlayers  int32     `protobuf:"varint,3,opt,name=NumOfPlayers,proto3" json:"NumOfPlayers,omitempty"`
	Jackpot       int32     `protobuf:"varint,4,opt,name=Jackpot,proto3" json:"Jackpot,omitempty"`
	NumOfGame     int32     `protobuf:"varint,5,opt,name=NumOfGame,proto3" json:"NumOfGame,omitempty"`
	NumOfLoop     int32     `protobuf:"varint,6,opt,name=NumOfLoop,proto3" json:"NumOfLoop,omitempty"`
	NumOfRound    int32     `protobuf:"varint,7,opt,name=NumOfRound,proto3" json:"NumOfRound,omitempty"`
	OpCd          int32     `protobuf:"varint,8,opt,name=OpCd,proto3" json:"OpCd,omitempty"`
	DealerIdx     int32     `protobuf:"varint,9,opt,name=DealerIdx,proto3" json:"DealerIdx,omitempty"`
	Cards         []int32   `protobuf:"varint,10,rep,packed,name=Cards,proto3" json:"Cards,omitempty"`
	Players       []*Player `protobuf:"bytes,11,rep,name=Players,proto3" json:"Players,omitempty"`
	WaitOps       int32     `protobuf:"varint,12,opt,name=WaitOps,proto3" json:"WaitOps,omitempty"`
	HandCards     []int32   `protobuf:"varint,13,rep,packed,name=HandCards,proto3" json:"HandCards,omitempty"`
	SmallBlindIdx int32     `protobuf:"varint,14,opt,name=SmallBlindIdx,proto3" json:"SmallBlindIdx,omitempty"`
	BigBlindIdx   int32     `protobuf:"varint,15,opt,name=BigBlindIdx,proto3" json:"BigBlindIdx,omitempty"`
	NumOfStart    int32     `protobuf:"varint,16,opt,name=NumOfStart,proto3" json:"NumOfStart,omitempty"`
	ShowHandCards bool      `protobuf:"varint,17,opt,name=ShowHandCards,proto3" json:"ShowHandCards,omitempty"`
}

func (m *S2CTable) Reset()      { *m = S2CTable{} }
func (*S2CTable) ProtoMessage() {}
func (*S2CTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{14}
}
func (m *S2CTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CTable.Merge(m, src)
}
func (m *S2CTable) XXX_Size() int {
	return m.Size()
}
func (m *S2CTable) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CTable.DiscardUnknown(m)
}

var xxx_messageInfo_S2CTable proto.InternalMessageInfo

func (m *S2CTable) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *S2CTable) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *S2CTable) GetNumOfPlayers() int32 {
	if m != nil {
		return m.NumOfPlayers
	}
	return 0
}

func (m *S2CTable) GetJackpot() int32 {
	if m != nil {
		return m.Jackpot
	}
	return 0
}

func (m *S2CTable) GetNumOfGame() int32 {
	if m != nil {
		return m.NumOfGame
	}
	return 0
}

func (m *S2CTable) GetNumOfLoop() int32 {
	if m != nil {
		return m.NumOfLoop
	}
	return 0
}

func (m *S2CTable) GetNumOfRound() int32 {
	if m != nil {
		return m.NumOfRound
	}
	return 0
}

func (m *S2CTable) GetOpCd() int32 {
	if m != nil {
		return m.OpCd
	}
	return 0
}

func (m *S2CTable) GetDealerIdx() int32 {
	if m != nil {
		return m.DealerIdx
	}
	return 0
}

func (m *S2CTable) GetCards() []int32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *S2CTable) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *S2CTable) GetWaitOps() int32 {
	if m != nil {
		return m.WaitOps
	}
	return 0
}

func (m *S2CTable) GetHandCards() []int32 {
	if m != nil {
		return m.HandCards
	}
	return nil
}

func (m *S2CTable) GetSmallBlindIdx() int32 {
	if m != nil {
		return m.SmallBlindIdx
	}
	return 0
}

func (m *S2CTable) GetBigBlindIdx() int32 {
	if m != nil {
		return m.BigBlindIdx
	}
	return 0
}

func (m *S2CTable) GetNumOfStart() int32 {
	if m != nil {
		return m.NumOfStart
	}
	return 0
}

func (m *S2CTable) GetShowHandCards() bool {
	if m != nil {
		return m.ShowHandCards
	}
	return false
}

// 玩家进入
type S2CPlayerEnter struct {
	Player *Player `protobuf:"bytes,1,opt,name=Player,proto3" json:"Player,omitempty"`
}

func (m *S2CPlayerEnter) Reset()      { *m = S2CPlayerEnter{} }
func (*S2CPlayerEnter) ProtoMessage() {}
func (*S2CPlayerEnter) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{15}
}
func (m *S2CPlayerEnter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CPlayerEnter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CPlayerEnter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CPlayerEnter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CPlayerEnter.Merge(m, src)
}
func (m *S2CPlayerEnter) XXX_Size() int {
	return m.Size()
}
func (m *S2CPlayerEnter) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CPlayerEnter.DiscardUnknown(m)
}

var xxx_messageInfo_S2CPlayerEnter proto.InternalMessageInfo

func (m *S2CPlayerEnter) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

// 玩家离开
type S2CPlayerLeave struct {
	Idx int32 `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
}

func (m *S2CPlayerLeave) Reset()      { *m = S2CPlayerLeave{} }
func (*S2CPlayerLeave) ProtoMessage() {}
func (*S2CPlayerLeave) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{16}
}
func (m *S2CPlayerLeave) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CPlayerLeave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CPlayerLeave.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CPlayerLeave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CPlayerLeave.Merge(m, src)
}
func (m *S2CPlayerLeave) XXX_Size() int {
	return m.Size()
}
func (m *S2CPlayerLeave) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CPlayerLeave.DiscardUnknown(m)
}

var xxx_messageInfo_S2CPlayerLeave proto.InternalMessageInfo

func (m *S2CPlayerLeave) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

type C2SOp struct {
	Op    Ops   `protobuf:"varint,1,opt,name=Op,proto3,enum=proto.game.Ops" json:"Op,omitempty"`
	Money int32 `protobuf:"varint,2,opt,name=Money,proto3" json:"Money,omitempty"`
}

func (m *C2SOp) Reset()      { *m = C2SOp{} }
func (*C2SOp) ProtoMessage() {}
func (*C2SOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{17}
}
func (m *C2SOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SOp.Merge(m, src)
}
func (m *C2SOp) XXX_Size() int {
	return m.Size()
}
func (m *C2SOp) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SOp.DiscardUnknown(m)
}

var xxx_messageInfo_C2SOp proto.InternalMessageInfo

func (m *C2SOp) GetOp() Ops {
	if m != nil {
		return m.Op
	}
	return OpsNone
}

func (m *C2SOp) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

// 玩家状态同步
type S2COp struct {
	Idx          int32  `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
	Ops          Ops    `protobuf:"varint,2,opt,name=Ops,proto3,enum=proto.game.Ops" json:"Ops,omitempty"`
	State        States `protobuf:"varint,3,opt,name=State,proto3,enum=proto.game.States" json:"State,omitempty"`
	RemainMoney  int32  `protobuf:"varint,4,opt,name=RemainMoney,proto3" json:"RemainMoney,omitempty"`
	OpMoney      int32  `protobuf:"varint,5,opt,name=OpMoney,proto3" json:"OpMoney,omitempty"`
	TotalOpMoney int32  `protobuf:"varint,6,opt,name=TotalOpMoney,proto3" json:"TotalOpMoney,omitempty"`
}

func (m *S2COp) Reset()      { *m = S2COp{} }
func (*S2COp) ProtoMessage() {}
func (*S2COp) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{18}
}
func (m *S2COp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2COp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2COp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2COp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2COp.Merge(m, src)
}
func (m *S2COp) XXX_Size() int {
	return m.Size()
}
func (m *S2COp) XXX_DiscardUnknown() {
	xxx_messageInfo_S2COp.DiscardUnknown(m)
}

var xxx_messageInfo_S2COp proto.InternalMessageInfo

func (m *S2COp) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *S2COp) GetOps() Ops {
	if m != nil {
		return m.Ops
	}
	return OpsNone
}

func (m *S2COp) GetState() States {
	if m != nil {
		return m.State
	}
	return StatesNone
}

func (m *S2COp) GetRemainMoney() int32 {
	if m != nil {
		return m.RemainMoney
	}
	return 0
}

func (m *S2COp) GetOpMoney() int32 {
	if m != nil {
		return m.OpMoney
	}
	return 0
}

func (m *S2COp) GetTotalOpMoney() int32 {
	if m != nil {
		return m.TotalOpMoney
	}
	return 0
}

// 等待状态下的操作按钮
type S2CWaitOps struct {
	Ops           int32 `protobuf:"varint,1,opt,name=Ops,proto3" json:"Ops,omitempty"`
	MinRaiseMoney int32 `protobuf:"varint,2,opt,name=MinRaiseMoney,proto3" json:"MinRaiseMoney,omitempty"`
	CallMoney     int32 `protobuf:"varint,3,opt,name=CallMoney,proto3" json:"CallMoney,omitempty"`
}

func (m *S2CWaitOps) Reset()      { *m = S2CWaitOps{} }
func (*S2CWaitOps) ProtoMessage() {}
func (*S2CWaitOps) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{19}
}
func (m *S2CWaitOps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CWaitOps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CWaitOps.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CWaitOps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CWaitOps.Merge(m, src)
}
func (m *S2CWaitOps) XXX_Size() int {
	return m.Size()
}
func (m *S2CWaitOps) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CWaitOps.DiscardUnknown(m)
}

var xxx_messageInfo_S2CWaitOps proto.InternalMessageInfo

func (m *S2CWaitOps) GetOps() int32 {
	if m != nil {
		return m.Ops
	}
	return 0
}

func (m *S2CWaitOps) GetMinRaiseMoney() int32 {
	if m != nil {
		return m.MinRaiseMoney
	}
	return 0
}

func (m *S2CWaitOps) GetCallMoney() int32 {
	if m != nil {
		return m.CallMoney
	}
	return 0
}

// 对局开始
type S2CGameStart struct {
	RoomId     int32   `protobuf:"varint,1,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
	GameId     int64   `protobuf:"varint,2,opt,name=GameId,proto3" json:"GameId,omitempty"`
	NumOfGame  int32   `protobuf:"varint,3,opt,name=NumOfGame,proto3" json:"NumOfGame,omitempty"`
	DealerIdx  int32   `protobuf:"varint,4,opt,name=DealerIdx,proto3" json:"DealerIdx,omitempty"`
	NewPlayers []int32 `protobuf:"varint,5,rep,packed,name=NewPlayers,proto3" json:"NewPlayers,omitempty"`
}

func (m *S2CGameStart) Reset()      { *m = S2CGameStart{} }
func (*S2CGameStart) ProtoMessage() {}
func (*S2CGameStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{20}
}
func (m *S2CGameStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGameStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGameStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CGameStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGameStart.Merge(m, src)
}
func (m *S2CGameStart) XXX_Size() int {
	return m.Size()
}
func (m *S2CGameStart) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGameStart.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGameStart proto.InternalMessageInfo

func (m *S2CGameStart) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2CGameStart) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *S2CGameStart) GetNumOfGame() int32 {
	if m != nil {
		return m.NumOfGame
	}
	return 0
}

func (m *S2CGameStart) GetDealerIdx() int32 {
	if m != nil {
		return m.DealerIdx
	}
	return 0
}

func (m *S2CGameStart) GetNewPlayers() []int32 {
	if m != nil {
		return m.NewPlayers
	}
	return nil
}

type PlayerStakes struct {
	Idx        int32 `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
	Money      int32 `protobuf:"varint,2,opt,name=Money,proto3" json:"Money,omitempty"`
	TotalMoney int32 `protobuf:"varint,3,opt,name=TotalMoney,proto3" json:"TotalMoney,omitempty"`
}

func (m *PlayerStakes) Reset()      { *m = PlayerStakes{} }
func (*PlayerStakes) ProtoMessage() {}
func (*PlayerStakes) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{21}
}
func (m *PlayerStakes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerStakes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerStakes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerStakes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerStakes.Merge(m, src)
}
func (m *PlayerStakes) XXX_Size() int {
	return m.Size()
}
func (m *PlayerStakes) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerStakes.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerStakes proto.InternalMessageInfo

func (m *PlayerStakes) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *PlayerStakes) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *PlayerStakes) GetTotalMoney() int32 {
	if m != nil {
		return m.TotalMoney
	}
	return 0
}

// 一圈内最后一个玩家操作
type S2CLoopOverBefore struct {
	EarlyOver bool `protobuf:"varint,1,opt,name=EarlyOver,proto3" json:"EarlyOver,omitempty"`
}

func (m *S2CLoopOverBefore) Reset()      { *m = S2CLoopOverBefore{} }
func (*S2CLoopOverBefore) ProtoMessage() {}
func (*S2CLoopOverBefore) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{22}
}
func (m *S2CLoopOverBefore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CLoopOverBefore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CLoopOverBefore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CLoopOverBefore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CLoopOverBefore.Merge(m, src)
}
func (m *S2CLoopOverBefore) XXX_Size() int {
	return m.Size()
}
func (m *S2CLoopOverBefore) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CLoopOverBefore.DiscardUnknown(m)
}

var xxx_messageInfo_S2CLoopOverBefore proto.InternalMessageInfo

func (m *S2CLoopOverBefore) GetEarlyOver() bool {
	if m != nil {
		return m.EarlyOver
	}
	return false
}

// 结束一圈
type S2CLoopOver struct {
	NumOfLoop int32           `protobuf:"varint,1,opt,name=NumOfLoop,proto3" json:"NumOfLoop,omitempty"`
	Jackpot   int32           `protobuf:"varint,2,opt,name=Jackpot,proto3" json:"Jackpot,omitempty"`
	Stakes    []*PlayerStakes `protobuf:"bytes,3,rep,name=Stakes,proto3" json:"Stakes,omitempty"`
}

func (m *S2CLoopOver) Reset()      { *m = S2CLoopOver{} }
func (*S2CLoopOver) ProtoMessage() {}
func (*S2CLoopOver) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{23}
}
func (m *S2CLoopOver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CLoopOver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CLoopOver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CLoopOver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CLoopOver.Merge(m, src)
}
func (m *S2CLoopOver) XXX_Size() int {
	return m.Size()
}
func (m *S2CLoopOver) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CLoopOver.DiscardUnknown(m)
}

var xxx_messageInfo_S2CLoopOver proto.InternalMessageInfo

func (m *S2CLoopOver) GetNumOfLoop() int32 {
	if m != nil {
		return m.NumOfLoop
	}
	return 0
}

func (m *S2CLoopOver) GetJackpot() int32 {
	if m != nil {
		return m.Jackpot
	}
	return 0
}

func (m *S2CLoopOver) GetStakes() []*PlayerStakes {
	if m != nil {
		return m.Stakes
	}
	return nil
}

// 结束一轮
type S2CRoundOver struct {
	NumOfRound int32 `protobuf:"varint,1,opt,name=NumOfRound,proto3" json:"NumOfRound,omitempty"`
}

func (m *S2CRoundOver) Reset()      { *m = S2CRoundOver{} }
func (*S2CRoundOver) ProtoMessage() {}
func (*S2CRoundOver) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{24}
}
func (m *S2CRoundOver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CRoundOver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CRoundOver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CRoundOver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CRoundOver.Merge(m, src)
}
func (m *S2CRoundOver) XXX_Size() int {
	return m.Size()
}
func (m *S2CRoundOver) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CRoundOver.DiscardUnknown(m)
}

var xxx_messageInfo_S2CRoundOver proto.InternalMessageInfo

func (m *S2CRoundOver) GetNumOfRound() int32 {
	if m != nil {
		return m.NumOfRound
	}
	return 0
}

// 发牌
type S2CDealCards struct {
	Type  DealCardsType `protobuf:"varint,1,opt,name=Type,proto3,enum=proto.game.DealCardsType" json:"Type,omitempty"`
	Cards []int32       `protobuf:"varint,2,rep,packed,name=Cards,proto3" json:"Cards,omitempty"`
}

func (m *S2CDealCards) Reset()      { *m = S2CDealCards{} }
func (*S2CDealCards) ProtoMessage() {}
func (*S2CDealCards) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{25}
}
func (m *S2CDealCards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CDealCards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CDealCards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CDealCards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CDealCards.Merge(m, src)
}
func (m *S2CDealCards) XXX_Size() int {
	return m.Size()
}
func (m *S2CDealCards) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CDealCards.DiscardUnknown(m)
}

var xxx_messageInfo_S2CDealCards proto.InternalMessageInfo

func (m *S2CDealCards) GetType() DealCardsType {
	if m != nil {
		return m.Type
	}
	return DealCardsTypeHole
}

func (m *S2CDealCards) GetCards() []int32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

type PlayerCards struct {
	Idx   int32   `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
	Cards []int32 `protobuf:"varint,2,rep,packed,name=Cards,proto3" json:"Cards,omitempty"`
}

func (m *PlayerCards) Reset()      { *m = PlayerCards{} }
func (*PlayerCards) ProtoMessage() {}
func (*PlayerCards) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{26}
}
func (m *PlayerCards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerCards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerCards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerCards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerCards.Merge(m, src)
}
func (m *PlayerCards) XXX_Size() int {
	return m.Size()
}
func (m *PlayerCards) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerCards.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerCards proto.InternalMessageInfo

func (m *PlayerCards) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *PlayerCards) GetCards() []int32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

// 摊牌
type S2CShowCards struct {
	Cards []*PlayerCards `protobuf:"bytes,1,rep,name=Cards,proto3" json:"Cards,omitempty"`
}

func (m *S2CShowCards) Reset()      { *m = S2CShowCards{} }
func (*S2CShowCards) ProtoMessage() {}
func (*S2CShowCards) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{27}
}
func (m *S2CShowCards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CShowCards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CShowCards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CShowCards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CShowCards.Merge(m, src)
}
func (m *S2CShowCards) XXX_Size() int {
	return m.Size()
}
func (m *S2CShowCards) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CShowCards.DiscardUnknown(m)
}

var xxx_messageInfo_S2CShowCards proto.InternalMessageInfo

func (m *S2CShowCards) GetCards() []*PlayerCards {
	if m != nil {
		return m.Cards
	}
	return nil
}

type PlayerSettle struct {
	Idx        int32     `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
	Type       CardTypes `protobuf:"varint,2,opt,name=Type,proto3,enum=proto.game.CardTypes" json:"Type,omitempty"`
	Cards      []int32   `protobuf:"varint,3,rep,packed,name=Cards,proto3" json:"Cards,omitempty"`
	TotalMoney int32     `protobuf:"varint,4,opt,name=TotalMoney,proto3" json:"TotalMoney,omitempty"`
	WinMoney   int32     `protobuf:"varint,5,opt,name=WinMoney,proto3" json:"WinMoney,omitempty"`
}

func (m *PlayerSettle) Reset()      { *m = PlayerSettle{} }
func (*PlayerSettle) ProtoMessage() {}
func (*PlayerSettle) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{28}
}
func (m *PlayerSettle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerSettle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerSettle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerSettle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerSettle.Merge(m, src)
}
func (m *PlayerSettle) XXX_Size() int {
	return m.Size()
}
func (m *PlayerSettle) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerSettle.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerSettle proto.InternalMessageInfo

func (m *PlayerSettle) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *PlayerSettle) GetType() CardTypes {
	if m != nil {
		return m.Type
	}
	return CardTypesNone
}

func (m *PlayerSettle) GetCards() []int32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *PlayerSettle) GetTotalMoney() int32 {
	if m != nil {
		return m.TotalMoney
	}
	return 0
}

func (m *PlayerSettle) GetWinMoney() int32 {
	if m != nil {
		return m.WinMoney
	}
	return 0
}

// 结算
type S2CSettle struct {
	Settles []*PlayerSettle `protobuf:"bytes,1,rep,name=Settles,proto3" json:"Settles,omitempty"`
}

func (m *S2CSettle) Reset()      { *m = S2CSettle{} }
func (*S2CSettle) ProtoMessage() {}
func (*S2CSettle) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{29}
}
func (m *S2CSettle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CSettle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CSettle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CSettle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CSettle.Merge(m, src)
}
func (m *S2CSettle) XXX_Size() int {
	return m.Size()
}
func (m *S2CSettle) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CSettle.DiscardUnknown(m)
}

var xxx_messageInfo_S2CSettle proto.InternalMessageInfo

func (m *S2CSettle) GetSettles() []*PlayerSettle {
	if m != nil {
		return m.Settles
	}
	return nil
}

type GameInfo struct {
	Win           bool      `protobuf:"varint,3,opt,name=Win,proto3" json:"Win,omitempty"`
	Stakes        int32     `protobuf:"varint,4,opt,name=Stakes,proto3" json:"Stakes,omitempty"`
	RaiseFlag     int32     `protobuf:"varint,5,opt,name=RaiseFlag,proto3" json:"RaiseFlag,omitempty"`
	FoldFlag      int32     `protobuf:"varint,6,opt,name=FoldFlag,proto3" json:"FoldFlag,omitempty"`
	CallOrRaise   bool      `protobuf:"varint,7,opt,name=CallOrRaise,proto3" json:"CallOrRaise,omitempty"`
	CardValue     int32     `protobuf:"varint,8,opt,name=CardValue,proto3" json:"CardValue,omitempty"`
	Cards         []int32   `protobuf:"varint,9,rep,packed,name=Cards,proto3" json:"Cards,omitempty"`
	CardType      CardTypes `protobuf:"varint,10,opt,name=CardType,proto3,enum=proto.game.CardTypes" json:"CardType,omitempty"`
	TotalBetMoney int32     `protobuf:"varint,11,opt,name=TotalBetMoney,proto3" json:"TotalBetMoney,omitempty"`
}

func (m *GameInfo) Reset()      { *m = GameInfo{} }
func (*GameInfo) ProtoMessage() {}
func (*GameInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{30}
}
func (m *GameInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameInfo.Merge(m, src)
}
func (m *GameInfo) XXX_Size() int {
	return m.Size()
}
func (m *GameInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GameInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GameInfo proto.InternalMessageInfo

func (m *GameInfo) GetWin() bool {
	if m != nil {
		return m.Win
	}
	return false
}

func (m *GameInfo) GetStakes() int32 {
	if m != nil {
		return m.Stakes
	}
	return 0
}

func (m *GameInfo) GetRaiseFlag() int32 {
	if m != nil {
		return m.RaiseFlag
	}
	return 0
}

func (m *GameInfo) GetFoldFlag() int32 {
	if m != nil {
		return m.FoldFlag
	}
	return 0
}

func (m *GameInfo) GetCallOrRaise() bool {
	if m != nil {
		return m.CallOrRaise
	}
	return false
}

func (m *GameInfo) GetCardValue() int32 {
	if m != nil {
		return m.CardValue
	}
	return 0
}

func (m *GameInfo) GetCards() []int32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *GameInfo) GetCardType() CardTypes {
	if m != nil {
		return m.CardType
	}
	return CardTypesNone
}

func (m *GameInfo) GetTotalBetMoney() int32 {
	if m != nil {
		return m.TotalBetMoney
	}
	return 0
}

// 对局结束
type S2CGameOver struct {
	RoomId   int32     `protobuf:"varint,1,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
	GameId   int64     `protobuf:"varint,2,opt,name=GameId,proto3" json:"GameId,omitempty"`
	PlayerId int64     `protobuf:"varint,3,opt,name=PlayerId,proto3" json:"PlayerId,omitempty"`
	Info     *GameInfo `protobuf:"bytes,4,opt,name=Info,proto3" json:"Info,omitempty"`
}

func (m *S2CGameOver) Reset()      { *m = S2CGameOver{} }
func (*S2CGameOver) ProtoMessage() {}
func (*S2CGameOver) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{31}
}
func (m *S2CGameOver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGameOver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGameOver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CGameOver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGameOver.Merge(m, src)
}
func (m *S2CGameOver) XXX_Size() int {
	return m.Size()
}
func (m *S2CGameOver) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGameOver.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGameOver proto.InternalMessageInfo

func (m *S2CGameOver) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2CGameOver) GetGameId() int64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *S2CGameOver) GetPlayerId() int64 {
	if m != nil {
		return m.PlayerId
	}
	return 0
}

func (m *S2CGameOver) GetInfo() *GameInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

type C2SStandUp struct {
}

func (m *C2SStandUp) Reset()      { *m = C2SStandUp{} }
func (*C2SStandUp) ProtoMessage() {}
func (*C2SStandUp) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{32}
}
func (m *C2SStandUp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SStandUp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SStandUp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SStandUp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SStandUp.Merge(m, src)
}
func (m *C2SStandUp) XXX_Size() int {
	return m.Size()
}
func (m *C2SStandUp) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SStandUp.DiscardUnknown(m)
}

var xxx_messageInfo_C2SStandUp proto.InternalMessageInfo

type S2CStandUp struct {
	Success bool `protobuf:"varint,1,opt,name=Success,proto3" json:"Success,omitempty"`
}

func (m *S2CStandUp) Reset()      { *m = S2CStandUp{} }
func (*S2CStandUp) ProtoMessage() {}
func (*S2CStandUp) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{33}
}
func (m *S2CStandUp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CStandUp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CStandUp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CStandUp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CStandUp.Merge(m, src)
}
func (m *S2CStandUp) XXX_Size() int {
	return m.Size()
}
func (m *S2CStandUp) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CStandUp.DiscardUnknown(m)
}

var xxx_messageInfo_S2CStandUp proto.InternalMessageInfo

func (m *S2CStandUp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type C2SSitDown struct {
	Idx int32 `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
}

func (m *C2SSitDown) Reset()      { *m = C2SSitDown{} }
func (*C2SSitDown) ProtoMessage() {}
func (*C2SSitDown) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{34}
}
func (m *C2SSitDown) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SSitDown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SSitDown.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SSitDown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SSitDown.Merge(m, src)
}
func (m *C2SSitDown) XXX_Size() int {
	return m.Size()
}
func (m *C2SSitDown) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SSitDown.DiscardUnknown(m)
}

var xxx_messageInfo_C2SSitDown proto.InternalMessageInfo

func (m *C2SSitDown) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

type S2CSitDown struct {
	Idx     int32 `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
	Success bool  `protobuf:"varint,2,opt,name=Success,proto3" json:"Success,omitempty"`
}

func (m *S2CSitDown) Reset()      { *m = S2CSitDown{} }
func (*S2CSitDown) ProtoMessage() {}
func (*S2CSitDown) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{35}
}
func (m *S2CSitDown) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CSitDown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CSitDown.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CSitDown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CSitDown.Merge(m, src)
}
func (m *S2CSitDown) XXX_Size() int {
	return m.Size()
}
func (m *S2CSitDown) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CSitDown.DiscardUnknown(m)
}

var xxx_messageInfo_S2CSitDown proto.InternalMessageInfo

func (m *S2CSitDown) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *S2CSitDown) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type C2STips struct {
}

func (m *C2STips) Reset()      { *m = C2STips{} }
func (*C2STips) ProtoMessage() {}
func (*C2STips) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{36}
}
func (m *C2STips) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2STips) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2STips.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2STips) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2STips.Merge(m, src)
}
func (m *C2STips) XXX_Size() int {
	return m.Size()
}
func (m *C2STips) XXX_DiscardUnknown() {
	xxx_messageInfo_C2STips.DiscardUnknown(m)
}

var xxx_messageInfo_C2STips proto.InternalMessageInfo

type S2CTips struct {
	Idx       int32 `protobuf:"varint,1,opt,name=Idx,proto3" json:"Idx,omitempty"`
	Money     int32 `protobuf:"varint,2,opt,name=Money,proto3" json:"Money,omitempty"`
	LeftMoney int32 `protobuf:"varint,3,opt,name=LeftMoney,proto3" json:"LeftMoney,omitempty"`
	Success   bool  `protobuf:"varint,4,opt,name=Success,proto3" json:"Success,omitempty"`
}

func (m *S2CTips) Reset()      { *m = S2CTips{} }
func (*S2CTips) ProtoMessage() {}
func (*S2CTips) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{37}
}
func (m *S2CTips) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CTips) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CTips.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CTips) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CTips.Merge(m, src)
}
func (m *S2CTips) XXX_Size() int {
	return m.Size()
}
func (m *S2CTips) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CTips.DiscardUnknown(m)
}

var xxx_messageInfo_S2CTips proto.InternalMessageInfo

func (m *S2CTips) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *S2CTips) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *S2CTips) GetLeftMoney() int32 {
	if m != nil {
		return m.LeftMoney
	}
	return 0
}

func (m *S2CTips) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type S2CGameKick struct {
	Type KickType `protobuf:"varint,1,opt,name=Type,proto3,enum=proto.game.KickType" json:"Type,omitempty"`
}

func (m *S2CGameKick) Reset()      { *m = S2CGameKick{} }
func (*S2CGameKick) ProtoMessage() {}
func (*S2CGameKick) Descriptor() ([]byte, []int) {
	return fileDescriptor_38fc58335341d769, []int{38}
}
func (m *S2CGameKick) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CGameKick) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CGameKick.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CGameKick) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CGameKick.Merge(m, src)
}
func (m *S2CGameKick) XXX_Size() int {
	return m.Size()
}
func (m *S2CGameKick) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CGameKick.DiscardUnknown(m)
}

var xxx_messageInfo_S2CGameKick proto.InternalMessageInfo

func (m *S2CGameKick) GetType() KickType {
	if m != nil {
		return m.Type
	}
	return Closed
}

func init() {
	proto.RegisterEnum("proto.game.EnterResult", EnterResult_name, EnterResult_value)
	proto.RegisterEnum("proto.game.Ops", Ops_name, Ops_value)
	proto.RegisterEnum("proto.game.States", States_name, States_value)
	proto.RegisterEnum("proto.game.DealCardsType", DealCardsType_name, DealCardsType_value)
	proto.RegisterEnum("proto.game.CardTypes", CardTypes_name, CardTypes_value)
	proto.RegisterEnum("proto.game.KickType", KickType_name, KickType_value)
	proto.RegisterType((*C2SRoomOptions)(nil), "proto.game.C2SRoomOptions")
	proto.RegisterType((*S2CRoomOptions)(nil), "proto.game.S2CRoomOptions")
	proto.RegisterType((*C2SEnter)(nil), "proto.game.C2SEnter")
	proto.RegisterType((*S2CMoneyNotEnough)(nil), "proto.game.S2CMoneyNotEnough")
	proto.RegisterType((*C2SBuy)(nil), "proto.game.C2SBuy")
	proto.RegisterType((*S2CBuy)(nil), "proto.game.S2CBuy")
	proto.RegisterType((*S2CAutoBuy)(nil), "proto.game.S2CAutoBuy")
	proto.RegisterType((*S2CEnter)(nil), "proto.game.S2CEnter")
	proto.RegisterType((*C2SLeave)(nil), "proto.game.C2SLeave")
	proto.RegisterType((*S2CLeave)(nil), "proto.game.S2CLeave")
	proto.RegisterType((*C2SGetNumOfPlayers)(nil), "proto.game.C2SGetNumOfPlayers")
	proto.RegisterType((*S2CGetNumOfPlayers)(nil), "proto.game.S2CGetNumOfPlayers")
	proto.RegisterType((*C2SCheckEnter)(nil), "proto.game.C2SCheckEnter")
	proto.RegisterType((*Player)(nil), "proto.game.Player")
	proto.RegisterType((*S2CTable)(nil), "proto.game.S2CTable")
	proto.RegisterType((*S2CPlayerEnter)(nil), "proto.game.S2CPlayerEnter")
	proto.RegisterType((*S2CPlayerLeave)(nil), "proto.game.S2CPlayerLeave")
	proto.RegisterType((*C2SOp)(nil), "proto.game.C2SOp")
	proto.RegisterType((*S2COp)(nil), "proto.game.S2COp")
	proto.RegisterType((*S2CWaitOps)(nil), "proto.game.S2CWaitOps")
	proto.RegisterType((*S2CGameStart)(nil), "proto.game.S2CGameStart")
	proto.RegisterType((*PlayerStakes)(nil), "proto.game.PlayerStakes")
	proto.RegisterType((*S2CLoopOverBefore)(nil), "proto.game.S2CLoopOverBefore")
	proto.RegisterType((*S2CLoopOver)(nil), "proto.game.S2CLoopOver")
	proto.RegisterType((*S2CRoundOver)(nil), "proto.game.S2CRoundOver")
	proto.RegisterType((*S2CDealCards)(nil), "proto.game.S2CDealCards")
	proto.RegisterType((*PlayerCards)(nil), "proto.game.PlayerCards")
	proto.RegisterType((*S2CShowCards)(nil), "proto.game.S2CShowCards")
	proto.RegisterType((*PlayerSettle)(nil), "proto.game.PlayerSettle")
	proto.RegisterType((*S2CSettle)(nil), "proto.game.S2CSettle")
	proto.RegisterType((*GameInfo)(nil), "proto.game.GameInfo")
	proto.RegisterType((*S2CGameOver)(nil), "proto.game.S2CGameOver")
	proto.RegisterType((*C2SStandUp)(nil), "proto.game.C2SStandUp")
	proto.RegisterType((*S2CStandUp)(nil), "proto.game.S2CStandUp")
	proto.RegisterType((*C2SSitDown)(nil), "proto.game.C2SSitDown")
	proto.RegisterType((*S2CSitDown)(nil), "proto.game.S2CSitDown")
	proto.RegisterType((*C2STips)(nil), "proto.game.C2STips")
	proto.RegisterType((*S2CTips)(nil), "proto.game.S2CTips")
	proto.RegisterType((*S2CGameKick)(nil), "proto.game.S2CGameKick")
}

func init() { proto.RegisterFile("game.proto", fileDescriptor_38fc58335341d769) }

var fileDescriptor_38fc58335341d769 = []byte{
	// 1653 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x4b, 0x6f, 0xdc, 0xc8,
	0x11, 0x1e, 0x72, 0xde, 0x35, 0x7a, 0x50, 0x6d, 0x3d, 0xc6, 0x46, 0x30, 0x51, 0x08, 0x23, 0x50,
	0x04, 0x47, 0x89, 0x19, 0x07, 0x09, 0x90, 0x87, 0x23, 0xd1, 0x96, 0xa5, 0xd8, 0x16, 0x05, 0x52,
	0xb1, 0x73, 0xa5, 0x34, 0x2d, 0x89, 0x10, 0x87, 0x24, 0x48, 0x8e, 0x65, 0xed, 0x69, 0x17, 0x7b,
	0xd9, 0xd3, 0x62, 0xcf, 0x0b, 0xf8, 0xbe, 0xbf, 0x64, 0xb1, 0x47, 0x1f, 0x7d, 0x5c, 0xcb, 0x97,
	0x3d, 0xfa, 0x0f, 0x2c, 0xb0, 0xa8, 0xea, 0xe6, 0x4b, 0x1a, 0x09, 0xf2, 0x65, 0x4f, 0xd3, 0xf5,
	0x55, 0x75, 0x77, 0xf5, 0xd7, 0xf5, 0x55, 0x73, 0x00, 0x8e, 0xdc, 0x11, 0x5f, 0x8b, 0xe2, 0x30,
	0x0d, 0x19, 0xd0, 0xcf, 0x1a, 0x22, 0xba, 0x0f, 0x33, 0xa6, 0xe1, 0xd8, 0x61, 0x38, 0xb2, 0xa2,
	0xd4, 0x0b, 0x83, 0x84, 0xcd, 0x80, 0xba, 0x3d, 0xec, 0x2b, 0xcb, 0xca, 0x4a, 0xd3, 0x56, 0xb7,
	0x87, 0xac, 0x0f, 0xed, 0xf5, 0x71, 0x1a, 0x6e, 0x8c, 0xcf, 0xfa, 0xea, 0xb2, 0xb2, 0xd2, 0xb1,
	0x33, 0x93, 0x0d, 0x00, 0xe4, 0xf0, 0xb9, 0xfb, 0xba, 0x5f, 0x27, 0x67, 0x09, 0x61, 0x1a, 0xd4,
	0x71, 0x56, 0x83, 0x96, 0xc2, 0x21, 0xee, 0xe6, 0x18, 0xe6, 0xaf, 0xb5, 0xdb, 0xff, 0xa1, 0x63,
	0x1a, 0xce, 0xe3, 0x20, 0xe5, 0x31, 0x5b, 0x84, 0x16, 0x6e, 0x9b, 0xef, 0x25, 0xad, 0x6c, 0x96,
	0x9a, 0xcf, 0x62, 0x3a, 0x4c, 0xed, 0x8c, 0x47, 0xd6, 0xe1, 0xae, 0xef, 0x9e, 0xf1, 0x38, 0xa1,
	0x9d, 0x9a, 0x76, 0x05, 0xd3, 0xb7, 0x61, 0xce, 0x31, 0xcc, 0xe7, 0x61, 0xc0, 0xcf, 0x76, 0xc2,
	0xf4, 0x71, 0x10, 0x8e, 0x8f, 0x8e, 0xaf, 0xdc, 0xe2, 0x37, 0xd0, 0x7d, 0xc6, 0x0f, 0x53, 0x8a,
	0x96, 0x1b, 0x15, 0x80, 0xfe, 0x00, 0x5a, 0xa6, 0xe1, 0xe0, 0xc6, 0x32, 0x15, 0xa5, 0x48, 0xe5,
	0x4a, 0x32, 0x74, 0x1d, 0x5a, 0x8e, 0x61, 0xca, 0x18, 0x67, 0x7c, 0x70, 0xc0, 0x93, 0x84, 0x66,
	0x76, 0xec, 0xcc, 0xd4, 0x1f, 0x00, 0x38, 0x86, 0x99, 0xd1, 0xa7, 0x41, 0x7d, 0x7b, 0xf8, 0x3a,
	0x5b, 0x7d, 0x7b, 0xf8, 0x9a, 0xcd, 0x43, 0xb3, 0x9c, 0x93, 0x30, 0xf4, 0x7f, 0x40, 0xc7, 0x31,
	0x4c, 0x41, 0xda, 0x9f, 0xa0, 0x65, 0xf3, 0x64, 0xec, 0xa7, 0x34, 0x6d, 0xc6, 0x58, 0x5a, 0x2b,
	0x2a, 0x67, 0x8d, 0x42, 0x84, 0xdb, 0x96, 0x61, 0x3a, 0x10, 0xe3, 0xcf, 0xb8, 0xfb, 0x8a, 0xe3,
	0xd8, 0x31, 0x4c, 0x31, 0xbe, 0x07, 0xcc, 0x34, 0x9c, 0x27, 0x3c, 0x2d, 0xb3, 0x78, 0x15, 0x61,
	0xfa, 0x2e, 0x30, 0xc7, 0x30, 0x6f, 0x18, 0x7d, 0xe9, 0xbe, 0xd4, 0x09, 0xf7, 0x35, 0x0b, 0xd3,
	0xa6, 0xe1, 0x98, 0xc7, 0xfc, 0xe0, 0x84, 0xd2, 0xd6, 0x7f, 0x56, 0xa0, 0x25, 0x9c, 0x13, 0x88,
	0x11, 0x35, 0x89, 0xeb, 0xd4, 0xa9, 0x26, 0x19, 0x34, 0x76, 0xdc, 0x11, 0xa7, 0x4a, 0xe8, 0xda,
	0x34, 0x46, 0x6c, 0x8b, 0xbb, 0x43, 0x2a, 0xb7, 0xae, 0x4d, 0x63, 0xf6, 0x5b, 0x50, 0xad, 0xa8,
	0xdf, 0x24, 0xaa, 0x66, 0xcb, 0x54, 0x59, 0x51, 0x62, 0xab, 0x56, 0xc4, 0x56, 0xa0, 0xe9, 0xa4,
	0x6e, 0xca, 0xfb, 0x2d, 0x8a, 0x61, 0xe5, 0x18, 0x72, 0x24, 0xb6, 0x08, 0x60, 0xcb, 0xd0, 0xb3,
	0xf9, 0xc8, 0xf5, 0x02, 0x71, 0x43, 0x6d, 0x4a, 0xae, 0x0c, 0xe1, 0xbd, 0x5b, 0x91, 0xf0, 0x76,
	0xc8, 0x9b, 0x99, 0x48, 0xc8, 0x5e, 0x98, 0xba, 0x7e, 0xe6, 0xee, 0x0a, 0x42, 0xca, 0x98, 0xfe,
	0x55, 0x83, 0x6e, 0x67, 0xcf, 0xdd, 0xf7, 0xf9, 0x25, 0x0d, 0x2e, 0x42, 0xeb, 0x89, 0x3b, 0xe2,
	0x39, 0x07, 0xd2, 0xba, 0x89, 0x32, 0x30, 0xad, 0xff, 0xba, 0x07, 0x27, 0x51, 0x98, 0x4a, 0x25,
	0x66, 0x26, 0xca, 0x80, 0x22, 0x71, 0x31, 0x22, 0xa9, 0x69, 0x17, 0x40, 0xee, 0x7d, 0x16, 0x86,
	0x11, 0xd1, 0x93, 0x79, 0x11, 0x40, 0xed, 0x93, 0x61, 0x87, 0xe3, 0x60, 0x28, 0xd9, 0x28, 0x21,
	0x78, 0x1b, 0x56, 0x64, 0x0e, 0x25, 0x13, 0x34, 0xc6, 0x15, 0x1f, 0x71, 0xd7, 0xe7, 0x31, 0xde,
	0xae, 0xe0, 0xa0, 0x00, 0xb0, 0xf8, 0x4d, 0x37, 0x1e, 0x26, 0x7d, 0x58, 0xae, 0x63, 0xf1, 0x93,
	0xc1, 0xee, 0x41, 0x3b, 0x3b, 0x5c, 0x6f, 0xb9, 0xbe, 0xd2, 0xab, 0x5e, 0x91, 0x70, 0xd9, 0xed,
	0xd2, 0x59, 0x5f, 0xba, 0x5e, 0x6a, 0x45, 0x49, 0x7f, 0x4a, 0x9c, 0x55, 0x9a, 0xb8, 0xf7, 0x96,
	0x1b, 0x0c, 0xc5, 0x0e, 0xd3, 0xb4, 0x43, 0x01, 0xb0, 0xbb, 0x30, 0xed, 0x8c, 0x5c, 0xdf, 0xdf,
	0xf0, 0xbd, 0x60, 0x88, 0xd9, 0xcd, 0xd0, 0xec, 0x2a, 0x88, 0x25, 0xb0, 0xe1, 0x1d, 0xe5, 0x31,
	0xb3, 0xa2, 0x04, 0x4a, 0x50, 0xce, 0x8a, 0x93, 0xba, 0x71, 0xda, 0xd7, 0x4a, 0xac, 0x10, 0x42,
	0xfb, 0x1c, 0x87, 0xa7, 0x45, 0x26, 0x73, 0xd4, 0x20, 0xaa, 0xa0, 0xfe, 0x4f, 0xea, 0xc9, 0xe2,
	0x4c, 0x42, 0xf6, 0xab, 0x99, 0x36, 0xa8, 0x26, 0x26, 0x93, 0x20, 0x23, 0x74, 0xbd, 0x34, 0x9b,
	0xb4, 0x7e, 0x59, 0x4f, 0xfa, 0xbf, 0xa1, 0x69, 0x1a, 0x8e, 0x15, 0x49, 0x81, 0x28, 0x57, 0x0b,
	0x64, 0x72, 0x4b, 0xfa, 0x5e, 0x81, 0xa6, 0x63, 0x98, 0x56, 0x34, 0x41, 0xab, 0xbf, 0x83, 0x3a,
	0xf2, 0xaf, 0x4e, 0x5e, 0x13, 0x7d, 0x85, 0xea, 0xea, 0x9f, 0xa8, 0xba, 0xc6, 0xb5, 0xaa, 0x6b,
	0x5e, 0xaf, 0xba, 0xd6, 0x04, 0xd5, 0xed, 0x53, 0x47, 0xce, 0x8a, 0x44, 0x13, 0xa9, 0xcb, 0xc3,
	0x20, 0x72, 0x17, 0xa6, 0x9f, 0x7b, 0x81, 0xed, 0x7a, 0x09, 0x2f, 0xd3, 0x50, 0x05, 0xb1, 0xb8,
	0x4c, 0xd7, 0xf7, 0x45, 0x84, 0xd0, 0x60, 0x01, 0xe8, 0xdf, 0x2a, 0x30, 0x85, 0xdd, 0xd3, 0x1d,
	0x71, 0x51, 0x05, 0x57, 0xf5, 0xcd, 0xab, 0x54, 0x5e, 0xd1, 0x69, 0x7d, 0x82, 0x4e, 0x0b, 0x55,
	0x35, 0x2e, 0xaa, 0x0a, 0x2b, 0x92, 0x9f, 0x66, 0x12, 0x6a, 0x52, 0xe1, 0x97, 0x10, 0xfd, 0x05,
	0x4c, 0x89, 0xa1, 0x93, 0xba, 0x27, 0x3c, 0xb9, 0xe9, 0xa3, 0x84, 0xeb, 0x12, 0x91, 0xe5, 0x33,
	0x97, 0x10, 0xfd, 0x3e, 0xbd, 0xc7, 0xd8, 0x2a, 0xac, 0x57, 0x3c, 0xde, 0xe0, 0x87, 0x61, 0x4c,
	0xa9, 0x3e, 0x76, 0x63, 0xff, 0x0c, 0x21, 0xf9, 0x36, 0x16, 0x80, 0x7e, 0x0a, 0xbd, 0xd2, 0x94,
	0x6a, 0xff, 0x51, 0x2e, 0xf6, 0x9f, 0x52, 0x57, 0x53, 0xab, 0x5d, 0xed, 0xcf, 0xd0, 0x12, 0x67,
	0xe9, 0xd7, 0xa9, 0x61, 0xf4, 0x2f, 0x6b, 0x45, 0xf8, 0x6d, 0x19, 0xa7, 0xaf, 0xd1, 0xfd, 0x50,
	0xdf, 0xa2, 0x9d, 0xab, 0xbd, 0x4d, 0xb9, 0xd8, 0xdb, 0x74, 0x87, 0xe2, 0x91, 0x63, 0xd1, 0x3d,
	0xfe, 0x08, 0x8d, 0xbd, 0xb3, 0x88, 0x4b, 0x19, 0xdd, 0x2e, 0xef, 0x97, 0x07, 0x61, 0x80, 0x4d,
	0x61, 0x45, 0xa3, 0x53, 0x4b, 0x8d, 0x4e, 0xff, 0x2b, 0xf4, 0x44, 0x72, 0x62, 0xcd, 0x89, 0xf7,
	0x30, 0x61, 0xda, 0xbf, 0x28, 0x17, 0xec, 0x1f, 0x59, 0x2e, 0x32, 0x4a, 0xa1, 0xc3, 0x2f, 0x5d,
	0x3e, 0x3c, 0xb9, 0xb3, 0xe9, 0x6f, 0x94, 0xfc, 0xfe, 0x79, 0x9a, 0xfa, 0x13, 0x7a, 0x05, 0xfb,
	0x83, 0x3c, 0x9d, 0x10, 0xf4, 0x42, 0x79, 0x41, 0x5c, 0x03, 0x7d, 0xc9, 0xc5, 0x93, 0xd5, 0xcb,
	0x2d, 0xbc, 0x5a, 0x2a, 0x8d, 0x8b, 0xa5, 0xc2, 0xee, 0x40, 0xe7, 0x65, 0x26, 0x70, 0x21, 0xe1,
	0xdc, 0xd6, 0x1f, 0x42, 0x17, 0x8f, 0x27, 0x72, 0x33, 0xa0, 0x2d, 0x46, 0xd9, 0xe9, 0x26, 0x5d,
	0x2d, 0x05, 0xd8, 0x59, 0xa0, 0xfe, 0x46, 0x85, 0x0e, 0xc9, 0x28, 0x38, 0x0c, 0xf1, 0x70, 0x2f,
	0xbd, 0x40, 0x7e, 0xa9, 0xe2, 0x10, 0x25, 0x27, 0x8b, 0x45, 0xe4, 0x25, 0x2d, 0x2c, 0x3e, 0xd2,
	0xf7, 0xa6, 0xef, 0x1e, 0x65, 0x4f, 0x63, 0x0e, 0x60, 0xc6, 0x9b, 0xa1, 0x3f, 0x24, 0xa7, 0xe8,
	0x2a, 0xb9, 0x8d, 0x1d, 0x0b, 0xa5, 0x6f, 0xc5, 0x14, 0x4e, 0x2f, 0x63, 0xc7, 0x2e, 0x43, 0xa2,
	0x5b, 0xc4, 0xc3, 0x17, 0xae, 0x3f, 0xe6, 0xf2, 0x7d, 0x2c, 0x80, 0x82, 0xc3, 0x6e, 0x99, 0xc3,
	0xfb, 0xd0, 0xc9, 0xc8, 0xee, 0xc3, 0x75, 0x17, 0x91, 0x87, 0x61, 0xeb, 0x22, 0x92, 0x37, 0xb8,
	0xfc, 0xd0, 0xed, 0x89, 0xd6, 0x55, 0x01, 0xf5, 0x2f, 0x15, 0x52, 0x1d, 0x52, 0x44, 0xb5, 0xff,
	0xa9, 0xbd, 0xe9, 0x0e, 0x74, 0x04, 0xf1, 0xdb, 0x43, 0xe2, 0xb5, 0x6e, 0xe7, 0x36, 0x5b, 0x81,
	0x06, 0xd2, 0x4e, 0xd4, 0xf6, 0x8c, 0xf9, 0x72, 0xc2, 0xd9, 0x95, 0xd8, 0x14, 0xa1, 0x4f, 0x01,
	0x98, 0x86, 0xe3, 0xa4, 0x6e, 0x30, 0xfc, 0x5f, 0xa4, 0xff, 0x9e, 0x9a, 0xb2, 0xb4, 0xae, 0xf9,
	0x9c, 0x1e, 0x88, 0x59, 0x5e, 0xfa, 0x28, 0x3c, 0x0d, 0x26, 0xbc, 0x72, 0x7f, 0x17, 0xeb, 0x5c,
	0xe5, 0x2f, 0xaf, 0xac, 0x56, 0x57, 0xee, 0x42, 0xdb, 0x34, 0x9c, 0x3d, 0x2f, 0x4a, 0x74, 0x0f,
	0xda, 0xf8, 0x59, 0xe6, 0x45, 0x37, 0xef, 0x8d, 0x95, 0xbf, 0x17, 0xf5, 0x0b, 0x7f, 0x2f, 0xca,
	0xbb, 0x36, 0xaa, 0xbb, 0xfe, 0x2d, 0xbf, 0x8a, 0xa7, 0xde, 0xc1, 0x09, 0xd2, 0x57, 0x6a, 0x2b,
	0x15, 0xfa, 0xd0, 0x5f, 0x74, 0x94, 0xd5, 0x27, 0xd0, 0x2b, 0x7d, 0xfb, 0x33, 0x0d, 0xa6, 0xc8,
	0x94, 0xeb, 0x6a, 0x35, 0x36, 0x0d, 0x5d, 0x42, 0x36, 0x5d, 0xcf, 0xd7, 0x14, 0xb6, 0x04, 0xb7,
	0xc8, 0xcc, 0xff, 0x29, 0x51, 0x66, 0x9a, 0xba, 0xfa, 0x19, 0x3d, 0x80, 0xac, 0x87, 0x6f, 0x6a,
	0xb2, 0x13, 0x06, 0x5c, 0xab, 0x49, 0x03, 0xeb, 0x5b, 0x53, 0xd8, 0x14, 0x74, 0xac, 0x28, 0xa1,
	0xcf, 0x76, 0x4d, 0x95, 0x2e, 0xac, 0x6d, 0xad, 0x21, 0x5d, 0x54, 0xe2, 0x5a, 0x47, 0x5a, 0xeb,
	0xbe, 0xbf, 0x1d, 0x68, 0x1a, 0x63, 0x30, 0x93, 0x4d, 0xb3, 0x62, 0x5a, 0x6a, 0x99, 0xcd, 0x00,
	0xc8, 0xc9, 0xeb, 0xc1, 0x99, 0xf6, 0x9f, 0xd5, 0x2f, 0x14, 0xd2, 0x62, 0xca, 0xf1, 0x2f, 0x28,
	0x88, 0x91, 0x4c, 0xe1, 0x16, 0xcc, 0x0a, 0xdb, 0x8a, 0x78, 0xec, 0xa6, 0x5e, 0x70, 0xa4, 0x29,
	0x45, 0x10, 0xbe, 0xde, 0x9a, 0xca, 0x66, 0xa1, 0x27, 0xec, 0x75, 0xdf, 0xf7, 0x02, 0xad, 0x5e,
	0x04, 0xd0, 0x86, 0x0d, 0x24, 0x41, 0x4e, 0xf0, 0x02, 0xad, 0x89, 0x39, 0x15, 0xf3, 0x91, 0x74,
	0xad, 0xb5, 0xfa, 0x10, 0xa6, 0x2b, 0x1d, 0x9b, 0x2d, 0xc0, 0x5c, 0x05, 0xd8, 0x0a, 0x7d, 0x4c,
	0x68, 0x09, 0x6e, 0x55, 0xe0, 0xdd, 0xf1, 0xbe, 0xef, 0x1d, 0x68, 0xca, 0xea, 0xd7, 0xaa, 0x10,
	0x37, 0x89, 0x91, 0xcd, 0xc1, 0x74, 0x6e, 0xc8, 0xa3, 0x2c, 0xc0, 0x5c, 0x0e, 0x6d, 0x79, 0x47,
	0xc7, 0x68, 0x68, 0x0a, 0x9b, 0x07, 0x2d, 0x87, 0xad, 0x80, 0xef, 0xba, 0x5e, 0xac, 0xa9, 0x15,
	0x74, 0xef, 0x34, 0x24, 0xb4, 0xce, 0x6e, 0xc3, 0x42, 0x81, 0x1e, 0xc7, 0x9c, 0x5b, 0x87, 0xeb,
	0x4f, 0xbd, 0x00, 0x8f, 0x58, 0x5e, 0xdd, 0x49, 0x63, 0xd7, 0x3b, 0x3a, 0x4e, 0xc5, 0x51, 0x73,
	0x78, 0xd3, 0x1f, 0x27, 0xc7, 0x5a, 0x8b, 0x2d, 0x02, 0x2b, 0xb0, 0xb1, 0xef, 0x6f, 0x85, 0xe3,
	0x84, 0x6b, 0x6d, 0xd6, 0x87, 0xf9, 0x02, 0x0f, 0xc7, 0x71, 0xb6, 0x78, 0x87, 0xdd, 0x81, 0xc5,
	0x4b, 0x8b, 0x8b, 0xd5, 0xba, 0x48, 0x48, 0xd1, 0x83, 0xc2, 0x33, 0xd7, 0x17, 0x0e, 0x58, 0x5d,
	0x84, 0x4e, 0x56, 0xac, 0x0c, 0xa0, 0x65, 0xfa, 0x61, 0xc2, 0x87, 0x5a, 0x6d, 0xe3, 0xc1, 0xdb,
	0xf7, 0x83, 0xda, 0xbb, 0xf7, 0x83, 0xda, 0xc7, 0xf7, 0x03, 0xe5, 0xf3, 0xf3, 0x81, 0xf2, 0xdd,
	0xf9, 0x40, 0xf9, 0xe1, 0x7c, 0xa0, 0xbc, 0x3d, 0x1f, 0x28, 0x3f, 0x9e, 0x0f, 0x94, 0x9f, 0xce,
	0x07, 0xb5, 0x8f, 0xe7, 0x03, 0xe5, 0x9b, 0x0f, 0x83, 0xda, 0xdb, 0x0f, 0x83, 0xda, 0xbb, 0x0f,
	0x83, 0xda, 0x7e, 0x8b, 0x34, 0xf0, 0x97, 0x5f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xfa, 0x2d, 0x34,
	0xb3, 0x3c, 0x11, 0x00, 0x00,
}

func (x EnterResult) String() string {
	s, ok := EnterResult_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Ops) String() string {
	s, ok := Ops_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x States) String() string {
	s, ok := States_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DealCardsType) String() string {
	s, ok := DealCardsType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CardTypes) String() string {
	s, ok := CardTypes_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x KickType) String() string {
	s, ok := KickType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *C2SRoomOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SRoomOptions)
	if !ok {
		that2, ok := that.(C2SRoomOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AutoBuy != that1.AutoBuy {
		return false
	}
	if this.AutoBuyMax != that1.AutoBuyMax {
		return false
	}
	if this.Buy != that1.Buy {
		return false
	}
	return true
}
func (this *S2CRoomOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CRoomOptions)
	if !ok {
		that2, ok := that.(S2CRoomOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AutoBuy != that1.AutoBuy {
		return false
	}
	if this.AutoBuyMax != that1.AutoBuyMax {
		return false
	}
	if this.Buy != that1.Buy {
		return false
	}
	return true
}
func (this *C2SEnter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SEnter)
	if !ok {
		that2, ok := that.(C2SEnter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	if this.Buy != that1.Buy {
		return false
	}
	if this.NumOfPlayers != that1.NumOfPlayers {
		return false
	}
	return true
}
func (this *S2CMoneyNotEnough) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CMoneyNotEnough)
	if !ok {
		that2, ok := that.(S2CMoneyNotEnough)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	if this.LeftMoney != that1.LeftMoney {
		return false
	}
	return true
}
func (this *C2SBuy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SBuy)
	if !ok {
		that2, ok := that.(C2SBuy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Buy != that1.Buy {
		return false
	}
	if this.AutoBuy != that1.AutoBuy {
		return false
	}
	return true
}
func (this *S2CBuy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CBuy)
	if !ok {
		that2, ok := that.(S2CBuy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *S2CAutoBuy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CAutoBuy)
	if !ok {
		that2, ok := that.(S2CAutoBuy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	if this.Money != that1.Money {
		return false
	}
	return true
}
func (this *S2CEnter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CEnter)
	if !ok {
		that2, ok := that.(S2CEnter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	return true
}
func (this *C2SLeave) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SLeave)
	if !ok {
		that2, ok := that.(C2SLeave)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *S2CLeave) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CLeave)
	if !ok {
		that2, ok := that.(S2CLeave)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *C2SGetNumOfPlayers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SGetNumOfPlayers)
	if !ok {
		that2, ok := that.(C2SGetNumOfPlayers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	return true
}
func (this *S2CGetNumOfPlayers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CGetNumOfPlayers)
	if !ok {
		that2, ok := that.(S2CGetNumOfPlayers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	if this.NumOfPlayers != that1.NumOfPlayers {
		return false
	}
	return true
}
func (this *C2SCheckEnter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SCheckEnter)
	if !ok {
		that2, ok := that.(C2SCheckEnter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Player) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Player)
	if !ok {
		that2, ok := that.(Player)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Head != that1.Head {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.RemainMoney != that1.RemainMoney {
		return false
	}
	if this.OpMoney != that1.OpMoney {
		return false
	}
	if this.TotalOpMoney != that1.TotalOpMoney {
		return false
	}
	return true
}
func (this *S2CTable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CTable)
	if !ok {
		that2, ok := that.(S2CTable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	if this.NumOfPlayers != that1.NumOfPlayers {
		return false
	}
	if this.Jackpot != that1.Jackpot {
		return false
	}
	if this.NumOfGame != that1.NumOfGame {
		return false
	}
	if this.NumOfLoop != that1.NumOfLoop {
		return false
	}
	if this.NumOfRound != that1.NumOfRound {
		return false
	}
	if this.OpCd != that1.OpCd {
		return false
	}
	if this.DealerIdx != that1.DealerIdx {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if len(this.Players) != len(that1.Players) {
		return false
	}
	for i := range this.Players {
		if !this.Players[i].Equal(that1.Players[i]) {
			return false
		}
	}
	if this.WaitOps != that1.WaitOps {
		return false
	}
	if len(this.HandCards) != len(that1.HandCards) {
		return false
	}
	for i := range this.HandCards {
		if this.HandCards[i] != that1.HandCards[i] {
			return false
		}
	}
	if this.SmallBlindIdx != that1.SmallBlindIdx {
		return false
	}
	if this.BigBlindIdx != that1.BigBlindIdx {
		return false
	}
	if this.NumOfStart != that1.NumOfStart {
		return false
	}
	if this.ShowHandCards != that1.ShowHandCards {
		return false
	}
	return true
}
func (this *S2CPlayerEnter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CPlayerEnter)
	if !ok {
		that2, ok := that.(S2CPlayerEnter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Player.Equal(that1.Player) {
		return false
	}
	return true
}
func (this *S2CPlayerLeave) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CPlayerLeave)
	if !ok {
		that2, ok := that.(S2CPlayerLeave)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	return true
}
func (this *C2SOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SOp)
	if !ok {
		that2, ok := that.(C2SOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.Money != that1.Money {
		return false
	}
	return true
}
func (this *S2COp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2COp)
	if !ok {
		that2, ok := that.(S2COp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	if this.Ops != that1.Ops {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.RemainMoney != that1.RemainMoney {
		return false
	}
	if this.OpMoney != that1.OpMoney {
		return false
	}
	if this.TotalOpMoney != that1.TotalOpMoney {
		return false
	}
	return true
}
func (this *S2CWaitOps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CWaitOps)
	if !ok {
		that2, ok := that.(S2CWaitOps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ops != that1.Ops {
		return false
	}
	if this.MinRaiseMoney != that1.MinRaiseMoney {
		return false
	}
	if this.CallMoney != that1.CallMoney {
		return false
	}
	return true
}
func (this *S2CGameStart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CGameStart)
	if !ok {
		that2, ok := that.(S2CGameStart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	if this.NumOfGame != that1.NumOfGame {
		return false
	}
	if this.DealerIdx != that1.DealerIdx {
		return false
	}
	if len(this.NewPlayers) != len(that1.NewPlayers) {
		return false
	}
	for i := range this.NewPlayers {
		if this.NewPlayers[i] != that1.NewPlayers[i] {
			return false
		}
	}
	return true
}
func (this *PlayerStakes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerStakes)
	if !ok {
		that2, ok := that.(PlayerStakes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	if this.Money != that1.Money {
		return false
	}
	if this.TotalMoney != that1.TotalMoney {
		return false
	}
	return true
}
func (this *S2CLoopOverBefore) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CLoopOverBefore)
	if !ok {
		that2, ok := that.(S2CLoopOverBefore)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EarlyOver != that1.EarlyOver {
		return false
	}
	return true
}
func (this *S2CLoopOver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CLoopOver)
	if !ok {
		that2, ok := that.(S2CLoopOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumOfLoop != that1.NumOfLoop {
		return false
	}
	if this.Jackpot != that1.Jackpot {
		return false
	}
	if len(this.Stakes) != len(that1.Stakes) {
		return false
	}
	for i := range this.Stakes {
		if !this.Stakes[i].Equal(that1.Stakes[i]) {
			return false
		}
	}
	return true
}
func (this *S2CRoundOver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CRoundOver)
	if !ok {
		that2, ok := that.(S2CRoundOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumOfRound != that1.NumOfRound {
		return false
	}
	return true
}
func (this *S2CDealCards) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CDealCards)
	if !ok {
		that2, ok := that.(S2CDealCards)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	return true
}
func (this *PlayerCards) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerCards)
	if !ok {
		that2, ok := that.(PlayerCards)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	return true
}
func (this *S2CShowCards) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CShowCards)
	if !ok {
		that2, ok := that.(S2CShowCards)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if !this.Cards[i].Equal(that1.Cards[i]) {
			return false
		}
	}
	return true
}
func (this *PlayerSettle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerSettle)
	if !ok {
		that2, ok := that.(PlayerSettle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.TotalMoney != that1.TotalMoney {
		return false
	}
	if this.WinMoney != that1.WinMoney {
		return false
	}
	return true
}
func (this *S2CSettle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CSettle)
	if !ok {
		that2, ok := that.(S2CSettle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Settles) != len(that1.Settles) {
		return false
	}
	for i := range this.Settles {
		if !this.Settles[i].Equal(that1.Settles[i]) {
			return false
		}
	}
	return true
}
func (this *GameInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GameInfo)
	if !ok {
		that2, ok := that.(GameInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Win != that1.Win {
		return false
	}
	if this.Stakes != that1.Stakes {
		return false
	}
	if this.RaiseFlag != that1.RaiseFlag {
		return false
	}
	if this.FoldFlag != that1.FoldFlag {
		return false
	}
	if this.CallOrRaise != that1.CallOrRaise {
		return false
	}
	if this.CardValue != that1.CardValue {
		return false
	}
	if len(this.Cards) != len(that1.Cards) {
		return false
	}
	for i := range this.Cards {
		if this.Cards[i] != that1.Cards[i] {
			return false
		}
	}
	if this.CardType != that1.CardType {
		return false
	}
	if this.TotalBetMoney != that1.TotalBetMoney {
		return false
	}
	return true
}
func (this *S2CGameOver) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CGameOver)
	if !ok {
		that2, ok := that.(S2CGameOver)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoomId != that1.RoomId {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	if this.PlayerId != that1.PlayerId {
		return false
	}
	if !this.Info.Equal(that1.Info) {
		return false
	}
	return true
}
func (this *C2SStandUp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SStandUp)
	if !ok {
		that2, ok := that.(C2SStandUp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *S2CStandUp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CStandUp)
	if !ok {
		that2, ok := that.(S2CStandUp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *C2SSitDown) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2SSitDown)
	if !ok {
		that2, ok := that.(C2SSitDown)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	return true
}
func (this *S2CSitDown) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CSitDown)
	if !ok {
		that2, ok := that.(S2CSitDown)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *C2STips) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*C2STips)
	if !ok {
		that2, ok := that.(C2STips)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *S2CTips) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CTips)
	if !ok {
		that2, ok := that.(S2CTips)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Idx != that1.Idx {
		return false
	}
	if this.Money != that1.Money {
		return false
	}
	if this.LeftMoney != that1.LeftMoney {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	return true
}
func (this *S2CGameKick) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*S2CGameKick)
	if !ok {
		that2, ok := that.(S2CGameKick)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *C2SRoomOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto_game.C2SRoomOptions{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "AutoBuy: "+fmt.Sprintf("%#v", this.AutoBuy)+",\n")
	s = append(s, "AutoBuyMax: "+fmt.Sprintf("%#v", this.AutoBuyMax)+",\n")
	s = append(s, "Buy: "+fmt.Sprintf("%#v", this.Buy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CRoomOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto_game.S2CRoomOptions{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "AutoBuy: "+fmt.Sprintf("%#v", this.AutoBuy)+",\n")
	s = append(s, "AutoBuyMax: "+fmt.Sprintf("%#v", this.AutoBuyMax)+",\n")
	s = append(s, "Buy: "+fmt.Sprintf("%#v", this.Buy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SEnter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto_game.C2SEnter{")
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	s = append(s, "Buy: "+fmt.Sprintf("%#v", this.Buy)+",\n")
	s = append(s, "NumOfPlayers: "+fmt.Sprintf("%#v", this.NumOfPlayers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CMoneyNotEnough) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_game.S2CMoneyNotEnough{")
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	s = append(s, "LeftMoney: "+fmt.Sprintf("%#v", this.LeftMoney)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SBuy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_game.C2SBuy{")
	s = append(s, "Buy: "+fmt.Sprintf("%#v", this.Buy)+",\n")
	s = append(s, "AutoBuy: "+fmt.Sprintf("%#v", this.AutoBuy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CBuy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CBuy{")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CAutoBuy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_game.S2CAutoBuy{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "Money: "+fmt.Sprintf("%#v", this.Money)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CEnter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CEnter{")
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SLeave) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_game.C2SLeave{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CLeave) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_game.S2CLeave{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SGetNumOfPlayers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.C2SGetNumOfPlayers{")
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CGetNumOfPlayers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_game.S2CGetNumOfPlayers{")
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	s = append(s, "NumOfPlayers: "+fmt.Sprintf("%#v", this.NumOfPlayers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SCheckEnter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_game.C2SCheckEnter{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Player) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&proto_game.Player{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Head: "+fmt.Sprintf("%#v", this.Head)+",\n")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "RemainMoney: "+fmt.Sprintf("%#v", this.RemainMoney)+",\n")
	s = append(s, "OpMoney: "+fmt.Sprintf("%#v", this.OpMoney)+",\n")
	s = append(s, "TotalOpMoney: "+fmt.Sprintf("%#v", this.TotalOpMoney)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CTable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&proto_game.S2CTable{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "NumOfPlayers: "+fmt.Sprintf("%#v", this.NumOfPlayers)+",\n")
	s = append(s, "Jackpot: "+fmt.Sprintf("%#v", this.Jackpot)+",\n")
	s = append(s, "NumOfGame: "+fmt.Sprintf("%#v", this.NumOfGame)+",\n")
	s = append(s, "NumOfLoop: "+fmt.Sprintf("%#v", this.NumOfLoop)+",\n")
	s = append(s, "NumOfRound: "+fmt.Sprintf("%#v", this.NumOfRound)+",\n")
	s = append(s, "OpCd: "+fmt.Sprintf("%#v", this.OpCd)+",\n")
	s = append(s, "DealerIdx: "+fmt.Sprintf("%#v", this.DealerIdx)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	if this.Players != nil {
		s = append(s, "Players: "+fmt.Sprintf("%#v", this.Players)+",\n")
	}
	s = append(s, "WaitOps: "+fmt.Sprintf("%#v", this.WaitOps)+",\n")
	s = append(s, "HandCards: "+fmt.Sprintf("%#v", this.HandCards)+",\n")
	s = append(s, "SmallBlindIdx: "+fmt.Sprintf("%#v", this.SmallBlindIdx)+",\n")
	s = append(s, "BigBlindIdx: "+fmt.Sprintf("%#v", this.BigBlindIdx)+",\n")
	s = append(s, "NumOfStart: "+fmt.Sprintf("%#v", this.NumOfStart)+",\n")
	s = append(s, "ShowHandCards: "+fmt.Sprintf("%#v", this.ShowHandCards)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CPlayerEnter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CPlayerEnter{")
	if this.Player != nil {
		s = append(s, "Player: "+fmt.Sprintf("%#v", this.Player)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CPlayerLeave) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CPlayerLeave{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_game.C2SOp{")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "Money: "+fmt.Sprintf("%#v", this.Money)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2COp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&proto_game.S2COp{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "Ops: "+fmt.Sprintf("%#v", this.Ops)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "RemainMoney: "+fmt.Sprintf("%#v", this.RemainMoney)+",\n")
	s = append(s, "OpMoney: "+fmt.Sprintf("%#v", this.OpMoney)+",\n")
	s = append(s, "TotalOpMoney: "+fmt.Sprintf("%#v", this.TotalOpMoney)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CWaitOps) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto_game.S2CWaitOps{")
	s = append(s, "Ops: "+fmt.Sprintf("%#v", this.Ops)+",\n")
	s = append(s, "MinRaiseMoney: "+fmt.Sprintf("%#v", this.MinRaiseMoney)+",\n")
	s = append(s, "CallMoney: "+fmt.Sprintf("%#v", this.CallMoney)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CGameStart) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto_game.S2CGameStart{")
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "NumOfGame: "+fmt.Sprintf("%#v", this.NumOfGame)+",\n")
	s = append(s, "DealerIdx: "+fmt.Sprintf("%#v", this.DealerIdx)+",\n")
	s = append(s, "NewPlayers: "+fmt.Sprintf("%#v", this.NewPlayers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlayerStakes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto_game.PlayerStakes{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "Money: "+fmt.Sprintf("%#v", this.Money)+",\n")
	s = append(s, "TotalMoney: "+fmt.Sprintf("%#v", this.TotalMoney)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CLoopOverBefore) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CLoopOverBefore{")
	s = append(s, "EarlyOver: "+fmt.Sprintf("%#v", this.EarlyOver)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CLoopOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&proto_game.S2CLoopOver{")
	s = append(s, "NumOfLoop: "+fmt.Sprintf("%#v", this.NumOfLoop)+",\n")
	s = append(s, "Jackpot: "+fmt.Sprintf("%#v", this.Jackpot)+",\n")
	if this.Stakes != nil {
		s = append(s, "Stakes: "+fmt.Sprintf("%#v", this.Stakes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CRoundOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CRoundOver{")
	s = append(s, "NumOfRound: "+fmt.Sprintf("%#v", this.NumOfRound)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CDealCards) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_game.S2CDealCards{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlayerCards) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_game.PlayerCards{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CShowCards) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CShowCards{")
	if this.Cards != nil {
		s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlayerSettle) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&proto_game.PlayerSettle{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "TotalMoney: "+fmt.Sprintf("%#v", this.TotalMoney)+",\n")
	s = append(s, "WinMoney: "+fmt.Sprintf("%#v", this.WinMoney)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CSettle) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CSettle{")
	if this.Settles != nil {
		s = append(s, "Settles: "+fmt.Sprintf("%#v", this.Settles)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GameInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&proto_game.GameInfo{")
	s = append(s, "Win: "+fmt.Sprintf("%#v", this.Win)+",\n")
	s = append(s, "Stakes: "+fmt.Sprintf("%#v", this.Stakes)+",\n")
	s = append(s, "RaiseFlag: "+fmt.Sprintf("%#v", this.RaiseFlag)+",\n")
	s = append(s, "FoldFlag: "+fmt.Sprintf("%#v", this.FoldFlag)+",\n")
	s = append(s, "CallOrRaise: "+fmt.Sprintf("%#v", this.CallOrRaise)+",\n")
	s = append(s, "CardValue: "+fmt.Sprintf("%#v", this.CardValue)+",\n")
	s = append(s, "Cards: "+fmt.Sprintf("%#v", this.Cards)+",\n")
	s = append(s, "CardType: "+fmt.Sprintf("%#v", this.CardType)+",\n")
	s = append(s, "TotalBetMoney: "+fmt.Sprintf("%#v", this.TotalBetMoney)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CGameOver) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto_game.S2CGameOver{")
	s = append(s, "RoomId: "+fmt.Sprintf("%#v", this.RoomId)+",\n")
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "PlayerId: "+fmt.Sprintf("%#v", this.PlayerId)+",\n")
	if this.Info != nil {
		s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SStandUp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_game.C2SStandUp{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CStandUp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CStandUp{")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2SSitDown) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.C2SSitDown{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CSitDown) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto_game.S2CSitDown{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *C2STips) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&proto_game.C2STips{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CTips) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto_game.S2CTips{")
	s = append(s, "Idx: "+fmt.Sprintf("%#v", this.Idx)+",\n")
	s = append(s, "Money: "+fmt.Sprintf("%#v", this.Money)+",\n")
	s = append(s, "LeftMoney: "+fmt.Sprintf("%#v", this.LeftMoney)+",\n")
	s = append(s, "Success: "+fmt.Sprintf("%#v", this.Success)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *S2CGameKick) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto_game.S2CGameKick{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringGame(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *C2SRoomOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SRoomOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SRoomOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Buy != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Buy))
		i--
		dAtA[i] = 0x20
	}
	if m.AutoBuyMax {
		i--
		if m.AutoBuyMax {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AutoBuy {
		i--
		if m.AutoBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CRoomOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CRoomOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CRoomOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Buy != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Buy))
		i--
		dAtA[i] = 0x20
	}
	if m.AutoBuyMax {
		i--
		if m.AutoBuyMax {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AutoBuy {
		i--
		if m.AutoBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SEnter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SEnter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SEnter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumOfPlayers != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfPlayers))
		i--
		dAtA[i] = 0x18
	}
	if m.Buy != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Buy))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CMoneyNotEnough) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CMoneyNotEnough) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CMoneyNotEnough) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeftMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.LeftMoney))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SBuy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SBuy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SBuy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AutoBuy {
		i--
		if m.AutoBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Buy != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Buy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CBuy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CBuy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CBuy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CAutoBuy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CAutoBuy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CAutoBuy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Money != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CEnter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CEnter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CEnter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SLeave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SLeave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SLeave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *S2CLeave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CLeave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CLeave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *C2SGetNumOfPlayers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SGetNumOfPlayers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SGetNumOfPlayers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CGetNumOfPlayers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGetNumOfPlayers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CGetNumOfPlayers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumOfPlayers != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfPlayers))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SCheckEnter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SCheckEnter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SCheckEnter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Player) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalOpMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.TotalOpMoney))
		i--
		dAtA[i] = 0x48
	}
	if m.OpMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.OpMoney))
		i--
		dAtA[i] = 0x40
	}
	if m.RemainMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.RemainMoney))
		i--
		dAtA[i] = 0x38
	}
	if m.State != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if m.Op != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Head) > 0 {
		i -= len(m.Head)
		copy(dAtA[i:], m.Head)
		i = encodeVarintGame(dAtA, i, uint64(len(m.Head)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGame(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShowHandCards {
		i--
		if m.ShowHandCards {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.NumOfStart != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfStart))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.BigBlindIdx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.BigBlindIdx))
		i--
		dAtA[i] = 0x78
	}
	if m.SmallBlindIdx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.SmallBlindIdx))
		i--
		dAtA[i] = 0x70
	}
	if len(m.HandCards) > 0 {
		dAtA2 := make([]byte, len(m.HandCards)*10)
		var j1 int
		for _, num1 := range m.HandCards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintGame(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x6a
	}
	if m.WaitOps != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.WaitOps))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Cards) > 0 {
		dAtA4 := make([]byte, len(m.Cards)*10)
		var j3 int
		for _, num1 := range m.Cards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintGame(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x52
	}
	if m.DealerIdx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.DealerIdx))
		i--
		dAtA[i] = 0x48
	}
	if m.OpCd != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.OpCd))
		i--
		dAtA[i] = 0x40
	}
	if m.NumOfRound != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfRound))
		i--
		dAtA[i] = 0x38
	}
	if m.NumOfLoop != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfLoop))
		i--
		dAtA[i] = 0x30
	}
	if m.NumOfGame != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfGame))
		i--
		dAtA[i] = 0x28
	}
	if m.Jackpot != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Jackpot))
		i--
		dAtA[i] = 0x20
	}
	if m.NumOfPlayers != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfPlayers))
		i--
		dAtA[i] = 0x18
	}
	if m.GameId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CPlayerEnter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CPlayerEnter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CPlayerEnter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Player != nil {
		{
			size, err := m.Player.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CPlayerLeave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CPlayerLeave) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CPlayerLeave) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SOp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SOp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Money != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x10
	}
	if m.Op != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2COp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2COp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2COp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalOpMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.TotalOpMoney))
		i--
		dAtA[i] = 0x30
	}
	if m.OpMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.OpMoney))
		i--
		dAtA[i] = 0x28
	}
	if m.RemainMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.RemainMoney))
		i--
		dAtA[i] = 0x20
	}
	if m.State != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.Ops != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Ops))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CWaitOps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CWaitOps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CWaitOps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CallMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.CallMoney))
		i--
		dAtA[i] = 0x18
	}
	if m.MinRaiseMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.MinRaiseMoney))
		i--
		dAtA[i] = 0x10
	}
	if m.Ops != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Ops))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CGameStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGameStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CGameStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewPlayers) > 0 {
		dAtA7 := make([]byte, len(m.NewPlayers)*10)
		var j6 int
		for _, num1 := range m.NewPlayers {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintGame(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x2a
	}
	if m.DealerIdx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.DealerIdx))
		i--
		dAtA[i] = 0x20
	}
	if m.NumOfGame != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfGame))
		i--
		dAtA[i] = 0x18
	}
	if m.GameId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayerStakes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerStakes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerStakes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.TotalMoney))
		i--
		dAtA[i] = 0x18
	}
	if m.Money != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CLoopOverBefore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CLoopOverBefore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CLoopOverBefore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EarlyOver {
		i--
		if m.EarlyOver {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CLoopOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CLoopOver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CLoopOver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Stakes) > 0 {
		for iNdEx := len(m.Stakes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stakes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Jackpot != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Jackpot))
		i--
		dAtA[i] = 0x10
	}
	if m.NumOfLoop != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfLoop))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CRoundOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CRoundOver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CRoundOver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumOfRound != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.NumOfRound))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CDealCards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CDealCards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CDealCards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		dAtA9 := make([]byte, len(m.Cards)*10)
		var j8 int
		for _, num1 := range m.Cards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintGame(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayerCards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerCards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerCards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		dAtA11 := make([]byte, len(m.Cards)*10)
		var j10 int
		for _, num1 := range m.Cards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintGame(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0x12
	}
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CShowCards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CShowCards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CShowCards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for iNdEx := len(m.Cards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PlayerSettle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerSettle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerSettle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WinMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.WinMoney))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.TotalMoney))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Cards) > 0 {
		dAtA13 := make([]byte, len(m.Cards)*10)
		var j12 int
		for _, num1 := range m.Cards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintGame(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CSettle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CSettle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CSettle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Settles) > 0 {
		for iNdEx := len(m.Settles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Settles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGame(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GameInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalBetMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.TotalBetMoney))
		i--
		dAtA[i] = 0x58
	}
	if m.CardType != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.CardType))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Cards) > 0 {
		dAtA15 := make([]byte, len(m.Cards)*10)
		var j14 int
		for _, num1 := range m.Cards {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintGame(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0x4a
	}
	if m.CardValue != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.CardValue))
		i--
		dAtA[i] = 0x40
	}
	if m.CallOrRaise {
		i--
		if m.CallOrRaise {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.FoldFlag != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.FoldFlag))
		i--
		dAtA[i] = 0x30
	}
	if m.RaiseFlag != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.RaiseFlag))
		i--
		dAtA[i] = 0x28
	}
	if m.Stakes != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Stakes))
		i--
		dAtA[i] = 0x20
	}
	if m.Win {
		i--
		if m.Win {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *S2CGameOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGameOver) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CGameOver) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PlayerId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerId))
		i--
		dAtA[i] = 0x18
	}
	if m.GameId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.GameId))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SStandUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SStandUp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SStandUp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *S2CStandUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CStandUp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CStandUp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SSitDown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SSitDown) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SSitDown) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CSitDown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CSitDown) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CSitDown) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2STips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2STips) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2STips) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *S2CTips) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CTips) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CTips) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.LeftMoney != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.LeftMoney))
		i--
		dAtA[i] = 0x18
	}
	if m.Money != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x10
	}
	if m.Idx != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Idx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CGameKick) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CGameKick) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CGameKick) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGame(dAtA []byte, offset int, v uint64) int {
	offset -= sovGame(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *C2SRoomOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.AutoBuy {
		n += 2
	}
	if m.AutoBuyMax {
		n += 2
	}
	if m.Buy != 0 {
		n += 1 + sovGame(uint64(m.Buy))
	}
	return n
}

func (m *S2CRoomOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.AutoBuy {
		n += 2
	}
	if m.AutoBuyMax {
		n += 2
	}
	if m.Buy != 0 {
		n += 1 + sovGame(uint64(m.Buy))
	}
	return n
}

func (m *C2SEnter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovGame(uint64(m.RoomId))
	}
	if m.Buy != 0 {
		n += 1 + sovGame(uint64(m.Buy))
	}
	if m.NumOfPlayers != 0 {
		n += 1 + sovGame(uint64(m.NumOfPlayers))
	}
	return n
}

func (m *S2CMoneyNotEnough) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovGame(uint64(m.RoomId))
	}
	if m.LeftMoney != 0 {
		n += 1 + sovGame(uint64(m.LeftMoney))
	}
	return n
}

func (m *C2SBuy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Buy != 0 {
		n += 1 + sovGame(uint64(m.Buy))
	}
	if m.AutoBuy {
		n += 2
	}
	return n
}

func (m *S2CBuy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *S2CAutoBuy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	if m.Money != 0 {
		n += 1 + sovGame(uint64(m.Money))
	}
	return n
}

func (m *S2CEnter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovGame(uint64(m.Result))
	}
	return n
}

func (m *C2SLeave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2CLeave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *C2SGetNumOfPlayers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovGame(uint64(m.RoomId))
	}
	return n
}

func (m *S2CGetNumOfPlayers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovGame(uint64(m.RoomId))
	}
	if m.NumOfPlayers != 0 {
		n += 1 + sovGame(uint64(m.NumOfPlayers))
	}
	return n
}

func (m *C2SCheckEnter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovGame(uint64(m.Op))
	}
	if m.State != 0 {
		n += 1 + sovGame(uint64(m.State))
	}
	if m.RemainMoney != 0 {
		n += 1 + sovGame(uint64(m.RemainMoney))
	}
	if m.OpMoney != 0 {
		n += 1 + sovGame(uint64(m.OpMoney))
	}
	if m.TotalOpMoney != 0 {
		n += 1 + sovGame(uint64(m.TotalOpMoney))
	}
	return n
}

func (m *S2CTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.GameId != 0 {
		n += 1 + sovGame(uint64(m.GameId))
	}
	if m.NumOfPlayers != 0 {
		n += 1 + sovGame(uint64(m.NumOfPlayers))
	}
	if m.Jackpot != 0 {
		n += 1 + sovGame(uint64(m.Jackpot))
	}
	if m.NumOfGame != 0 {
		n += 1 + sovGame(uint64(m.NumOfGame))
	}
	if m.NumOfLoop != 0 {
		n += 1 + sovGame(uint64(m.NumOfLoop))
	}
	if m.NumOfRound != 0 {
		n += 1 + sovGame(uint64(m.NumOfRound))
	}
	if m.OpCd != 0 {
		n += 1 + sovGame(uint64(m.OpCd))
	}
	if m.DealerIdx != 0 {
		n += 1 + sovGame(uint64(m.DealerIdx))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	if m.WaitOps != 0 {
		n += 1 + sovGame(uint64(m.WaitOps))
	}
	if len(m.HandCards) > 0 {
		l = 0
		for _, e := range m.HandCards {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	if m.SmallBlindIdx != 0 {
		n += 1 + sovGame(uint64(m.SmallBlindIdx))
	}
	if m.BigBlindIdx != 0 {
		n += 1 + sovGame(uint64(m.BigBlindIdx))
	}
	if m.NumOfStart != 0 {
		n += 2 + sovGame(uint64(m.NumOfStart))
	}
	if m.ShowHandCards {
		n += 3
	}
	return n
}

func (m *S2CPlayerEnter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *S2CPlayerLeave) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	return n
}

func (m *C2SOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovGame(uint64(m.Op))
	}
	if m.Money != 0 {
		n += 1 + sovGame(uint64(m.Money))
	}
	return n
}

func (m *S2COp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	if m.Ops != 0 {
		n += 1 + sovGame(uint64(m.Ops))
	}
	if m.State != 0 {
		n += 1 + sovGame(uint64(m.State))
	}
	if m.RemainMoney != 0 {
		n += 1 + sovGame(uint64(m.RemainMoney))
	}
	if m.OpMoney != 0 {
		n += 1 + sovGame(uint64(m.OpMoney))
	}
	if m.TotalOpMoney != 0 {
		n += 1 + sovGame(uint64(m.TotalOpMoney))
	}
	return n
}

func (m *S2CWaitOps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ops != 0 {
		n += 1 + sovGame(uint64(m.Ops))
	}
	if m.MinRaiseMoney != 0 {
		n += 1 + sovGame(uint64(m.MinRaiseMoney))
	}
	if m.CallMoney != 0 {
		n += 1 + sovGame(uint64(m.CallMoney))
	}
	return n
}

func (m *S2CGameStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovGame(uint64(m.RoomId))
	}
	if m.GameId != 0 {
		n += 1 + sovGame(uint64(m.GameId))
	}
	if m.NumOfGame != 0 {
		n += 1 + sovGame(uint64(m.NumOfGame))
	}
	if m.DealerIdx != 0 {
		n += 1 + sovGame(uint64(m.DealerIdx))
	}
	if len(m.NewPlayers) > 0 {
		l = 0
		for _, e := range m.NewPlayers {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	return n
}

func (m *PlayerStakes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	if m.Money != 0 {
		n += 1 + sovGame(uint64(m.Money))
	}
	if m.TotalMoney != 0 {
		n += 1 + sovGame(uint64(m.TotalMoney))
	}
	return n
}

func (m *S2CLoopOverBefore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EarlyOver {
		n += 2
	}
	return n
}

func (m *S2CLoopOver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumOfLoop != 0 {
		n += 1 + sovGame(uint64(m.NumOfLoop))
	}
	if m.Jackpot != 0 {
		n += 1 + sovGame(uint64(m.Jackpot))
	}
	if len(m.Stakes) > 0 {
		for _, e := range m.Stakes {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *S2CRoundOver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumOfRound != 0 {
		n += 1 + sovGame(uint64(m.NumOfRound))
	}
	return n
}

func (m *S2CDealCards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGame(uint64(m.Type))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	return n
}

func (m *PlayerCards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	return n
}

func (m *S2CShowCards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *PlayerSettle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	if m.Type != 0 {
		n += 1 + sovGame(uint64(m.Type))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	if m.TotalMoney != 0 {
		n += 1 + sovGame(uint64(m.TotalMoney))
	}
	if m.WinMoney != 0 {
		n += 1 + sovGame(uint64(m.WinMoney))
	}
	return n
}

func (m *S2CSettle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Settles) > 0 {
		for _, e := range m.Settles {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *GameInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Win {
		n += 2
	}
	if m.Stakes != 0 {
		n += 1 + sovGame(uint64(m.Stakes))
	}
	if m.RaiseFlag != 0 {
		n += 1 + sovGame(uint64(m.RaiseFlag))
	}
	if m.FoldFlag != 0 {
		n += 1 + sovGame(uint64(m.FoldFlag))
	}
	if m.CallOrRaise {
		n += 2
	}
	if m.CardValue != 0 {
		n += 1 + sovGame(uint64(m.CardValue))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	if m.CardType != 0 {
		n += 1 + sovGame(uint64(m.CardType))
	}
	if m.TotalBetMoney != 0 {
		n += 1 + sovGame(uint64(m.TotalBetMoney))
	}
	return n
}

func (m *S2CGameOver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovGame(uint64(m.RoomId))
	}
	if m.GameId != 0 {
		n += 1 + sovGame(uint64(m.GameId))
	}
	if m.PlayerId != 0 {
		n += 1 + sovGame(uint64(m.PlayerId))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *C2SStandUp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2CStandUp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *C2SSitDown) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	return n
}

func (m *S2CSitDown) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	if m.Success {
		n += 2
	}
	return n
}

func (m *C2STips) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *S2CTips) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Idx != 0 {
		n += 1 + sovGame(uint64(m.Idx))
	}
	if m.Money != 0 {
		n += 1 + sovGame(uint64(m.Money))
	}
	if m.LeftMoney != 0 {
		n += 1 + sovGame(uint64(m.LeftMoney))
	}
	if m.Success {
		n += 2
	}
	return n
}

func (m *S2CGameKick) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovGame(uint64(m.Type))
	}
	return n
}

func sovGame(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGame(x uint64) (n int) {
	return sovGame(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *C2SRoomOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SRoomOptions{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`AutoBuy:` + fmt.Sprintf("%v", this.AutoBuy) + `,`,
		`AutoBuyMax:` + fmt.Sprintf("%v", this.AutoBuyMax) + `,`,
		`Buy:` + fmt.Sprintf("%v", this.Buy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CRoomOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CRoomOptions{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`AutoBuy:` + fmt.Sprintf("%v", this.AutoBuy) + `,`,
		`AutoBuyMax:` + fmt.Sprintf("%v", this.AutoBuyMax) + `,`,
		`Buy:` + fmt.Sprintf("%v", this.Buy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SEnter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SEnter{`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`Buy:` + fmt.Sprintf("%v", this.Buy) + `,`,
		`NumOfPlayers:` + fmt.Sprintf("%v", this.NumOfPlayers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CMoneyNotEnough) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CMoneyNotEnough{`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`LeftMoney:` + fmt.Sprintf("%v", this.LeftMoney) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SBuy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SBuy{`,
		`Buy:` + fmt.Sprintf("%v", this.Buy) + `,`,
		`AutoBuy:` + fmt.Sprintf("%v", this.AutoBuy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CBuy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CBuy{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CAutoBuy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CAutoBuy{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CEnter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CEnter{`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SLeave) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SLeave{`,
		`}`,
	}, "")
	return s
}
func (this *S2CLeave) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CLeave{`,
		`}`,
	}, "")
	return s
}
func (this *C2SGetNumOfPlayers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SGetNumOfPlayers{`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CGetNumOfPlayers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CGetNumOfPlayers{`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`NumOfPlayers:` + fmt.Sprintf("%v", this.NumOfPlayers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SCheckEnter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SCheckEnter{`,
		`}`,
	}, "")
	return s
}
func (this *Player) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Player{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Head:` + fmt.Sprintf("%v", this.Head) + `,`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`RemainMoney:` + fmt.Sprintf("%v", this.RemainMoney) + `,`,
		`OpMoney:` + fmt.Sprintf("%v", this.OpMoney) + `,`,
		`TotalOpMoney:` + fmt.Sprintf("%v", this.TotalOpMoney) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CTable) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPlayers := "[]*Player{"
	for _, f := range this.Players {
		repeatedStringForPlayers += strings.Replace(f.String(), "Player", "Player", 1) + ","
	}
	repeatedStringForPlayers += "}"
	s := strings.Join([]string{`&S2CTable{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`NumOfPlayers:` + fmt.Sprintf("%v", this.NumOfPlayers) + `,`,
		`Jackpot:` + fmt.Sprintf("%v", this.Jackpot) + `,`,
		`NumOfGame:` + fmt.Sprintf("%v", this.NumOfGame) + `,`,
		`NumOfLoop:` + fmt.Sprintf("%v", this.NumOfLoop) + `,`,
		`NumOfRound:` + fmt.Sprintf("%v", this.NumOfRound) + `,`,
		`OpCd:` + fmt.Sprintf("%v", this.OpCd) + `,`,
		`DealerIdx:` + fmt.Sprintf("%v", this.DealerIdx) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`Players:` + repeatedStringForPlayers + `,`,
		`WaitOps:` + fmt.Sprintf("%v", this.WaitOps) + `,`,
		`HandCards:` + fmt.Sprintf("%v", this.HandCards) + `,`,
		`SmallBlindIdx:` + fmt.Sprintf("%v", this.SmallBlindIdx) + `,`,
		`BigBlindIdx:` + fmt.Sprintf("%v", this.BigBlindIdx) + `,`,
		`NumOfStart:` + fmt.Sprintf("%v", this.NumOfStart) + `,`,
		`ShowHandCards:` + fmt.Sprintf("%v", this.ShowHandCards) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CPlayerEnter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CPlayerEnter{`,
		`Player:` + strings.Replace(this.Player.String(), "Player", "Player", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CPlayerLeave) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CPlayerLeave{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SOp{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2COp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2COp{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`Ops:` + fmt.Sprintf("%v", this.Ops) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`RemainMoney:` + fmt.Sprintf("%v", this.RemainMoney) + `,`,
		`OpMoney:` + fmt.Sprintf("%v", this.OpMoney) + `,`,
		`TotalOpMoney:` + fmt.Sprintf("%v", this.TotalOpMoney) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CWaitOps) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CWaitOps{`,
		`Ops:` + fmt.Sprintf("%v", this.Ops) + `,`,
		`MinRaiseMoney:` + fmt.Sprintf("%v", this.MinRaiseMoney) + `,`,
		`CallMoney:` + fmt.Sprintf("%v", this.CallMoney) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CGameStart) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CGameStart{`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`NumOfGame:` + fmt.Sprintf("%v", this.NumOfGame) + `,`,
		`DealerIdx:` + fmt.Sprintf("%v", this.DealerIdx) + `,`,
		`NewPlayers:` + fmt.Sprintf("%v", this.NewPlayers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayerStakes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlayerStakes{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`TotalMoney:` + fmt.Sprintf("%v", this.TotalMoney) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CLoopOverBefore) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CLoopOverBefore{`,
		`EarlyOver:` + fmt.Sprintf("%v", this.EarlyOver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CLoopOver) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStakes := "[]*PlayerStakes{"
	for _, f := range this.Stakes {
		repeatedStringForStakes += strings.Replace(f.String(), "PlayerStakes", "PlayerStakes", 1) + ","
	}
	repeatedStringForStakes += "}"
	s := strings.Join([]string{`&S2CLoopOver{`,
		`NumOfLoop:` + fmt.Sprintf("%v", this.NumOfLoop) + `,`,
		`Jackpot:` + fmt.Sprintf("%v", this.Jackpot) + `,`,
		`Stakes:` + repeatedStringForStakes + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CRoundOver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CRoundOver{`,
		`NumOfRound:` + fmt.Sprintf("%v", this.NumOfRound) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CDealCards) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CDealCards{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayerCards) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlayerCards{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CShowCards) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCards := "[]*PlayerCards{"
	for _, f := range this.Cards {
		repeatedStringForCards += strings.Replace(f.String(), "PlayerCards", "PlayerCards", 1) + ","
	}
	repeatedStringForCards += "}"
	s := strings.Join([]string{`&S2CShowCards{`,
		`Cards:` + repeatedStringForCards + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlayerSettle) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PlayerSettle{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`TotalMoney:` + fmt.Sprintf("%v", this.TotalMoney) + `,`,
		`WinMoney:` + fmt.Sprintf("%v", this.WinMoney) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CSettle) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSettles := "[]*PlayerSettle{"
	for _, f := range this.Settles {
		repeatedStringForSettles += strings.Replace(f.String(), "PlayerSettle", "PlayerSettle", 1) + ","
	}
	repeatedStringForSettles += "}"
	s := strings.Join([]string{`&S2CSettle{`,
		`Settles:` + repeatedStringForSettles + `,`,
		`}`,
	}, "")
	return s
}
func (this *GameInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GameInfo{`,
		`Win:` + fmt.Sprintf("%v", this.Win) + `,`,
		`Stakes:` + fmt.Sprintf("%v", this.Stakes) + `,`,
		`RaiseFlag:` + fmt.Sprintf("%v", this.RaiseFlag) + `,`,
		`FoldFlag:` + fmt.Sprintf("%v", this.FoldFlag) + `,`,
		`CallOrRaise:` + fmt.Sprintf("%v", this.CallOrRaise) + `,`,
		`CardValue:` + fmt.Sprintf("%v", this.CardValue) + `,`,
		`Cards:` + fmt.Sprintf("%v", this.Cards) + `,`,
		`CardType:` + fmt.Sprintf("%v", this.CardType) + `,`,
		`TotalBetMoney:` + fmt.Sprintf("%v", this.TotalBetMoney) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CGameOver) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CGameOver{`,
		`RoomId:` + fmt.Sprintf("%v", this.RoomId) + `,`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`PlayerId:` + fmt.Sprintf("%v", this.PlayerId) + `,`,
		`Info:` + strings.Replace(this.Info.String(), "GameInfo", "GameInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SStandUp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SStandUp{`,
		`}`,
	}, "")
	return s
}
func (this *S2CStandUp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CStandUp{`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2SSitDown) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2SSitDown{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CSitDown) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CSitDown{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *C2STips) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&C2STips{`,
		`}`,
	}, "")
	return s
}
func (this *S2CTips) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CTips{`,
		`Idx:` + fmt.Sprintf("%v", this.Idx) + `,`,
		`Money:` + fmt.Sprintf("%v", this.Money) + `,`,
		`LeftMoney:` + fmt.Sprintf("%v", this.LeftMoney) + `,`,
		`Success:` + fmt.Sprintf("%v", this.Success) + `,`,
		`}`,
	}, "")
	return s
}
func (this *S2CGameKick) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&S2CGameKick{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGame(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *C2SRoomOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SRoomOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SRoomOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoBuy = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoBuyMax", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoBuyMax = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buy", wireType)
			}
			m.Buy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Buy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CRoomOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CRoomOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CRoomOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoBuy = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoBuyMax", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoBuyMax = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buy", wireType)
			}
			m.Buy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Buy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SEnter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SEnter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SEnter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buy", wireType)
			}
			m.Buy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Buy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPlayers", wireType)
			}
			m.NumOfPlayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPlayers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CMoneyNotEnough) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CMoneyNotEnough: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CMoneyNotEnough: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftMoney", wireType)
			}
			m.LeftMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SBuy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SBuy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SBuy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buy", wireType)
			}
			m.Buy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Buy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoBuy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CBuy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CBuy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CBuy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CAutoBuy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CAutoBuy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CAutoBuy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CEnter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CEnter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CEnter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= EnterResult(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SLeave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SLeave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SLeave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CLeave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CLeave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CLeave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SGetNumOfPlayers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SGetNumOfPlayers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SGetNumOfPlayers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGetNumOfPlayers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGetNumOfPlayers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGetNumOfPlayers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPlayers", wireType)
			}
			m.NumOfPlayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPlayers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SCheckEnter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SCheckEnter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SCheckEnter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Ops(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= States(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainMoney", wireType)
			}
			m.RemainMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpMoney", wireType)
			}
			m.OpMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalOpMoney", wireType)
			}
			m.TotalOpMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalOpMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfPlayers", wireType)
			}
			m.NumOfPlayers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfPlayers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jackpot", wireType)
			}
			m.Jackpot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jackpot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfGame", wireType)
			}
			m.NumOfGame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfGame |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfLoop", wireType)
			}
			m.NumOfLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfRound", wireType)
			}
			m.NumOfRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfRound |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpCd", wireType)
			}
			m.OpCd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpCd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealerIdx", wireType)
			}
			m.DealerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DealerIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGame
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cards) == 0 {
					m.Cards = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitOps", wireType)
			}
			m.WaitOps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitOps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HandCards = append(m.HandCards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGame
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.HandCards) == 0 {
					m.HandCards = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HandCards = append(m.HandCards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HandCards", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallBlindIdx", wireType)
			}
			m.SmallBlindIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SmallBlindIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigBlindIdx", wireType)
			}
			m.BigBlindIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BigBlindIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfStart", wireType)
			}
			m.NumOfStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfStart |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowHandCards", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShowHandCards = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CPlayerEnter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CPlayerEnter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CPlayerEnter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CPlayerLeave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CPlayerLeave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CPlayerLeave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= Ops(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2COp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2COp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2COp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			m.Ops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ops |= Ops(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= States(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainMoney", wireType)
			}
			m.RemainMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpMoney", wireType)
			}
			m.OpMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalOpMoney", wireType)
			}
			m.TotalOpMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalOpMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CWaitOps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CWaitOps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CWaitOps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			m.Ops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ops |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRaiseMoney", wireType)
			}
			m.MinRaiseMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinRaiseMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallMoney", wireType)
			}
			m.CallMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGameStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGameStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGameStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfGame", wireType)
			}
			m.NumOfGame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfGame |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealerIdx", wireType)
			}
			m.DealerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DealerIdx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewPlayers = append(m.NewPlayers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGame
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewPlayers) == 0 {
					m.NewPlayers = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewPlayers = append(m.NewPlayers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPlayers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerStakes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerStakes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerStakes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMoney", wireType)
			}
			m.TotalMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CLoopOverBefore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CLoopOverBefore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CLoopOverBefore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarlyOver", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EarlyOver = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CLoopOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CLoopOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CLoopOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfLoop", wireType)
			}
			m.NumOfLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfLoop |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jackpot", wireType)
			}
			m.Jackpot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jackpot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stakes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stakes = append(m.Stakes, &PlayerStakes{})
			if err := m.Stakes[len(m.Stakes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CRoundOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CRoundOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CRoundOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumOfRound", wireType)
			}
			m.NumOfRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumOfRound |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CDealCards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CDealCards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CDealCards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DealCardsType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGame
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cards) == 0 {
					m.Cards = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerCards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerCards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerCards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGame
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cards) == 0 {
					m.Cards = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CShowCards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CShowCards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CShowCards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &PlayerCards{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerSettle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerSettle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerSettle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CardTypes(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGame
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cards) == 0 {
					m.Cards = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMoney", wireType)
			}
			m.TotalMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinMoney", wireType)
			}
			m.WinMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CSettle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CSettle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CSettle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settles = append(m.Settles, &PlayerSettle{})
			if err := m.Settles[len(m.Settles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Win = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stakes", wireType)
			}
			m.Stakes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stakes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaiseFlag", wireType)
			}
			m.RaiseFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaiseFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoldFlag", wireType)
			}
			m.FoldFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FoldFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallOrRaise", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CallOrRaise = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardValue", wireType)
			}
			m.CardValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGame
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cards) == 0 {
					m.Cards = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardType", wireType)
			}
			m.CardType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardType |= CardTypes(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBetMoney", wireType)
			}
			m.TotalBetMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBetMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGameOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGameOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGameOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerId", wireType)
			}
			m.PlayerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &GameInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SStandUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SStandUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SStandUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CStandUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CStandUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CStandUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SSitDown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SSitDown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SSitDown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CSitDown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CSitDown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CSitDown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2STips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2STips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2STips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CTips) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CTips: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CTips: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftMoney", wireType)
			}
			m.LeftMoney = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftMoney |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CGameKick) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: S2CGameKick: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: S2CGameKick: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= KickType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGame(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGame
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGame
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGame
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGame
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGame        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGame          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGame = fmt.Errorf("proto: unexpected end of group")
)
